<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2019 Scott Morrison. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Scott Morrison</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  import topology.sheaves.presheaf</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/sheaves/presheaf.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  import topology.category.TopCommRing</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/TopCommRing.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  import category_theory.yoneda</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/yoneda.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  import ring_theory.subring</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/subring.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  import topology.algebra.continuous_functions</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/continuous_functions.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  universes v u</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  open category_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  open topological_space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  open opposite</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  namespace Top</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  variables (X : Top.{v})</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  /-- The presheaf of continuous functions on `X` with values in fixed target topological space `T`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  def presheaf_to_Top (T : Top.{v}) : X.presheaf (Type v) :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  (opens.to_Top X).op ⋙ (yoneda.obj T)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  /-- The (bundled) commutative ring of continuous functions from a topological space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  to a topological commutative ring, with pointwise multiplication. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  -- TODO upgrade the result to TopCommRing?</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  def continuous_functions (X : Top.{v}ᵒᵖ) (R : TopCommRing.{v}) : CommRing.{v} :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='Top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='TopCommRing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='CommRing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/Top/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/TopCommRing.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/category/CommRing/basic.lean&#x27;, &#x27;line&#x27;: 119, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type (v+1) → Type (v+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='The category of topological spaces and continuous maps.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='A bundled topological commutative ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The category of commutative rings.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  { α := unop X ⟶ (forget₂ TopCommRing Top).obj R,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='opposite.unop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.forget₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='TopCommRing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/TopCommRing.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/Top/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Sort u}, opposite.{u} α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{v+2} Top.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (v+1)} [c : category_theory.has_hom.{v v+1} obj], obj → obj → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (C D : Type (u+1)) [_inst_1 : category_theory.concrete_category.{u} C] [_inst_2 : category_theory.concrete_category.{u} D] [_inst_3 : @category_theory.has_forget₂.{u} C D _inst_1 _inst_2], @category_theory.functor.{u u u+1 u+1} C (@category_theory.concrete_category.to_category.{u} C _inst_1) D (@category_theory.concrete_category.to_category.{u} D _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (v+1)} [_inst_1 : category_theory.category.{v v+1} C] {D : Type (v+1)} [_inst_2 : category_theory.category.{v v+1} D], @category_theory.functor.{v v v+1 v+1} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='TopCommRing.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title=' The forgetful functor `C ⥤ D` between concrete categories for which we have an instance
`has_forget₂ C `.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A bundled topological commutative ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The category of topological spaces and continuous maps.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31    str := _root_.continuous_comm_ring }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='continuous_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/continuous_functions.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : topological_space.{u} α] [_inst_2 : topological_space.{v} β] [_inst_3 : comm_ring.{v} β] [_inst_4 : @topological_ring.{v} β _inst_2 (@comm_ring.to_ring.{v} β _inst_3)], comm_ring.{(max u v)} (@coe_sort.{(max ((max u v)+1) 1) (max 1 ((max u v)+1))+1} (set.{(max u v)} (α → β)) (@set.has_coe_to_sort.{(max u v)} (α → β)) (@set_of.{(max u v)} (α → β) (λ (f : α → β), @continuous.{u v} α β _inst_1 _inst_2 f)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  namespace continuous_functions</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  @[simp] lemma one (X : Top.{v}ᵒᵖ) (R : TopCommRing.{v}) (x) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='Top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='TopCommRing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/Top/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/TopCommRing.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type (v+1) → Type (v+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The category of topological spaces and continuous maps.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='A bundled topological commutative ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35    (monoid.one ↥(continuous_functions X R)).val x = 1 := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='monoid.one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='coe_sort'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Top.continuous_functions'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 29, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u) [c : monoid.{u} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {a : Type (v+1)} [_inst_1 : has_coe_to_sort.{v+2 v+2} a], a → @has_coe_to_sort.S.{v+2 v+2} a _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{v+2} Top.{v} → TopCommRing.{v} → CommRing.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{v+2} Top.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='TopCommRing.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v} {p : α → Prop}, @subtype.{v+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.bundled.α.{v v} topological_space.{v} (@opposite.unop.{v+2} Top.{v} X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α : Type v} {a : α}, @eq.{v+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title=' The (bundled) commutative ring of continuous functions from a topological space
to a topological commutative ring, with pointwise multiplication.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36  @[simp] lemma zero (X : Top.{v}ᵒᵖ) (R : TopCommRing.{v}) (x) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='Top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='TopCommRing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/Top/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/TopCommRing.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type (v+1) → Type (v+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The category of topological spaces and continuous maps.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='A bundled topological commutative ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37    (comm_ring.zero ↥(continuous_functions X R)).val x = 0 := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='comm_ring.zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='coe_sort'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Top.continuous_functions'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 29, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u) [c : comm_ring.{u} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {a : Type (v+1)} [_inst_1 : has_coe_to_sort.{v+2 v+2} a], a → @has_coe_to_sort.S.{v+2 v+2} a _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{v+2} Top.{v} → TopCommRing.{v} → CommRing.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{v+2} Top.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='TopCommRing.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v} {p : α → Prop}, @subtype.{v+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.bundled.α.{v v} topological_space.{v} (@opposite.unop.{v+2} Top.{v} X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α : Type v} {a : α}, @eq.{v+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title=' The (bundled) commutative ring of continuous functions from a topological space
to a topological commutative ring, with pointwise multiplication.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  @[simp] lemma add (X : Top.{v}ᵒᵖ) (R : TopCommRing.{v}) (f g : continuous_functions X R) (x) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='Top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='TopCommRing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='Top.continuous_functions'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/Top/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/TopCommRing.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 29, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type (v+1) → Type (v+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='opposite.{v+2} Top.{v} → TopCommRing.{v} → CommRing.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{v+2} Top.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='TopCommRing.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The category of topological spaces and continuous maps.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='A bundled topological commutative ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title=' The (bundled) commutative ring of continuous functions from a topological space
to a topological commutative ring, with pointwise multiplication.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39    (comm_ring.add f g).val x = f.1 x + g.1 x := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='comm_ring.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} [c : comm_ring.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{v+2 v+2} CommRing.{v} CommRing.has_coe_to_sort.{v} (Top.continuous_functions.{v} X R)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{v+2 v+2} CommRing.{v} CommRing.has_coe_to_sort.{v} (Top.continuous_functions.{v} X R)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} {p : α → Prop}, @subtype.{v+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.bundled.α.{v v} topological_space.{v} (@opposite.unop.{v+2} Top.{v} X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{v+2 v+2} CommRing.{v} CommRing.has_coe_to_sort.{v} (Top.continuous_functions.{v} X R)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} {p : α → Prop}, @subtype.{v+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.bundled.α.{v v} topological_space.{v} (@opposite.unop.{v+2} Top.{v} X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_add.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{v+2 v+2} CommRing.{v} CommRing.has_coe_to_sort.{v} (Top.continuous_functions.{v} X R)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} {p : α → Prop}, @subtype.{v+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.bundled.α.{v v} topological_space.{v} (@opposite.unop.{v+2} Top.{v} X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type v} {a : α}, @eq.{v+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  @[simp] lemma mul (X : Top.{v}ᵒᵖ) (R : TopCommRing.{v}) (f g : continuous_functions X R) (x) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='Top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='TopCommRing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='Top.continuous_functions'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/Top/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/TopCommRing.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 29, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type (v+1) → Type (v+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='opposite.{v+2} Top.{v} → TopCommRing.{v} → CommRing.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{v+2} Top.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='TopCommRing.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The category of topological spaces and continuous maps.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='A bundled topological commutative ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title=' The (bundled) commutative ring of continuous functions from a topological space
to a topological commutative ring, with pointwise multiplication.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41    (ring.mul f g).val x = f.1 x * g.1 x := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ring.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 163, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} [c : ring.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{v+2 v+2} CommRing.{v} CommRing.has_coe_to_sort.{v} (Top.continuous_functions.{v} X R)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{v+2 v+2} CommRing.{v} CommRing.has_coe_to_sort.{v} (Top.continuous_functions.{v} X R)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} {p : α → Prop}, @subtype.{v+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.bundled.α.{v v} topological_space.{v} (@opposite.unop.{v+2} Top.{v} X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{v+2 v+2} CommRing.{v} CommRing.has_coe_to_sort.{v} (Top.continuous_functions.{v} X R)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} {p : α → Prop}, @subtype.{v+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.bundled.α.{v v} topological_space.{v} (@opposite.unop.{v+2} Top.{v} X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_mul.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{v+2 v+2} CommRing.{v} CommRing.has_coe_to_sort.{v} (Top.continuous_functions.{v} X R)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} {p : α → Prop}, @subtype.{v+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.bundled.α.{v v} topological_space.{v} (@opposite.unop.{v+2} Top.{v} X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type v} {a : α}, @eq.{v+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  /-- Pulling back functions into a topological ring along a continuous map is a ring homomorphism. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  def pullback {X Y : Topᵒᵖ} (f : X ⟶ Y) (R : TopCommRing) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='Top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='TopCommRing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/Top/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/TopCommRing.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type (u_1+1) → Type (u_1+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='opposite.{u_1+2} Top.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (u_1+1)} [c : category_theory.has_hom.{u_1 u_1+1} obj], obj → obj → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{u_1+2} Top.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The category of topological spaces and continuous maps.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='A bundled topological commutative ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45    continuous_functions X R ⟶ continuous_functions Y R :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Top.continuous_functions'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Top.continuous_functions'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 29, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 29, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='opposite.{v+2} Top.{v} → TopCommRing.{v} → CommRing.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{u_1+2} Top.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='TopCommRing.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (u_1+1)} [c : category_theory.has_hom.{u_1 u_1+1} obj], obj → obj → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{v+2} Top.{v} → TopCommRing.{v} → CommRing.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{u_1+2} Top.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='TopCommRing.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' The (bundled) commutative ring of continuous functions from a topological space
to a topological commutative ring, with pointwise multiplication.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title=' The (bundled) commutative ring of continuous functions from a topological space
to a topological commutative ring, with pointwise multiplication.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  { to_fun := λ g, f.unop ≫ g,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.has_hom.hom.unop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@category_theory.bundled.α.{u_1 u_1} (λ (α : Type u_1), ring.{u_1} α) (@category_theory.bundled.map.{u_1 u_1} (λ (α : Type u_1), comm_ring.{u_1} α) (λ (α : Type u_1), ring.{u_1} α) comm_ring.to_ring.{u_1} (Top.continuous_functions.{u_1} X R))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{u_1 u_1+1} (opposite.{u_1+2} Top.{u_1}) (@category_theory.has_hom.opposite.{u_1 u_1+1} Top.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} Top.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} Top.{u_1} (@category_theory.bundled_hom.category.{u_1} topological_space.{u_1} (λ (α β : Type u_1) (Iα : topological_space.{u_1} α) (Iβ : topological_space.{u_1} β), @subtype.{u_1+1} (α → β) (@continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), topological_space.{u_1} α) continuous.{u_1 u_1} Top.concrete_category_continuous.{u_1}))))) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (u_1+1)} [𝒞 : category_theory.has_hom.{u_1 u_1+1} C] {X Y : opposite.{u_1+2} C}, @category_theory.has_hom.hom.{u_1 u_1+1} (opposite.{u_1+2} C) (@category_theory.has_hom.opposite.{u_1 u_1+1} C 𝒞) X Y → @category_theory.has_hom.hom.{u_1 u_1+1} C 𝒞 (@opposite.unop.{u_1+2} C Y) (@opposite.unop.{u_1+2} C X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (u_1+1)} [c : category_theory.category_struct.{u_1 u_1+1} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{u_1 u_1+1} obj (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} obj c) X Y → @category_theory.has_hom.hom.{u_1 u_1+1} obj (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} obj c) Y Z → @category_theory.has_hom.hom.{u_1 u_1+1} obj (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.bundled.α.{u_1 u_1} (λ (α : Type u_1), ring.{u_1} α) (@category_theory.bundled.map.{u_1 u_1} (λ (α : Type u_1), comm_ring.{u_1} α) (λ (α : Type u_1), ring.{u_1} α) comm_ring.to_ring.{u_1} (Top.continuous_functions.{u_1} X R))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47    map_one&#x27; := rfl,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='∀ {α : Sort u} {a : α}, @eq.{u} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48    map_zero&#x27; := rfl,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='∀ {α : Sort u} {a : α}, @eq.{u} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49    map_add&#x27; := by tidy,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/tidy.lean&#x27;, &#x27;line&#x27;: 91, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → opt_param.{1} tactic.tidy.cfg {trace_result := bool.ff, trace_result_prefix := string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))), tactics := tactic.tidy.default_tactics} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title=' Use a variety of conservative tactics to solve goals.
`tidy?` reports back the tactic script it found.
The default list of tactics is stored in `tactic.tidy.default_tidy_tactics`.
This list can be overridden using `tidy { tactics := ... }`.
(The list must be a `list` of `tactic string`, so that `tidy?`
can report a usable tactic script.) 

Tactics can also be added to the list by tagging them (locally) with the
`[tidy]` attribute.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='tidy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;??&#x27;, &#x27;tactic.tidy.cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='lime'><a title='X Y : opposite.{?l_1+2} Top.{?l_1},
f :
  @category_theory.has_hom.hom.{?l_1 ?l_1+1} (opposite.{?l_1+2} Top.{?l_1})
    (@category_theory.has_hom.opposite.{?l_1 ?l_1+1} Top.{?l_1}
       (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} Top.{?l_1}
          (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} Top.{?l_1}
             (@category_theory.bundled_hom.category.{?l_1} topological_space.{?l_1}
                (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                   @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), topological_space.{?l_1} α)
                   continuous.{?l_1 ?l_1}
                   Top.concrete_category_continuous.{?l_1})))))
    X
    Y,
R : TopCommRing.{?l_1}
⊢ ∀
  (x y :
    @category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
      (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
         (λ (α : Type ?l_1), ring.{?l_1} α)
         comm_ring.to_ring.{?l_1}
         (Top.continuous_functions.{?l_1} X R))),
    @eq.{?l_1+1}
      (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
         (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
            (λ (α : Type ?l_1), ring.{?l_1} α)
            comm_ring.to_ring.{?l_1}
            (Top.continuous_functions.{?l_1} Y R)))
      ((λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
        (f :
          @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
            (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (λ (X Y : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1}),
                  (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                     @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
                    (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} X)
                    (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} Y)
                    (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
                    (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)))
            X
            Y)
        (g :
          @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
            (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (λ (X Y : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1}),
                  (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                     @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
                    (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} X)
                    (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} Y)
                    (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
                    (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)))
            Y
            Z),
          @category_theory.bundled_hom.comp.{?l_1} topological_space.{?l_1}
            (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
               @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
            (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), topological_space.{?l_1} α)
               continuous.{?l_1 ?l_1}
               Top.concrete_category_continuous.{?l_1})
            (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
               X)
            (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
               Y)
            (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
               Z)
            (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
            (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)
            (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Z)
            g
            f)
         (@opposite.unop.{?l_1+2} Top.{?l_1} Y)
         (@opposite.unop.{?l_1+2} Top.{?l_1} X)
         ((λ (X : TopCommRing.{?l_1}),
             (λ (R : TopCommRing.{?l_1}),
                @Top.of.{?l_1} (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                  (TopCommRing.forget_topological_space.{?l_1} R))
               X)
            R)
         (@category_theory.has_hom.hom.unop.{?l_1 ?l_1+1} Top.{?l_1}
            (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (λ (X Y : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1}),
                  (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                     @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
                    (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} X)
                    (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} Y)
                    (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
                    (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)))
            X
            Y
            f)
         (@add_comm_monoid.add.{?l_1}
            (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
               (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                  (λ (α : Type ?l_1), ring.{?l_1} α)
                  comm_ring.to_ring.{?l_1}
                  (Top.continuous_functions.{?l_1} X R)))
            (@semiring.to_add_comm_monoid.{?l_1}
               (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
                  (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                     (λ (α : Type ?l_1), ring.{?l_1} α)
                     comm_ring.to_ring.{?l_1}
                     (Top.continuous_functions.{?l_1} X R)))
               (@ring.to_semiring.{?l_1}
                  (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
                     (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                        (λ (α : Type ?l_1), ring.{?l_1} α)
                        comm_ring.to_ring.{?l_1}
                        (Top.continuous_functions.{?l_1} X R)))
                  (@category_theory.bundled.str.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
                     (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                        (λ (α : Type ?l_1), ring.{?l_1} α)
                        comm_ring.to_ring.{?l_1}
                        (Top.continuous_functions.{?l_1} X R)))))
            x
            y))
      (@add_comm_monoid.add.{?l_1}
         (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
            (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
               (λ (α : Type ?l_1), ring.{?l_1} α)
               comm_ring.to_ring.{?l_1}
               (Top.continuous_functions.{?l_1} Y R)))
         (@semiring.to_add_comm_monoid.{?l_1}
            (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
               (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                  (λ (α : Type ?l_1), ring.{?l_1} α)
                  comm_ring.to_ring.{?l_1}
                  (Top.continuous_functions.{?l_1} Y R)))
            (@ring.to_semiring.{?l_1}
               (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
                  (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                     (λ (α : Type ?l_1), ring.{?l_1} α)
                     comm_ring.to_ring.{?l_1}
                     (Top.continuous_functions.{?l_1} Y R)))
               (@category_theory.bundled.str.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
                  (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                     (λ (α : Type ?l_1), ring.{?l_1} α)
                     comm_ring.to_ring.{?l_1}
                     (Top.continuous_functions.{?l_1} Y R)))))
         ((λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
           (f :
             @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1}),
                     (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                        @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} Y)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)))
               X
               Y)
           (g :
             @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1}),
                     (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                        @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} Y)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)))
               Y
               Z),
             @category_theory.bundled_hom.comp.{?l_1} topological_space.{?l_1}
               (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                  @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
               (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), topological_space.{?l_1} α)
                  continuous.{?l_1 ?l_1}
                  Top.concrete_category_continuous.{?l_1})
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
                  X)
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
                  Y)
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
                  Z)
               (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
               (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)
               (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Z)
               g
               f)
            (@opposite.unop.{?l_1+2} Top.{?l_1} Y)
            (@opposite.unop.{?l_1+2} Top.{?l_1} X)
            ((λ (X : TopCommRing.{?l_1}),
                (λ (R : TopCommRing.{?l_1}),
                   @Top.of.{?l_1} (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                     (TopCommRing.forget_topological_space.{?l_1} R))
                  X)
               R)
            (@category_theory.has_hom.hom.unop.{?l_1 ?l_1+1} Top.{?l_1}
               (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1}),
                     (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                        @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} Y)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)))
               X
               Y
               f)
            x)
         ((λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
           (f :
             @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1}),
                     (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                        @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} Y)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)))
               X
               Y)
           (g :
             @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1}),
                     (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                        @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} Y)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)))
               Y
               Z),
             @category_theory.bundled_hom.comp.{?l_1} topological_space.{?l_1}
               (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                  @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
               (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), topological_space.{?l_1} α)
                  continuous.{?l_1 ?l_1}
                  Top.concrete_category_continuous.{?l_1})
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
                  X)
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
                  Y)
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
                  Z)
               (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
               (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)
               (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Z)
               g
               f)
            (@opposite.unop.{?l_1+2} Top.{?l_1} Y)
            (@opposite.unop.{?l_1+2} Top.{?l_1} X)
            ((λ (X : TopCommRing.{?l_1}),
                (λ (R : TopCommRing.{?l_1}),
                   @Top.of.{?l_1} (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                     (TopCommRing.forget_topological_space.{?l_1} R))
                  X)
               R)
            (@category_theory.has_hom.hom.unop.{?l_1 ?l_1+1} Top.{?l_1}
               (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1}),
                     (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                        @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} Y)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)))
               X
               Y
               f)
            y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50    map_mul&#x27; := by tidy }</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/tidy.lean&#x27;, &#x27;line&#x27;: 91, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → opt_param.{1} tactic.tidy.cfg {trace_result := bool.ff, trace_result_prefix := string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))), tactics := tactic.tidy.default_tactics} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title=' Use a variety of conservative tactics to solve goals.
`tidy?` reports back the tactic script it found.
The default list of tactics is stored in `tactic.tidy.default_tidy_tactics`.
This list can be overridden using `tidy { tactics := ... }`.
(The list must be a `list` of `tactic string`, so that `tidy?`
can report a usable tactic script.) 

Tactics can also be added to the list by tagging them (locally) with the
`[tidy]` attribute.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='tidy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;??&#x27;, &#x27;tactic.tidy.cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='lime'><a title='X Y : opposite.{?l_1+2} Top.{?l_1},
f :
  @category_theory.has_hom.hom.{?l_1 ?l_1+1} (opposite.{?l_1+2} Top.{?l_1})
    (@category_theory.has_hom.opposite.{?l_1 ?l_1+1} Top.{?l_1}
       (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} Top.{?l_1}
          (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} Top.{?l_1}
             (@category_theory.bundled_hom.category.{?l_1} topological_space.{?l_1}
                (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                   @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), topological_space.{?l_1} α)
                   continuous.{?l_1 ?l_1}
                   Top.concrete_category_continuous.{?l_1})))))
    X
    Y,
R : TopCommRing.{?l_1}
⊢ ∀
  (x y :
    @category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
      (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
         (λ (α : Type ?l_1), ring.{?l_1} α)
         comm_ring.to_ring.{?l_1}
         (Top.continuous_functions.{?l_1} X R))),
    @eq.{?l_1+1}
      (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
         (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
            (λ (α : Type ?l_1), ring.{?l_1} α)
            comm_ring.to_ring.{?l_1}
            (Top.continuous_functions.{?l_1} Y R)))
      ((λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
        (f :
          @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
            (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (λ (X Y : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1}),
                  (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                     @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
                    (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} X)
                    (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} Y)
                    (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
                    (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)))
            X
            Y)
        (g :
          @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
            (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (λ (X Y : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1}),
                  (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                     @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
                    (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} X)
                    (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} Y)
                    (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
                    (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)))
            Y
            Z),
          @category_theory.bundled_hom.comp.{?l_1} topological_space.{?l_1}
            (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
               @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
            (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), topological_space.{?l_1} α)
               continuous.{?l_1 ?l_1}
               Top.concrete_category_continuous.{?l_1})
            (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
               X)
            (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
               Y)
            (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
               Z)
            (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
            (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)
            (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Z)
            g
            f)
         (@opposite.unop.{?l_1+2} Top.{?l_1} Y)
         (@opposite.unop.{?l_1+2} Top.{?l_1} X)
         ((λ (X : TopCommRing.{?l_1}),
             (λ (R : TopCommRing.{?l_1}),
                @Top.of.{?l_1} (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                  (TopCommRing.forget_topological_space.{?l_1} R))
               X)
            R)
         (@category_theory.has_hom.hom.unop.{?l_1 ?l_1+1} Top.{?l_1}
            (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (λ (X Y : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1}),
                  (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                     @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
                    (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} X)
                    (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} Y)
                    (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
                    (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)))
            X
            Y
            f)
         (@semiring.mul.{?l_1}
            (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
               (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                  (λ (α : Type ?l_1), ring.{?l_1} α)
                  comm_ring.to_ring.{?l_1}
                  (Top.continuous_functions.{?l_1} X R)))
            (@ring.to_semiring.{?l_1}
               (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
                  (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                     (λ (α : Type ?l_1), ring.{?l_1} α)
                     comm_ring.to_ring.{?l_1}
                     (Top.continuous_functions.{?l_1} X R)))
               (@category_theory.bundled.str.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
                  (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                     (λ (α : Type ?l_1), ring.{?l_1} α)
                     comm_ring.to_ring.{?l_1}
                     (Top.continuous_functions.{?l_1} X R))))
            x
            y))
      (@semiring.mul.{?l_1}
         (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
            (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
               (λ (α : Type ?l_1), ring.{?l_1} α)
               comm_ring.to_ring.{?l_1}
               (Top.continuous_functions.{?l_1} Y R)))
         (@ring.to_semiring.{?l_1}
            (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
               (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                  (λ (α : Type ?l_1), ring.{?l_1} α)
                  comm_ring.to_ring.{?l_1}
                  (Top.continuous_functions.{?l_1} Y R)))
            (@category_theory.bundled.str.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
               (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                  (λ (α : Type ?l_1), ring.{?l_1} α)
                  comm_ring.to_ring.{?l_1}
                  (Top.continuous_functions.{?l_1} Y R))))
         ((λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
           (f :
             @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1}),
                     (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                        @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} Y)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)))
               X
               Y)
           (g :
             @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1}),
                     (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                        @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} Y)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)))
               Y
               Z),
             @category_theory.bundled_hom.comp.{?l_1} topological_space.{?l_1}
               (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                  @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
               (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), topological_space.{?l_1} α)
                  continuous.{?l_1 ?l_1}
                  Top.concrete_category_continuous.{?l_1})
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
                  X)
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
                  Y)
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
                  Z)
               (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
               (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)
               (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Z)
               g
               f)
            (@opposite.unop.{?l_1+2} Top.{?l_1} Y)
            (@opposite.unop.{?l_1+2} Top.{?l_1} X)
            ((λ (X : TopCommRing.{?l_1}),
                (λ (R : TopCommRing.{?l_1}),
                   @Top.of.{?l_1} (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                     (TopCommRing.forget_topological_space.{?l_1} R))
                  X)
               R)
            (@category_theory.has_hom.hom.unop.{?l_1 ?l_1+1} Top.{?l_1}
               (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1}),
                     (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                        @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} Y)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)))
               X
               Y
               f)
            x)
         ((λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
           (f :
             @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1}),
                     (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                        @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} Y)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)))
               X
               Y)
           (g :
             @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1}),
                     (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                        @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} Y)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)))
               Y
               Z),
             @category_theory.bundled_hom.comp.{?l_1} topological_space.{?l_1}
               (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                  @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
               (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), topological_space.{?l_1} α)
                  continuous.{?l_1 ?l_1}
                  Top.concrete_category_continuous.{?l_1})
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
                  X)
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
                  Y)
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
                  Z)
               (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
               (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)
               (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Z)
               g
               f)
            (@opposite.unop.{?l_1+2} Top.{?l_1} Y)
            (@opposite.unop.{?l_1+2} Top.{?l_1} X)
            ((λ (X : TopCommRing.{?l_1}),
                (λ (R : TopCommRing.{?l_1}),
                   @Top.of.{?l_1} (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                     (TopCommRing.forget_topological_space.{?l_1} R))
                  X)
               R)
            (@category_theory.has_hom.hom.unop.{?l_1 ?l_1+1} Top.{?l_1}
               (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1}),
                     (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                        @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} Y)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)))
               X
               Y
               f)
            y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  local attribute [ext] subtype.eq</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='subtype.eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/subtype/basic.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='∀ {α : Type u} {p : α → Prop} {a1 a2 : @subtype.{u+1} α (λ (x : α), p x)}, @eq.{u+1} α (@subtype.val.{u+1} α (λ (x : α), p x) a1) (@subtype.val.{u+1} α (λ (x : α), p x) a2) → @eq.{(max 1 (u+1))} (@subtype.{u+1} α (λ (x : α), p x)) a1 a2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='lemmas usable by `ext` tactic'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54  /-- A homomorphism of topological rings can be postcomposed with functions from a source space `X`;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  this is a ring homomorphism (with respect to the pointwise ring operations on functions). -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56  def map (X : Topᵒᵖ) {R S : TopCommRing} (φ : R ⟶ S) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='Top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='TopCommRing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/Top/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/TopCommRing.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type (u_1+1) → Type (u_1+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='TopCommRing.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (u_1+1)} [c : category_theory.has_hom.{u_1 u_1+1} obj], obj → obj → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='TopCommRing.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The category of topological spaces and continuous maps.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='A bundled topological commutative ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57    continuous_functions X R ⟶ continuous_functions X S :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Top.continuous_functions'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Top.continuous_functions'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 29, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 29, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='opposite.{v+2} Top.{v} → TopCommRing.{v} → CommRing.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{u_1+2} Top.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='TopCommRing.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (u_1+1)} [c : category_theory.has_hom.{u_1 u_1+1} obj], obj → obj → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{v+2} Top.{v} → TopCommRing.{v} → CommRing.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{u_1+2} Top.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='TopCommRing.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' The (bundled) commutative ring of continuous functions from a topological space
to a topological commutative ring, with pointwise multiplication.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title=' The (bundled) commutative ring of continuous functions from a topological space
to a topological commutative ring, with pointwise multiplication.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58  { to_fun := λ g, g ≫ ((forget₂ TopCommRing Top).map φ),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.forget₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='TopCommRing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/TopCommRing.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/Top/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@category_theory.bundled.α.{u_1 u_1} (λ (α : Type u_1), ring.{u_1} α) (@category_theory.bundled.map.{u_1 u_1} (λ (α : Type u_1), comm_ring.{u_1} α) (λ (α : Type u_1), ring.{u_1} α) comm_ring.to_ring.{u_1} (Top.continuous_functions.{u_1} X R))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.bundled.α.{u_1 u_1} (λ (α : Type u_1), ring.{u_1} α) (@category_theory.bundled.map.{u_1 u_1} (λ (α : Type u_1), comm_ring.{u_1} α) (λ (α : Type u_1), ring.{u_1} α) comm_ring.to_ring.{u_1} (Top.continuous_functions.{u_1} X R))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (u_1+1)} [c : category_theory.category_struct.{u_1 u_1+1} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{u_1 u_1+1} obj (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} obj c) X Y → @category_theory.has_hom.hom.{u_1 u_1+1} obj (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} obj c) Y Z → @category_theory.has_hom.hom.{u_1 u_1+1} obj (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (C D : Type (u+1)) [_inst_1 : category_theory.concrete_category.{u} C] [_inst_2 : category_theory.concrete_category.{u} D] [_inst_3 : @category_theory.has_forget₂.{u} C D _inst_1 _inst_2], @category_theory.functor.{u u u+1 u+1} C (@category_theory.concrete_category.to_category.{u} C _inst_1) D (@category_theory.concrete_category.to_category.{u} D _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (u_1+1)} [_inst_1 : category_theory.category.{u_1 u_1+1} C] {D : Type (u_1+1)} [_inst_2 : category_theory.category.{u_1 u_1+1} D] (c : @category_theory.functor.{u_1 u_1 u_1+1 u_1+1} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{u_1 u_1+1} C (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} C (@category_theory.category.to_category_struct.{u_1 u_1+1} C _inst_1)) X Y → @category_theory.has_hom.hom.{u_1 u_1+1} D (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} D (@category_theory.category.to_category_struct.{u_1 u_1+1} D _inst_2)) (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{u_1 u_1+1} TopCommRing.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} TopCommRing.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} TopCommRing.{u_1} (@category_theory.concrete_category.to_category.{u_1} TopCommRing.{u_1} TopCommRing.category_theory.concrete_category.{u_1}))) R S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title=' The forgetful functor `C ⥤ D` between concrete categories for which we have an instance
`has_forget₂ C `.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A bundled topological commutative ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The category of topological spaces and continuous maps.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59    map_one&#x27; := by ext; exact φ.1.map_one,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.has_hom.hom.{u_1 u_1+1} TopCommRing.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} TopCommRing.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} TopCommRing.{u_1} (@category_theory.concrete_category.to_category.{u_1} TopCommRing.{u_1} TopCommRing.category_theory.concrete_category.{u_1}))) R S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='lime'><a title='X : opposite.{?l_1+2} Top.{?l_1},
R S : TopCommRing.{?l_1},
φ :
  @category_theory.has_hom.hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
    (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
       (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} TopCommRing.{?l_1}
          (@category_theory.concrete_category.to_category.{?l_1} TopCommRing.{?l_1}
             TopCommRing.category_theory.concrete_category.{?l_1})))
    R
    S
⊢ @eq.{?l_1+1}
    (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
       (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
          (λ (α : Type ?l_1), ring.{?l_1} α)
          comm_ring.to_ring.{?l_1}
          (Top.continuous_functions.{?l_1} X S)))
    ((λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
      (f :
        @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
          (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
             (λ (X Y : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1}),
                (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                   @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
                  (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} X)
                  (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} Y)
                  (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
                  (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)))
          X
          Y)
      (g :
        @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
          (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
             (λ (X Y : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1}),
                (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                   @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
                  (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} X)
                  (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} Y)
                  (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
                  (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)))
          Y
          Z),
        @category_theory.bundled_hom.comp.{?l_1} topological_space.{?l_1}
          (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
             @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), topological_space.{?l_1} α)
             continuous.{?l_1 ?l_1}
             Top.concrete_category_continuous.{?l_1})
          (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
             X)
          (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
             Y)
          (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
             Z)
          (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
          (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)
          (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Z)
          g
          f)
       (@opposite.unop.{?l_1+2} Top.{?l_1} X)
       ((λ (X : TopCommRing.{?l_1}),
           (λ (R : TopCommRing.{?l_1}),
              @Top.of.{?l_1} (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                (TopCommRing.forget_topological_space.{?l_1} R))
             X)
          R)
       ((λ (X : TopCommRing.{?l_1}),
           (λ (R : TopCommRing.{?l_1}),
              @Top.of.{?l_1} (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                (TopCommRing.forget_topological_space.{?l_1} R))
             X)
          S)
       (@monoid.one.{?l_1}
          (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
             (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                (λ (α : Type ?l_1), ring.{?l_1} α)
                comm_ring.to_ring.{?l_1}
                (Top.continuous_functions.{?l_1} X R)))
          (@semiring.to_monoid.{?l_1}
             (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
                (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                   (λ (α : Type ?l_1), ring.{?l_1} α)
                   comm_ring.to_ring.{?l_1}
                   (Top.continuous_functions.{?l_1} X R)))
             (@ring.to_semiring.{?l_1}
                (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
                   (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                      (λ (α : Type ?l_1), ring.{?l_1} α)
                      comm_ring.to_ring.{?l_1}
                      (Top.continuous_functions.{?l_1} X R)))
                (@category_theory.bundled.str.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
                   (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                      (λ (α : Type ?l_1), ring.{?l_1} α)
                      comm_ring.to_ring.{?l_1}
                      (Top.continuous_functions.{?l_1} X R))))))
       ((λ (X Y : TopCommRing.{?l_1})
         (f :
           @category_theory.has_hom.hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
             (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                   (@category_theory.concrete_category.to_category.{?l_1} TopCommRing.{?l_1}
                      TopCommRing.category_theory.concrete_category.{?l_1})))
             X
             Y),
           (λ (R S : TopCommRing.{?l_1})
            (f :
              @category_theory.has_hom.hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                   (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                      (@category_theory.concrete_category.to_category.{?l_1} TopCommRing.{?l_1}
                         TopCommRing.category_theory.concrete_category.{?l_1})))
                R
                S),
              @subtype.mk.{?l_1+1}
                (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1}
                   (@Top.of.{?l_1} (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                      (TopCommRing.forget_topological_space.{?l_1} R)) →
                 @category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1}
                   (@Top.of.{?l_1} (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                      (TopCommRing.forget_topological_space.{?l_1} S)))
                (@continuous.{?l_1 ?l_1}
                   (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1}
                      (@Top.of.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                         (TopCommRing.forget_topological_space.{?l_1} R)))
                   (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1}
                      (@Top.of.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                         (TopCommRing.forget_topological_space.{?l_1} S)))
                   (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1}
                      (@Top.of.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                         (TopCommRing.forget_topological_space.{?l_1} R)))
                   (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1}
                      (@Top.of.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                         (TopCommRing.forget_topological_space.{?l_1} S))))
                (@coe_fn.{?l_1+1 ?l_1+1}
                   (@ring_hom.{?l_1 ?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                      (@ring.to_semiring.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                         (@comm_ring.to_ring.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                            (R.is_comm_ring)))
                      (@ring.to_semiring.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                         (@comm_ring.to_ring.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                            (S.is_comm_ring))))
                   (@ring_hom.has_coe_to_fun.{?l_1 ?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                      (@ring.to_semiring.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                         (@comm_ring.to_ring.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                            (R.is_comm_ring)))
                      (@ring.to_semiring.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                         (@comm_ring.to_ring.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                            (S.is_comm_ring))))
                   (@subtype.val.{?l_1+1}
                      (@ring_hom.{?l_1 ?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                         (@ring.to_semiring.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                            (@comm_ring.to_ring.{?l_1}
                               (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                               (R.is_comm_ring)))
                         (@ring.to_semiring.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                            (@comm_ring.to_ring.{?l_1}
                               (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                               (S.is_comm_ring))))
                      (λ
                       (f :
                         @ring_hom.{?l_1 ?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                           (@ring.to_semiring.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                              (@comm_ring.to_ring.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                 (R.is_comm_ring)))
                           (@ring.to_semiring.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                              (@comm_ring.to_ring.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                 (S.is_comm_ring)))),
                         @continuous.{?l_1 ?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                           (R.is_topological_space)
                           (S.is_topological_space)
                           (@coe_fn.{?l_1+1 ?l_1+1}
                              (@ring_hom.{?l_1 ?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                 (@ring.to_semiring.{?l_1}
                                    (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                    (@comm_ring.to_ring.{?l_1}
                                       (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                          R)
                                       (R.is_comm_ring)))
                                 (@ring.to_semiring.{?l_1}
                                    (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                    (@comm_ring.to_ring.{?l_1}
                                       (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                          S)
                                       (S.is_comm_ring))))
                              (@ring_hom.has_coe_to_fun.{?l_1 ?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                 (@ring.to_semiring.{?l_1}
                                    (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                    (@comm_ring.to_ring.{?l_1}
                                       (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                          R)
                                       (R.is_comm_ring)))
                                 (@ring.to_semiring.{?l_1}
                                    (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                    (@comm_ring.to_ring.{?l_1}
                                       (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                          S)
                                       (S.is_comm_ring))))
                              f))
                      f))
                (TopCommRing.has_forget_to_Top._proof_2.{?l_1} R S f))
             X
             Y
             f)
          R
          S
          φ))
    (@monoid.one.{?l_1}
       (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
          (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
             (λ (α : Type ?l_1), ring.{?l_1} α)
             comm_ring.to_ring.{?l_1}
             (Top.continuous_functions.{?l_1} X S)))
       (@semiring.to_monoid.{?l_1}
          (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
             (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                (λ (α : Type ?l_1), ring.{?l_1} α)
                comm_ring.to_ring.{?l_1}
                (Top.continuous_functions.{?l_1} X S)))
          (@ring.to_semiring.{?l_1}
             (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
                (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                   (λ (α : Type ?l_1), ring.{?l_1} α)
                   comm_ring.to_ring.{?l_1}
                   (Top.continuous_functions.{?l_1} X S)))
             (@category_theory.bundled.str.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
                (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                   (λ (α : Type ?l_1), ring.{?l_1} α)
                   comm_ring.to_ring.{?l_1}
                   (Top.continuous_functions.{?l_1} X S))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60    map_zero&#x27; := by ext; exact φ.1.map_zero,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.has_hom.hom.{u_1 u_1+1} TopCommRing.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} TopCommRing.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} TopCommRing.{u_1} (@category_theory.concrete_category.to_category.{u_1} TopCommRing.{u_1} TopCommRing.category_theory.concrete_category.{u_1}))) R S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='lime'><a title='X : opposite.{?l_1+2} Top.{?l_1},
R S : TopCommRing.{?l_1},
φ :
  @category_theory.has_hom.hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
    (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
       (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} TopCommRing.{?l_1}
          (@category_theory.concrete_category.to_category.{?l_1} TopCommRing.{?l_1}
             TopCommRing.category_theory.concrete_category.{?l_1})))
    R
    S
⊢ @eq.{?l_1+1}
    (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
       (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
          (λ (α : Type ?l_1), ring.{?l_1} α)
          comm_ring.to_ring.{?l_1}
          (Top.continuous_functions.{?l_1} X S)))
    ((λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
      (f :
        @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
          (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
             (λ (X Y : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1}),
                (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                   @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
                  (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} X)
                  (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} Y)
                  (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
                  (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)))
          X
          Y)
      (g :
        @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
          (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
             (λ (X Y : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1}),
                (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                   @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
                  (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} X)
                  (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} Y)
                  (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
                  (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)))
          Y
          Z),
        @category_theory.bundled_hom.comp.{?l_1} topological_space.{?l_1}
          (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
             @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), topological_space.{?l_1} α)
             continuous.{?l_1 ?l_1}
             Top.concrete_category_continuous.{?l_1})
          (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
             X)
          (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
             Y)
          (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
             Z)
          (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
          (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)
          (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Z)
          g
          f)
       (@opposite.unop.{?l_1+2} Top.{?l_1} X)
       ((λ (X : TopCommRing.{?l_1}),
           (λ (R : TopCommRing.{?l_1}),
              @Top.of.{?l_1} (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                (TopCommRing.forget_topological_space.{?l_1} R))
             X)
          R)
       ((λ (X : TopCommRing.{?l_1}),
           (λ (R : TopCommRing.{?l_1}),
              @Top.of.{?l_1} (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                (TopCommRing.forget_topological_space.{?l_1} R))
             X)
          S)
       (@add_monoid.zero.{?l_1}
          (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
             (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                (λ (α : Type ?l_1), ring.{?l_1} α)
                comm_ring.to_ring.{?l_1}
                (Top.continuous_functions.{?l_1} X R)))
          (@add_comm_monoid.to_add_monoid.{?l_1}
             (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
                (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                   (λ (α : Type ?l_1), ring.{?l_1} α)
                   comm_ring.to_ring.{?l_1}
                   (Top.continuous_functions.{?l_1} X R)))
             (@semiring.to_add_comm_monoid.{?l_1}
                (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
                   (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                      (λ (α : Type ?l_1), ring.{?l_1} α)
                      comm_ring.to_ring.{?l_1}
                      (Top.continuous_functions.{?l_1} X R)))
                (@ring.to_semiring.{?l_1}
                   (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
                      (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                         (λ (α : Type ?l_1), ring.{?l_1} α)
                         comm_ring.to_ring.{?l_1}
                         (Top.continuous_functions.{?l_1} X R)))
                   (@category_theory.bundled.str.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
                      (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                         (λ (α : Type ?l_1), ring.{?l_1} α)
                         comm_ring.to_ring.{?l_1}
                         (Top.continuous_functions.{?l_1} X R)))))))
       ((λ (X Y : TopCommRing.{?l_1})
         (f :
           @category_theory.has_hom.hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
             (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                   (@category_theory.concrete_category.to_category.{?l_1} TopCommRing.{?l_1}
                      TopCommRing.category_theory.concrete_category.{?l_1})))
             X
             Y),
           (λ (R S : TopCommRing.{?l_1})
            (f :
              @category_theory.has_hom.hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                   (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                      (@category_theory.concrete_category.to_category.{?l_1} TopCommRing.{?l_1}
                         TopCommRing.category_theory.concrete_category.{?l_1})))
                R
                S),
              @subtype.mk.{?l_1+1}
                (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1}
                   (@Top.of.{?l_1} (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                      (TopCommRing.forget_topological_space.{?l_1} R)) →
                 @category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1}
                   (@Top.of.{?l_1} (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                      (TopCommRing.forget_topological_space.{?l_1} S)))
                (@continuous.{?l_1 ?l_1}
                   (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1}
                      (@Top.of.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                         (TopCommRing.forget_topological_space.{?l_1} R)))
                   (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1}
                      (@Top.of.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                         (TopCommRing.forget_topological_space.{?l_1} S)))
                   (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1}
                      (@Top.of.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                         (TopCommRing.forget_topological_space.{?l_1} R)))
                   (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1}
                      (@Top.of.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                         (TopCommRing.forget_topological_space.{?l_1} S))))
                (@coe_fn.{?l_1+1 ?l_1+1}
                   (@ring_hom.{?l_1 ?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                      (@ring.to_semiring.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                         (@comm_ring.to_ring.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                            (R.is_comm_ring)))
                      (@ring.to_semiring.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                         (@comm_ring.to_ring.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                            (S.is_comm_ring))))
                   (@ring_hom.has_coe_to_fun.{?l_1 ?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                      (@ring.to_semiring.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                         (@comm_ring.to_ring.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                            (R.is_comm_ring)))
                      (@ring.to_semiring.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                         (@comm_ring.to_ring.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                            (S.is_comm_ring))))
                   (@subtype.val.{?l_1+1}
                      (@ring_hom.{?l_1 ?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                         (@ring.to_semiring.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                            (@comm_ring.to_ring.{?l_1}
                               (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                               (R.is_comm_ring)))
                         (@ring.to_semiring.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                            (@comm_ring.to_ring.{?l_1}
                               (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                               (S.is_comm_ring))))
                      (λ
                       (f :
                         @ring_hom.{?l_1 ?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                           (@ring.to_semiring.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                              (@comm_ring.to_ring.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                 (R.is_comm_ring)))
                           (@ring.to_semiring.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                              (@comm_ring.to_ring.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                 (S.is_comm_ring)))),
                         @continuous.{?l_1 ?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                           (R.is_topological_space)
                           (S.is_topological_space)
                           (@coe_fn.{?l_1+1 ?l_1+1}
                              (@ring_hom.{?l_1 ?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                 (@ring.to_semiring.{?l_1}
                                    (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                    (@comm_ring.to_ring.{?l_1}
                                       (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                          R)
                                       (R.is_comm_ring)))
                                 (@ring.to_semiring.{?l_1}
                                    (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                    (@comm_ring.to_ring.{?l_1}
                                       (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                          S)
                                       (S.is_comm_ring))))
                              (@ring_hom.has_coe_to_fun.{?l_1 ?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                 (@ring.to_semiring.{?l_1}
                                    (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                    (@comm_ring.to_ring.{?l_1}
                                       (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                          R)
                                       (R.is_comm_ring)))
                                 (@ring.to_semiring.{?l_1}
                                    (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                    (@comm_ring.to_ring.{?l_1}
                                       (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                          S)
                                       (S.is_comm_ring))))
                              f))
                      f))
                (TopCommRing.has_forget_to_Top._proof_2.{?l_1} R S f))
             X
             Y
             f)
          R
          S
          φ))
    (@add_monoid.zero.{?l_1}
       (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
          (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
             (λ (α : Type ?l_1), ring.{?l_1} α)
             comm_ring.to_ring.{?l_1}
             (Top.continuous_functions.{?l_1} X S)))
       (@add_comm_monoid.to_add_monoid.{?l_1}
          (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
             (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                (λ (α : Type ?l_1), ring.{?l_1} α)
                comm_ring.to_ring.{?l_1}
                (Top.continuous_functions.{?l_1} X S)))
          (@semiring.to_add_comm_monoid.{?l_1}
             (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
                (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                   (λ (α : Type ?l_1), ring.{?l_1} α)
                   comm_ring.to_ring.{?l_1}
                   (Top.continuous_functions.{?l_1} X S)))
             (@ring.to_semiring.{?l_1}
                (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
                   (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                      (λ (α : Type ?l_1), ring.{?l_1} α)
                      comm_ring.to_ring.{?l_1}
                      (Top.continuous_functions.{?l_1} X S)))
                (@category_theory.bundled.str.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
                   (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                      (λ (α : Type ?l_1), ring.{?l_1} α)
                      comm_ring.to_ring.{?l_1}
                      (Top.continuous_functions.{?l_1} X S)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61    map_add&#x27; := by intros; ext; apply φ.1.map_add,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.has_hom.hom.{u_1 u_1+1} TopCommRing.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} TopCommRing.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} TopCommRing.{u_1} (@category_theory.concrete_category.to_category.{u_1} TopCommRing.{u_1} TopCommRing.category_theory.concrete_category.{u_1}))) R S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='lime'><a title='X : opposite.{?l_1+2} Top.{?l_1},
R S : TopCommRing.{?l_1},
φ :
  @category_theory.has_hom.hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
    (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
       (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} TopCommRing.{?l_1}
          (@category_theory.concrete_category.to_category.{?l_1} TopCommRing.{?l_1}
             TopCommRing.category_theory.concrete_category.{?l_1})))
    R
    S
⊢ ∀
  (x y :
    @category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
      (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
         (λ (α : Type ?l_1), ring.{?l_1} α)
         comm_ring.to_ring.{?l_1}
         (Top.continuous_functions.{?l_1} X R))),
    @eq.{?l_1+1}
      (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
         (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
            (λ (α : Type ?l_1), ring.{?l_1} α)
            comm_ring.to_ring.{?l_1}
            (Top.continuous_functions.{?l_1} X S)))
      ((λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
        (f :
          @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
            (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (λ (X Y : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1}),
                  (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                     @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
                    (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} X)
                    (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} Y)
                    (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
                    (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)))
            X
            Y)
        (g :
          @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
            (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (λ (X Y : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1}),
                  (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                     @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
                    (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} X)
                    (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} Y)
                    (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
                    (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)))
            Y
            Z),
          @category_theory.bundled_hom.comp.{?l_1} topological_space.{?l_1}
            (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
               @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
            (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), topological_space.{?l_1} α)
               continuous.{?l_1 ?l_1}
               Top.concrete_category_continuous.{?l_1})
            (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
               X)
            (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
               Y)
            (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
               Z)
            (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
            (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)
            (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Z)
            g
            f)
         (@opposite.unop.{?l_1+2} Top.{?l_1} X)
         ((λ (X : TopCommRing.{?l_1}),
             (λ (R : TopCommRing.{?l_1}),
                @Top.of.{?l_1} (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                  (TopCommRing.forget_topological_space.{?l_1} R))
               X)
            R)
         ((λ (X : TopCommRing.{?l_1}),
             (λ (R : TopCommRing.{?l_1}),
                @Top.of.{?l_1} (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                  (TopCommRing.forget_topological_space.{?l_1} R))
               X)
            S)
         (@add_comm_monoid.add.{?l_1}
            (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
               (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                  (λ (α : Type ?l_1), ring.{?l_1} α)
                  comm_ring.to_ring.{?l_1}
                  (Top.continuous_functions.{?l_1} X R)))
            (@semiring.to_add_comm_monoid.{?l_1}
               (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
                  (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                     (λ (α : Type ?l_1), ring.{?l_1} α)
                     comm_ring.to_ring.{?l_1}
                     (Top.continuous_functions.{?l_1} X R)))
               (@ring.to_semiring.{?l_1}
                  (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
                     (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                        (λ (α : Type ?l_1), ring.{?l_1} α)
                        comm_ring.to_ring.{?l_1}
                        (Top.continuous_functions.{?l_1} X R)))
                  (@category_theory.bundled.str.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
                     (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                        (λ (α : Type ?l_1), ring.{?l_1} α)
                        comm_ring.to_ring.{?l_1}
                        (Top.continuous_functions.{?l_1} X R)))))
            x
            y)
         ((λ (X Y : TopCommRing.{?l_1})
           (f :
             @category_theory.has_hom.hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
               (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                  (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                     (@category_theory.concrete_category.to_category.{?l_1} TopCommRing.{?l_1}
                        TopCommRing.category_theory.concrete_category.{?l_1})))
               X
               Y),
             (λ (R S : TopCommRing.{?l_1})
              (f :
                @category_theory.has_hom.hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                  (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                     (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                        (@category_theory.concrete_category.to_category.{?l_1} TopCommRing.{?l_1}
                           TopCommRing.category_theory.concrete_category.{?l_1})))
                  R
                  S),
                @subtype.mk.{?l_1+1}
                  (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1}
                     (@Top.of.{?l_1} (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                        (TopCommRing.forget_topological_space.{?l_1} R)) →
                   @category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1}
                     (@Top.of.{?l_1} (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                        (TopCommRing.forget_topological_space.{?l_1} S)))
                  (@continuous.{?l_1 ?l_1}
                     (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1}
                        (@Top.of.{?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                           (TopCommRing.forget_topological_space.{?l_1} R)))
                     (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1}
                        (@Top.of.{?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                           (TopCommRing.forget_topological_space.{?l_1} S)))
                     (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1}
                        (@Top.of.{?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                           (TopCommRing.forget_topological_space.{?l_1} R)))
                     (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1}
                        (@Top.of.{?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                           (TopCommRing.forget_topological_space.{?l_1} S))))
                  (@coe_fn.{?l_1+1 ?l_1+1}
                     (@ring_hom.{?l_1 ?l_1}
                        (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                        (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                        (@ring.to_semiring.{?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                           (@comm_ring.to_ring.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                              (R.is_comm_ring)))
                        (@ring.to_semiring.{?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                           (@comm_ring.to_ring.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                              (S.is_comm_ring))))
                     (@ring_hom.has_coe_to_fun.{?l_1 ?l_1}
                        (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                        (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                        (@ring.to_semiring.{?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                           (@comm_ring.to_ring.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                              (R.is_comm_ring)))
                        (@ring.to_semiring.{?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                           (@comm_ring.to_ring.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                              (S.is_comm_ring))))
                     (@subtype.val.{?l_1+1}
                        (@ring_hom.{?l_1 ?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                           (@ring.to_semiring.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                              (@comm_ring.to_ring.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                 (R.is_comm_ring)))
                           (@ring.to_semiring.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                              (@comm_ring.to_ring.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                 (S.is_comm_ring))))
                        (λ
                         (f :
                           @ring_hom.{?l_1 ?l_1}
                             (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                             (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                             (@ring.to_semiring.{?l_1}
                                (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                (@comm_ring.to_ring.{?l_1}
                                   (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                   (R.is_comm_ring)))
                             (@ring.to_semiring.{?l_1}
                                (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                (@comm_ring.to_ring.{?l_1}
                                   (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                   (S.is_comm_ring)))),
                           @continuous.{?l_1 ?l_1}
                             (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                             (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                             (R.is_topological_space)
                             (S.is_topological_space)
                             (@coe_fn.{?l_1+1 ?l_1+1}
                                (@ring_hom.{?l_1 ?l_1}
                                   (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                   (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                   (@ring.to_semiring.{?l_1}
                                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                         R)
                                      (@comm_ring.to_ring.{?l_1}
                                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                            TopCommRing.has_coe_to_sort.{?l_1}
                                            R)
                                         (R.is_comm_ring)))
                                   (@ring.to_semiring.{?l_1}
                                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                         S)
                                      (@comm_ring.to_ring.{?l_1}
                                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                            TopCommRing.has_coe_to_sort.{?l_1}
                                            S)
                                         (S.is_comm_ring))))
                                (@ring_hom.has_coe_to_fun.{?l_1 ?l_1}
                                   (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                   (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                   (@ring.to_semiring.{?l_1}
                                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                         R)
                                      (@comm_ring.to_ring.{?l_1}
                                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                            TopCommRing.has_coe_to_sort.{?l_1}
                                            R)
                                         (R.is_comm_ring)))
                                   (@ring.to_semiring.{?l_1}
                                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                         S)
                                      (@comm_ring.to_ring.{?l_1}
                                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                            TopCommRing.has_coe_to_sort.{?l_1}
                                            S)
                                         (S.is_comm_ring))))
                                f))
                        f))
                  (TopCommRing.has_forget_to_Top._proof_2.{?l_1} R S f))
               X
               Y
               f)
            R
            S
            φ))
      (@add_comm_monoid.add.{?l_1}
         (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
            (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
               (λ (α : Type ?l_1), ring.{?l_1} α)
               comm_ring.to_ring.{?l_1}
               (Top.continuous_functions.{?l_1} X S)))
         (@semiring.to_add_comm_monoid.{?l_1}
            (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
               (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                  (λ (α : Type ?l_1), ring.{?l_1} α)
                  comm_ring.to_ring.{?l_1}
                  (Top.continuous_functions.{?l_1} X S)))
            (@ring.to_semiring.{?l_1}
               (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
                  (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                     (λ (α : Type ?l_1), ring.{?l_1} α)
                     comm_ring.to_ring.{?l_1}
                     (Top.continuous_functions.{?l_1} X S)))
               (@category_theory.bundled.str.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
                  (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                     (λ (α : Type ?l_1), ring.{?l_1} α)
                     comm_ring.to_ring.{?l_1}
                     (Top.continuous_functions.{?l_1} X S)))))
         ((λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
           (f :
             @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1}),
                     (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                        @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} Y)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)))
               X
               Y)
           (g :
             @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1}),
                     (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                        @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} Y)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)))
               Y
               Z),
             @category_theory.bundled_hom.comp.{?l_1} topological_space.{?l_1}
               (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                  @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
               (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), topological_space.{?l_1} α)
                  continuous.{?l_1 ?l_1}
                  Top.concrete_category_continuous.{?l_1})
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
                  X)
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
                  Y)
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
                  Z)
               (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
               (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)
               (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Z)
               g
               f)
            (@opposite.unop.{?l_1+2} Top.{?l_1} X)
            ((λ (X : TopCommRing.{?l_1}),
                (λ (R : TopCommRing.{?l_1}),
                   @Top.of.{?l_1} (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                     (TopCommRing.forget_topological_space.{?l_1} R))
                  X)
               R)
            ((λ (X : TopCommRing.{?l_1}),
                (λ (R : TopCommRing.{?l_1}),
                   @Top.of.{?l_1} (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                     (TopCommRing.forget_topological_space.{?l_1} R))
                  X)
               S)
            x
            ((λ (X Y : TopCommRing.{?l_1})
              (f :
                @category_theory.has_hom.hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                  (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                     (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                        (@category_theory.concrete_category.to_category.{?l_1} TopCommRing.{?l_1}
                           TopCommRing.category_theory.concrete_category.{?l_1})))
                  X
                  Y),
                (λ (R S : TopCommRing.{?l_1})
                 (f :
                   @category_theory.has_hom.hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                     (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                        (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                           (@category_theory.concrete_category.to_category.{?l_1} TopCommRing.{?l_1}
                              TopCommRing.category_theory.concrete_category.{?l_1})))
                     R
                     S),
                   @subtype.mk.{?l_1+1}
                     (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1}
                        (@Top.of.{?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                           (TopCommRing.forget_topological_space.{?l_1} R)) →
                      @category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1}
                        (@Top.of.{?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                           (TopCommRing.forget_topological_space.{?l_1} S)))
                     (@continuous.{?l_1 ?l_1}
                        (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1}
                           (@Top.of.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                              (TopCommRing.forget_topological_space.{?l_1} R)))
                        (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1}
                           (@Top.of.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                              (TopCommRing.forget_topological_space.{?l_1} S)))
                        (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1}
                           (@Top.of.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                              (TopCommRing.forget_topological_space.{?l_1} R)))
                        (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1}
                           (@Top.of.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                              (TopCommRing.forget_topological_space.{?l_1} S))))
                     (@coe_fn.{?l_1+1 ?l_1+1}
                        (@ring_hom.{?l_1 ?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                           (@ring.to_semiring.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                              (@comm_ring.to_ring.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                 (R.is_comm_ring)))
                           (@ring.to_semiring.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                              (@comm_ring.to_ring.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                 (S.is_comm_ring))))
                        (@ring_hom.has_coe_to_fun.{?l_1 ?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                           (@ring.to_semiring.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                              (@comm_ring.to_ring.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                 (R.is_comm_ring)))
                           (@ring.to_semiring.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                              (@comm_ring.to_ring.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                 (S.is_comm_ring))))
                        (@subtype.val.{?l_1+1}
                           (@ring_hom.{?l_1 ?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                              (@ring.to_semiring.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                 (@comm_ring.to_ring.{?l_1}
                                    (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                    (R.is_comm_ring)))
                              (@ring.to_semiring.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                 (@comm_ring.to_ring.{?l_1}
                                    (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                    (S.is_comm_ring))))
                           (λ
                            (f :
                              @ring_hom.{?l_1 ?l_1}
                                (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                (@ring.to_semiring.{?l_1}
                                   (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                   (@comm_ring.to_ring.{?l_1}
                                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                         R)
                                      (R.is_comm_ring)))
                                (@ring.to_semiring.{?l_1}
                                   (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                   (@comm_ring.to_ring.{?l_1}
                                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                         S)
                                      (S.is_comm_ring)))),
                              @continuous.{?l_1 ?l_1}
                                (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                (R.is_topological_space)
                                (S.is_topological_space)
                                (@coe_fn.{?l_1+1 ?l_1+1}
                                   (@ring_hom.{?l_1 ?l_1}
                                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                         R)
                                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                         S)
                                      (@ring.to_semiring.{?l_1}
                                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                            TopCommRing.has_coe_to_sort.{?l_1}
                                            R)
                                         (@comm_ring.to_ring.{?l_1}
                                            (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                               TopCommRing.has_coe_to_sort.{?l_1}
                                               R)
                                            (R.is_comm_ring)))
                                      (@ring.to_semiring.{?l_1}
                                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                            TopCommRing.has_coe_to_sort.{?l_1}
                                            S)
                                         (@comm_ring.to_ring.{?l_1}
                                            (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                               TopCommRing.has_coe_to_sort.{?l_1}
                                               S)
                                            (S.is_comm_ring))))
                                   (@ring_hom.has_coe_to_fun.{?l_1 ?l_1}
                                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                         R)
                                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                         S)
                                      (@ring.to_semiring.{?l_1}
                                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                            TopCommRing.has_coe_to_sort.{?l_1}
                                            R)
                                         (@comm_ring.to_ring.{?l_1}
                                            (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                               TopCommRing.has_coe_to_sort.{?l_1}
                                               R)
                                            (R.is_comm_ring)))
                                      (@ring.to_semiring.{?l_1}
                                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                            TopCommRing.has_coe_to_sort.{?l_1}
                                            S)
                                         (@comm_ring.to_ring.{?l_1}
                                            (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                               TopCommRing.has_coe_to_sort.{?l_1}
                                               S)
                                            (S.is_comm_ring))))
                                   f))
                           f))
                     (TopCommRing.has_forget_to_Top._proof_2.{?l_1} R S f))
                  X
                  Y
                  f)
               R
               S
               φ))
         ((λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
           (f :
             @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1}),
                     (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                        @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} Y)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)))
               X
               Y)
           (g :
             @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1}),
                     (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                        @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} Y)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)))
               Y
               Z),
             @category_theory.bundled_hom.comp.{?l_1} topological_space.{?l_1}
               (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                  @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
               (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), topological_space.{?l_1} α)
                  continuous.{?l_1 ?l_1}
                  Top.concrete_category_continuous.{?l_1})
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
                  X)
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
                  Y)
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
                  Z)
               (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
               (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)
               (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Z)
               g
               f)
            (@opposite.unop.{?l_1+2} Top.{?l_1} X)
            ((λ (X : TopCommRing.{?l_1}),
                (λ (R : TopCommRing.{?l_1}),
                   @Top.of.{?l_1} (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                     (TopCommRing.forget_topological_space.{?l_1} R))
                  X)
               R)
            ((λ (X : TopCommRing.{?l_1}),
                (λ (R : TopCommRing.{?l_1}),
                   @Top.of.{?l_1} (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                     (TopCommRing.forget_topological_space.{?l_1} R))
                  X)
               S)
            y
            ((λ (X Y : TopCommRing.{?l_1})
              (f :
                @category_theory.has_hom.hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                  (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                     (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                        (@category_theory.concrete_category.to_category.{?l_1} TopCommRing.{?l_1}
                           TopCommRing.category_theory.concrete_category.{?l_1})))
                  X
                  Y),
                (λ (R S : TopCommRing.{?l_1})
                 (f :
                   @category_theory.has_hom.hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                     (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                        (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                           (@category_theory.concrete_category.to_category.{?l_1} TopCommRing.{?l_1}
                              TopCommRing.category_theory.concrete_category.{?l_1})))
                     R
                     S),
                   @subtype.mk.{?l_1+1}
                     (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1}
                        (@Top.of.{?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                           (TopCommRing.forget_topological_space.{?l_1} R)) →
                      @category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1}
                        (@Top.of.{?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                           (TopCommRing.forget_topological_space.{?l_1} S)))
                     (@continuous.{?l_1 ?l_1}
                        (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1}
                           (@Top.of.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                              (TopCommRing.forget_topological_space.{?l_1} R)))
                        (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1}
                           (@Top.of.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                              (TopCommRing.forget_topological_space.{?l_1} S)))
                        (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1}
                           (@Top.of.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                              (TopCommRing.forget_topological_space.{?l_1} R)))
                        (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1}
                           (@Top.of.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                              (TopCommRing.forget_topological_space.{?l_1} S))))
                     (@coe_fn.{?l_1+1 ?l_1+1}
                        (@ring_hom.{?l_1 ?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                           (@ring.to_semiring.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                              (@comm_ring.to_ring.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                 (R.is_comm_ring)))
                           (@ring.to_semiring.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                              (@comm_ring.to_ring.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                 (S.is_comm_ring))))
                        (@ring_hom.has_coe_to_fun.{?l_1 ?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                           (@ring.to_semiring.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                              (@comm_ring.to_ring.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                 (R.is_comm_ring)))
                           (@ring.to_semiring.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                              (@comm_ring.to_ring.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                 (S.is_comm_ring))))
                        (@subtype.val.{?l_1+1}
                           (@ring_hom.{?l_1 ?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                              (@ring.to_semiring.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                 (@comm_ring.to_ring.{?l_1}
                                    (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                    (R.is_comm_ring)))
                              (@ring.to_semiring.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                 (@comm_ring.to_ring.{?l_1}
                                    (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                    (S.is_comm_ring))))
                           (λ
                            (f :
                              @ring_hom.{?l_1 ?l_1}
                                (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                (@ring.to_semiring.{?l_1}
                                   (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                   (@comm_ring.to_ring.{?l_1}
                                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                         R)
                                      (R.is_comm_ring)))
                                (@ring.to_semiring.{?l_1}
                                   (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                   (@comm_ring.to_ring.{?l_1}
                                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                         S)
                                      (S.is_comm_ring)))),
                              @continuous.{?l_1 ?l_1}
                                (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                (R.is_topological_space)
                                (S.is_topological_space)
                                (@coe_fn.{?l_1+1 ?l_1+1}
                                   (@ring_hom.{?l_1 ?l_1}
                                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                         R)
                                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                         S)
                                      (@ring.to_semiring.{?l_1}
                                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                            TopCommRing.has_coe_to_sort.{?l_1}
                                            R)
                                         (@comm_ring.to_ring.{?l_1}
                                            (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                               TopCommRing.has_coe_to_sort.{?l_1}
                                               R)
                                            (R.is_comm_ring)))
                                      (@ring.to_semiring.{?l_1}
                                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                            TopCommRing.has_coe_to_sort.{?l_1}
                                            S)
                                         (@comm_ring.to_ring.{?l_1}
                                            (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                               TopCommRing.has_coe_to_sort.{?l_1}
                                               S)
                                            (S.is_comm_ring))))
                                   (@ring_hom.has_coe_to_fun.{?l_1 ?l_1}
                                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                         R)
                                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                         S)
                                      (@ring.to_semiring.{?l_1}
                                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                            TopCommRing.has_coe_to_sort.{?l_1}
                                            R)
                                         (@comm_ring.to_ring.{?l_1}
                                            (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                               TopCommRing.has_coe_to_sort.{?l_1}
                                               R)
                                            (R.is_comm_ring)))
                                      (@ring.to_semiring.{?l_1}
                                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                            TopCommRing.has_coe_to_sort.{?l_1}
                                            S)
                                         (@comm_ring.to_ring.{?l_1}
                                            (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                               TopCommRing.has_coe_to_sort.{?l_1}
                                               S)
                                            (S.is_comm_ring))))
                                   f))
                           f))
                     (TopCommRing.has_forget_to_Top._proof_2.{?l_1} R S f))
                  X
                  Y
                  f)
               R
               S
               φ)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62    map_mul&#x27; := by intros; ext; apply φ.1.map_mul }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.has_hom.hom.{u_1 u_1+1} TopCommRing.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} TopCommRing.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} TopCommRing.{u_1} (@category_theory.concrete_category.to_category.{u_1} TopCommRing.{u_1} TopCommRing.category_theory.concrete_category.{u_1}))) R S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='lime'><a title='X : opposite.{?l_1+2} Top.{?l_1},
R S : TopCommRing.{?l_1},
φ :
  @category_theory.has_hom.hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
    (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
       (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} TopCommRing.{?l_1}
          (@category_theory.concrete_category.to_category.{?l_1} TopCommRing.{?l_1}
             TopCommRing.category_theory.concrete_category.{?l_1})))
    R
    S
⊢ ∀
  (x y :
    @category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
      (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
         (λ (α : Type ?l_1), ring.{?l_1} α)
         comm_ring.to_ring.{?l_1}
         (Top.continuous_functions.{?l_1} X R))),
    @eq.{?l_1+1}
      (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
         (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
            (λ (α : Type ?l_1), ring.{?l_1} α)
            comm_ring.to_ring.{?l_1}
            (Top.continuous_functions.{?l_1} X S)))
      ((λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
        (f :
          @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
            (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (λ (X Y : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1}),
                  (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                     @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
                    (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} X)
                    (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} Y)
                    (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
                    (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)))
            X
            Y)
        (g :
          @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
            (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (λ (X Y : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1}),
                  (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                     @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
                    (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} X)
                    (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} Y)
                    (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
                    (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)))
            Y
            Z),
          @category_theory.bundled_hom.comp.{?l_1} topological_space.{?l_1}
            (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
               @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
            (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), topological_space.{?l_1} α)
               continuous.{?l_1 ?l_1}
               Top.concrete_category_continuous.{?l_1})
            (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
               X)
            (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
               Y)
            (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
               Z)
            (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
            (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)
            (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Z)
            g
            f)
         (@opposite.unop.{?l_1+2} Top.{?l_1} X)
         ((λ (X : TopCommRing.{?l_1}),
             (λ (R : TopCommRing.{?l_1}),
                @Top.of.{?l_1} (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                  (TopCommRing.forget_topological_space.{?l_1} R))
               X)
            R)
         ((λ (X : TopCommRing.{?l_1}),
             (λ (R : TopCommRing.{?l_1}),
                @Top.of.{?l_1} (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                  (TopCommRing.forget_topological_space.{?l_1} R))
               X)
            S)
         (@semiring.mul.{?l_1}
            (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
               (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                  (λ (α : Type ?l_1), ring.{?l_1} α)
                  comm_ring.to_ring.{?l_1}
                  (Top.continuous_functions.{?l_1} X R)))
            (@ring.to_semiring.{?l_1}
               (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
                  (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                     (λ (α : Type ?l_1), ring.{?l_1} α)
                     comm_ring.to_ring.{?l_1}
                     (Top.continuous_functions.{?l_1} X R)))
               (@category_theory.bundled.str.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
                  (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                     (λ (α : Type ?l_1), ring.{?l_1} α)
                     comm_ring.to_ring.{?l_1}
                     (Top.continuous_functions.{?l_1} X R))))
            x
            y)
         ((λ (X Y : TopCommRing.{?l_1})
           (f :
             @category_theory.has_hom.hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
               (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                  (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                     (@category_theory.concrete_category.to_category.{?l_1} TopCommRing.{?l_1}
                        TopCommRing.category_theory.concrete_category.{?l_1})))
               X
               Y),
             (λ (R S : TopCommRing.{?l_1})
              (f :
                @category_theory.has_hom.hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                  (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                     (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                        (@category_theory.concrete_category.to_category.{?l_1} TopCommRing.{?l_1}
                           TopCommRing.category_theory.concrete_category.{?l_1})))
                  R
                  S),
                @subtype.mk.{?l_1+1}
                  (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1}
                     (@Top.of.{?l_1} (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                        (TopCommRing.forget_topological_space.{?l_1} R)) →
                   @category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1}
                     (@Top.of.{?l_1} (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                        (TopCommRing.forget_topological_space.{?l_1} S)))
                  (@continuous.{?l_1 ?l_1}
                     (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1}
                        (@Top.of.{?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                           (TopCommRing.forget_topological_space.{?l_1} R)))
                     (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1}
                        (@Top.of.{?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                           (TopCommRing.forget_topological_space.{?l_1} S)))
                     (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1}
                        (@Top.of.{?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                           (TopCommRing.forget_topological_space.{?l_1} R)))
                     (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1}
                        (@Top.of.{?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                           (TopCommRing.forget_topological_space.{?l_1} S))))
                  (@coe_fn.{?l_1+1 ?l_1+1}
                     (@ring_hom.{?l_1 ?l_1}
                        (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                        (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                        (@ring.to_semiring.{?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                           (@comm_ring.to_ring.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                              (R.is_comm_ring)))
                        (@ring.to_semiring.{?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                           (@comm_ring.to_ring.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                              (S.is_comm_ring))))
                     (@ring_hom.has_coe_to_fun.{?l_1 ?l_1}
                        (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                        (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                        (@ring.to_semiring.{?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                           (@comm_ring.to_ring.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                              (R.is_comm_ring)))
                        (@ring.to_semiring.{?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                           (@comm_ring.to_ring.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                              (S.is_comm_ring))))
                     (@subtype.val.{?l_1+1}
                        (@ring_hom.{?l_1 ?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                           (@ring.to_semiring.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                              (@comm_ring.to_ring.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                 (R.is_comm_ring)))
                           (@ring.to_semiring.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                              (@comm_ring.to_ring.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                 (S.is_comm_ring))))
                        (λ
                         (f :
                           @ring_hom.{?l_1 ?l_1}
                             (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                             (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                             (@ring.to_semiring.{?l_1}
                                (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                (@comm_ring.to_ring.{?l_1}
                                   (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                   (R.is_comm_ring)))
                             (@ring.to_semiring.{?l_1}
                                (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                (@comm_ring.to_ring.{?l_1}
                                   (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                   (S.is_comm_ring)))),
                           @continuous.{?l_1 ?l_1}
                             (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                             (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                             (R.is_topological_space)
                             (S.is_topological_space)
                             (@coe_fn.{?l_1+1 ?l_1+1}
                                (@ring_hom.{?l_1 ?l_1}
                                   (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                   (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                   (@ring.to_semiring.{?l_1}
                                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                         R)
                                      (@comm_ring.to_ring.{?l_1}
                                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                            TopCommRing.has_coe_to_sort.{?l_1}
                                            R)
                                         (R.is_comm_ring)))
                                   (@ring.to_semiring.{?l_1}
                                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                         S)
                                      (@comm_ring.to_ring.{?l_1}
                                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                            TopCommRing.has_coe_to_sort.{?l_1}
                                            S)
                                         (S.is_comm_ring))))
                                (@ring_hom.has_coe_to_fun.{?l_1 ?l_1}
                                   (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                   (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                   (@ring.to_semiring.{?l_1}
                                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                         R)
                                      (@comm_ring.to_ring.{?l_1}
                                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                            TopCommRing.has_coe_to_sort.{?l_1}
                                            R)
                                         (R.is_comm_ring)))
                                   (@ring.to_semiring.{?l_1}
                                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                         S)
                                      (@comm_ring.to_ring.{?l_1}
                                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                            TopCommRing.has_coe_to_sort.{?l_1}
                                            S)
                                         (S.is_comm_ring))))
                                f))
                        f))
                  (TopCommRing.has_forget_to_Top._proof_2.{?l_1} R S f))
               X
               Y
               f)
            R
            S
            φ))
      (@semiring.mul.{?l_1}
         (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
            (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
               (λ (α : Type ?l_1), ring.{?l_1} α)
               comm_ring.to_ring.{?l_1}
               (Top.continuous_functions.{?l_1} X S)))
         (@ring.to_semiring.{?l_1}
            (@category_theory.bundled.α.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
               (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                  (λ (α : Type ?l_1), ring.{?l_1} α)
                  comm_ring.to_ring.{?l_1}
                  (Top.continuous_functions.{?l_1} X S)))
            (@category_theory.bundled.str.{?l_1 ?l_1} (λ (α : Type ?l_1), ring.{?l_1} α)
               (@category_theory.bundled.map.{?l_1 ?l_1} (λ (α : Type ?l_1), comm_ring.{?l_1} α)
                  (λ (α : Type ?l_1), ring.{?l_1} α)
                  comm_ring.to_ring.{?l_1}
                  (Top.continuous_functions.{?l_1} X S))))
         ((λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
           (f :
             @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1}),
                     (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                        @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} Y)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)))
               X
               Y)
           (g :
             @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1}),
                     (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                        @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} Y)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)))
               Y
               Z),
             @category_theory.bundled_hom.comp.{?l_1} topological_space.{?l_1}
               (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                  @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
               (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), topological_space.{?l_1} α)
                  continuous.{?l_1 ?l_1}
                  Top.concrete_category_continuous.{?l_1})
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
                  X)
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
                  Y)
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
                  Z)
               (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
               (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)
               (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Z)
               g
               f)
            (@opposite.unop.{?l_1+2} Top.{?l_1} X)
            ((λ (X : TopCommRing.{?l_1}),
                (λ (R : TopCommRing.{?l_1}),
                   @Top.of.{?l_1} (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                     (TopCommRing.forget_topological_space.{?l_1} R))
                  X)
               R)
            ((λ (X : TopCommRing.{?l_1}),
                (λ (R : TopCommRing.{?l_1}),
                   @Top.of.{?l_1} (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                     (TopCommRing.forget_topological_space.{?l_1} R))
                  X)
               S)
            x
            ((λ (X Y : TopCommRing.{?l_1})
              (f :
                @category_theory.has_hom.hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                  (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                     (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                        (@category_theory.concrete_category.to_category.{?l_1} TopCommRing.{?l_1}
                           TopCommRing.category_theory.concrete_category.{?l_1})))
                  X
                  Y),
                (λ (R S : TopCommRing.{?l_1})
                 (f :
                   @category_theory.has_hom.hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                     (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                        (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                           (@category_theory.concrete_category.to_category.{?l_1} TopCommRing.{?l_1}
                              TopCommRing.category_theory.concrete_category.{?l_1})))
                     R
                     S),
                   @subtype.mk.{?l_1+1}
                     (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1}
                        (@Top.of.{?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                           (TopCommRing.forget_topological_space.{?l_1} R)) →
                      @category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1}
                        (@Top.of.{?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                           (TopCommRing.forget_topological_space.{?l_1} S)))
                     (@continuous.{?l_1 ?l_1}
                        (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1}
                           (@Top.of.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                              (TopCommRing.forget_topological_space.{?l_1} R)))
                        (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1}
                           (@Top.of.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                              (TopCommRing.forget_topological_space.{?l_1} S)))
                        (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1}
                           (@Top.of.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                              (TopCommRing.forget_topological_space.{?l_1} R)))
                        (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1}
                           (@Top.of.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                              (TopCommRing.forget_topological_space.{?l_1} S))))
                     (@coe_fn.{?l_1+1 ?l_1+1}
                        (@ring_hom.{?l_1 ?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                           (@ring.to_semiring.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                              (@comm_ring.to_ring.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                 (R.is_comm_ring)))
                           (@ring.to_semiring.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                              (@comm_ring.to_ring.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                 (S.is_comm_ring))))
                        (@ring_hom.has_coe_to_fun.{?l_1 ?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                           (@ring.to_semiring.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                              (@comm_ring.to_ring.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                 (R.is_comm_ring)))
                           (@ring.to_semiring.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                              (@comm_ring.to_ring.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                 (S.is_comm_ring))))
                        (@subtype.val.{?l_1+1}
                           (@ring_hom.{?l_1 ?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                              (@ring.to_semiring.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                 (@comm_ring.to_ring.{?l_1}
                                    (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                    (R.is_comm_ring)))
                              (@ring.to_semiring.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                 (@comm_ring.to_ring.{?l_1}
                                    (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                    (S.is_comm_ring))))
                           (λ
                            (f :
                              @ring_hom.{?l_1 ?l_1}
                                (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                (@ring.to_semiring.{?l_1}
                                   (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                   (@comm_ring.to_ring.{?l_1}
                                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                         R)
                                      (R.is_comm_ring)))
                                (@ring.to_semiring.{?l_1}
                                   (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                   (@comm_ring.to_ring.{?l_1}
                                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                         S)
                                      (S.is_comm_ring)))),
                              @continuous.{?l_1 ?l_1}
                                (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                (R.is_topological_space)
                                (S.is_topological_space)
                                (@coe_fn.{?l_1+1 ?l_1+1}
                                   (@ring_hom.{?l_1 ?l_1}
                                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                         R)
                                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                         S)
                                      (@ring.to_semiring.{?l_1}
                                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                            TopCommRing.has_coe_to_sort.{?l_1}
                                            R)
                                         (@comm_ring.to_ring.{?l_1}
                                            (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                               TopCommRing.has_coe_to_sort.{?l_1}
                                               R)
                                            (R.is_comm_ring)))
                                      (@ring.to_semiring.{?l_1}
                                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                            TopCommRing.has_coe_to_sort.{?l_1}
                                            S)
                                         (@comm_ring.to_ring.{?l_1}
                                            (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                               TopCommRing.has_coe_to_sort.{?l_1}
                                               S)
                                            (S.is_comm_ring))))
                                   (@ring_hom.has_coe_to_fun.{?l_1 ?l_1}
                                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                         R)
                                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                         S)
                                      (@ring.to_semiring.{?l_1}
                                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                            TopCommRing.has_coe_to_sort.{?l_1}
                                            R)
                                         (@comm_ring.to_ring.{?l_1}
                                            (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                               TopCommRing.has_coe_to_sort.{?l_1}
                                               R)
                                            (R.is_comm_ring)))
                                      (@ring.to_semiring.{?l_1}
                                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                            TopCommRing.has_coe_to_sort.{?l_1}
                                            S)
                                         (@comm_ring.to_ring.{?l_1}
                                            (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                               TopCommRing.has_coe_to_sort.{?l_1}
                                               S)
                                            (S.is_comm_ring))))
                                   f))
                           f))
                     (TopCommRing.has_forget_to_Top._proof_2.{?l_1} R S f))
                  X
                  Y
                  f)
               R
               S
               φ))
         ((λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
           (f :
             @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1}),
                     (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                        @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} Y)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)))
               X
               Y)
           (g :
             @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
               (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1}),
                     (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                        @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1} Y)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
                       (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)))
               Y
               Z),
             @category_theory.bundled_hom.comp.{?l_1} topological_space.{?l_1}
               (λ (α β : Type ?l_1) (Iα : topological_space.{?l_1} α) (Iβ : topological_space.{?l_1} β),
                  @subtype.{?l_1+1} (α → β) (@continuous.{?l_1 ?l_1} α β Iα Iβ))
               (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), topological_space.{?l_1} α)
                  continuous.{?l_1 ?l_1}
                  Top.concrete_category_continuous.{?l_1})
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
                  X)
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
                  Y)
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} topological_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} topological_space.{?l_1})
                  Z)
               (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} X)
               (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Y)
               (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1} Z)
               g
               f)
            (@opposite.unop.{?l_1+2} Top.{?l_1} X)
            ((λ (X : TopCommRing.{?l_1}),
                (λ (R : TopCommRing.{?l_1}),
                   @Top.of.{?l_1} (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                     (TopCommRing.forget_topological_space.{?l_1} R))
                  X)
               R)
            ((λ (X : TopCommRing.{?l_1}),
                (λ (R : TopCommRing.{?l_1}),
                   @Top.of.{?l_1} (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                     (TopCommRing.forget_topological_space.{?l_1} R))
                  X)
               S)
            y
            ((λ (X Y : TopCommRing.{?l_1})
              (f :
                @category_theory.has_hom.hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                  (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                     (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                        (@category_theory.concrete_category.to_category.{?l_1} TopCommRing.{?l_1}
                           TopCommRing.category_theory.concrete_category.{?l_1})))
                  X
                  Y),
                (λ (R S : TopCommRing.{?l_1})
                 (f :
                   @category_theory.has_hom.hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                     (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                        (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} TopCommRing.{?l_1}
                           (@category_theory.concrete_category.to_category.{?l_1} TopCommRing.{?l_1}
                              TopCommRing.category_theory.concrete_category.{?l_1})))
                     R
                     S),
                   @subtype.mk.{?l_1+1}
                     (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1}
                        (@Top.of.{?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                           (TopCommRing.forget_topological_space.{?l_1} R)) →
                      @category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1}
                        (@Top.of.{?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                           (TopCommRing.forget_topological_space.{?l_1} S)))
                     (@continuous.{?l_1 ?l_1}
                        (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1}
                           (@Top.of.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                              (TopCommRing.forget_topological_space.{?l_1} R)))
                        (@category_theory.bundled.α.{?l_1 ?l_1} topological_space.{?l_1}
                           (@Top.of.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                              (TopCommRing.forget_topological_space.{?l_1} S)))
                        (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1}
                           (@Top.of.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                              (TopCommRing.forget_topological_space.{?l_1} R)))
                        (@category_theory.bundled.str.{?l_1 ?l_1} topological_space.{?l_1}
                           (@Top.of.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                              (TopCommRing.forget_topological_space.{?l_1} S))))
                     (@coe_fn.{?l_1+1 ?l_1+1}
                        (@ring_hom.{?l_1 ?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                           (@ring.to_semiring.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                              (@comm_ring.to_ring.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                 (R.is_comm_ring)))
                           (@ring.to_semiring.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                              (@comm_ring.to_ring.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                 (S.is_comm_ring))))
                        (@ring_hom.has_coe_to_fun.{?l_1 ?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                           (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                           (@ring.to_semiring.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                              (@comm_ring.to_ring.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                 (R.is_comm_ring)))
                           (@ring.to_semiring.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                              (@comm_ring.to_ring.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                 (S.is_comm_ring))))
                        (@subtype.val.{?l_1+1}
                           (@ring_hom.{?l_1 ?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                              (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                              (@ring.to_semiring.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                 (@comm_ring.to_ring.{?l_1}
                                    (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                    (R.is_comm_ring)))
                              (@ring.to_semiring.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                 (@comm_ring.to_ring.{?l_1}
                                    (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                    (S.is_comm_ring))))
                           (λ
                            (f :
                              @ring_hom.{?l_1 ?l_1}
                                (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                (@ring.to_semiring.{?l_1}
                                   (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                   (@comm_ring.to_ring.{?l_1}
                                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                         R)
                                      (R.is_comm_ring)))
                                (@ring.to_semiring.{?l_1}
                                   (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                   (@comm_ring.to_ring.{?l_1}
                                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                         S)
                                      (S.is_comm_ring)))),
                              @continuous.{?l_1 ?l_1}
                                (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} R)
                                (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1} S)
                                (R.is_topological_space)
                                (S.is_topological_space)
                                (@coe_fn.{?l_1+1 ?l_1+1}
                                   (@ring_hom.{?l_1 ?l_1}
                                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                         R)
                                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                         S)
                                      (@ring.to_semiring.{?l_1}
                                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                            TopCommRing.has_coe_to_sort.{?l_1}
                                            R)
                                         (@comm_ring.to_ring.{?l_1}
                                            (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                               TopCommRing.has_coe_to_sort.{?l_1}
                                               R)
                                            (R.is_comm_ring)))
                                      (@ring.to_semiring.{?l_1}
                                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                            TopCommRing.has_coe_to_sort.{?l_1}
                                            S)
                                         (@comm_ring.to_ring.{?l_1}
                                            (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                               TopCommRing.has_coe_to_sort.{?l_1}
                                               S)
                                            (S.is_comm_ring))))
                                   (@ring_hom.has_coe_to_fun.{?l_1 ?l_1}
                                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                         R)
                                      (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1} TopCommRing.has_coe_to_sort.{?l_1}
                                         S)
                                      (@ring.to_semiring.{?l_1}
                                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                            TopCommRing.has_coe_to_sort.{?l_1}
                                            R)
                                         (@comm_ring.to_ring.{?l_1}
                                            (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                               TopCommRing.has_coe_to_sort.{?l_1}
                                               R)
                                            (R.is_comm_ring)))
                                      (@ring.to_semiring.{?l_1}
                                         (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                            TopCommRing.has_coe_to_sort.{?l_1}
                                            S)
                                         (@comm_ring.to_ring.{?l_1}
                                            (@coe_sort.{?l_1+2 ?l_1+2} TopCommRing.{?l_1}
                                               TopCommRing.has_coe_to_sort.{?l_1}
                                               S)
                                            (S.is_comm_ring))))
                                   f))
                           f))
                     (TopCommRing.has_forget_to_Top._proof_2.{?l_1} R S f))
                  X
                  Y
                  f)
               R
               S
               φ)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  end continuous_functions</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65  /-- An upgraded version of the Yoneda embedding, observing that the continuous maps</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  from `X : Top` to `R : TopCommRing` form a commutative ring, functorial in both `X` and `R`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67  def CommRing_yoneda : TopCommRing.{u} ⥤ (Top.{u}ᵒᵖ ⥤ CommRing.{u}) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='TopCommRing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='CommRing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/TopCommRing.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/Top/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/category/CommRing/basic.lean&#x27;, &#x27;line&#x27;: 119, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (C : Type (u+1)) [_inst_1 : category_theory.category.{u u+1} C] (D : Type (u+1)) [_inst_2 : category_theory.category.{u+1 u+1} D], Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type (u+1) → Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type (u+1)) [_inst_1 : category_theory.category.{u u+1} C] (D : Type (u+1)) [_inst_2 : category_theory.category.{u u+1} D], Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='A bundled topological commutative ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The category of topological spaces and continuous maps.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The category of commutative rings.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68  { obj := λ R,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='TopCommRing.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69    { obj := λ X, continuous_functions X R,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Top.continuous_functions'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 29, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='opposite.{u+2} Top.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='opposite.{v+2} Top.{v} → TopCommRing.{v} → CommRing.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{u+2} Top.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='TopCommRing.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title=' The (bundled) commutative ring of continuous functions from a topological space
to a topological commutative ring, with pointwise multiplication.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70      map := λ X Y f, continuous_functions.pullback f R },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Top.continuous_functions.pullback'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='opposite.{u+2} Top.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{u+2} Top.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{u u+1} (opposite.{u+2} Top.{u}) (@category_theory.category_struct.to_has_hom.{u u+1} (opposite.{u+2} Top.{u}) (@category_theory.category.to_category_struct.{u u+1} (opposite.{u+2} Top.{u}) (@category_theory.category.opposite.{u u+1} Top.{u} (@category_theory.bundled_hom.category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u}))))) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {X Y : opposite.{u_1+2} Top.{u_1}}, @category_theory.has_hom.hom.{u_1 u_1+1} (opposite.{u_1+2} Top.{u_1}) (@category_theory.has_hom.opposite.{u_1 u_1+1} Top.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} Top.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} Top.{u_1} (@category_theory.bundled_hom.category.{u_1} topological_space.{u_1} (λ (α β : Type u_1) (Iα : topological_space.{u_1} α) (Iβ : topological_space.{u_1} β), @subtype.{u_1+1} (α → β) (@continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), topological_space.{u_1} α) continuous.{u_1 u_1} Top.concrete_category_continuous.{u_1}))))) X Y → Π (R : TopCommRing.{u_1}), @category_theory.has_hom.hom.{u_1 u_1+1} CommRing.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} CommRing.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} CommRing.{u_1} (@category_theory.concrete_category.to_category.{u_1} CommRing.{u_1} CommRing.category_theory.concrete_category.{u_1}))) (Top.continuous_functions.{u_1} X R) (Top.continuous_functions.{u_1} Y R)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{u u+1} (opposite.{u+2} Top.{u}) (@category_theory.category_struct.to_has_hom.{u u+1} (opposite.{u+2} Top.{u}) (@category_theory.category.to_category_struct.{u u+1} (opposite.{u+2} Top.{u}) (@category_theory.category.opposite.{u u+1} Top.{u} (@category_theory.bundled_hom.category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u}))))) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='TopCommRing.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='Pulling back functions into a topological ring along a continuous map is a ring homomorphism.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71    map := λ R S φ,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='TopCommRing.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='TopCommRing.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{u u+1} TopCommRing.{u} (@category_theory.category_struct.to_has_hom.{u u+1} TopCommRing.{u} (@category_theory.category.to_category_struct.{u u+1} TopCommRing.{u} (@category_theory.concrete_category.to_category.{u} TopCommRing.{u} TopCommRing.category_theory.concrete_category.{u}))) R S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72    { app := λ X, continuous_functions.map X φ } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Top.continuous_functions.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 56, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='opposite.{u+2} Top.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (X : opposite.{u_1+2} Top.{u_1}) {R S : TopCommRing.{u_1}}, @category_theory.has_hom.hom.{u_1 u_1+1} TopCommRing.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} TopCommRing.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} TopCommRing.{u_1} (@category_theory.concrete_category.to_category.{u_1} TopCommRing.{u_1} TopCommRing.category_theory.concrete_category.{u_1}))) R S → @category_theory.has_hom.hom.{u_1 u_1+1} CommRing.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} CommRing.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} CommRing.{u_1} (@category_theory.concrete_category.to_category.{u_1} CommRing.{u_1} CommRing.category_theory.concrete_category.{u_1}))) (Top.continuous_functions.{u_1} X R) (Top.continuous_functions.{u_1} X S)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{u+2} Top.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{u u+1} TopCommRing.{u} (@category_theory.category_struct.to_has_hom.{u u+1} TopCommRing.{u} (@category_theory.category.to_category_struct.{u u+1} TopCommRing.{u} (@category_theory.concrete_category.to_category.{u} TopCommRing.{u} TopCommRing.category_theory.concrete_category.{u}))) R S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title=' A homomorphism of topological rings can be postcomposed with functions from a source space `X`;
this is a ring homomorphism (with respect to the pointwise ring operations on functions).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74  /-- The presheaf (of commutative rings), consisting of functions on an open set `U ⊆ X` with</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75  values in some topological commutative ring `T`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76  def presheaf_to_TopCommRing (T : TopCommRing.{v}) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='TopCommRing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/TopCommRing.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='A bundled topological commutative ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77    X.presheaf CommRing.{v} :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Top.presheaf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='CommRing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/sheaves/presheaf.lean&#x27;, &#x27;line&#x27;: 20, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/category/CommRing/basic.lean&#x27;, &#x27;line&#x27;: 119, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Top.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (C : Type (v+1)) [𝒞 : category_theory.category.{v v+1} C], Top.{v} → Type (v+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The category of commutative rings.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78  (opens.to_Top X).op ⋙ (CommRing_yoneda.obj T)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='topological_space.opens.to_Top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Top.CommRing_yoneda'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/Top/opens.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 87, &#x27;column&#x27;: 21}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 67, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (X : Top.{u}), @category_theory.functor.{u u u u+1} (@topological_space.opens.{u} (@coe_sort.{u+2 u+2} Top.{u} (@category_theory.bundled.has_coe_to_sort.{u u} topological_space.{u}) X) (Top.topological_space_unbundled.{u} X)) (@topological_space.opens.opens_category.{u} X) Top.{u} (@category_theory.bundled_hom.category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u}))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Top.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type (v+1)} [𝒟 : category_theory.category.{v v+1} D], @category_theory.functor.{v v v v+1} C 𝒞 D 𝒟 → @category_theory.functor.{v v v v+1} (opposite.{v+1} C) (@category_theory.category.opposite.{v v} C 𝒞) (opposite.{v+2} D) (@category_theory.category.opposite.{v v+1} D 𝒟)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type (v+1)} [𝒟 : category_theory.category.{v v+1} D] {E : Type (v+1)} [ℰ : category_theory.category.{v v+1} E], @category_theory.functor.{v v v v+1} C 𝒞 D 𝒟 → @category_theory.functor.{v v v+1 v+1} D 𝒟 E ℰ → @category_theory.functor.{v v v v+1} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v v+1 v+1 v+1} TopCommRing.{v} (@category_theory.concrete_category.to_category.{v} TopCommRing.{v} TopCommRing.category_theory.concrete_category.{v}) (@category_theory.functor.{v v v+1 v+1} (opposite.{v+2} Top.{v}) (@category_theory.category.opposite.{v v+1} Top.{v} (@category_theory.bundled_hom.category.{v} topological_space.{v} (λ (α β : Type v) (Iα : topological_space.{v} α) (Iβ : topological_space.{v} β), @subtype.{v+1} (α → β) (@continuous.{v v} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{v} (λ (α : Type v), topological_space.{v} α) continuous.{v v} Top.concrete_category_continuous.{v}))) CommRing.{v} (@category_theory.concrete_category.to_category.{v} CommRing.{v} CommRing.category_theory.concrete_category.{v})) (@category_theory.functor.category.{v v v+1 v+1} (opposite.{v+2} Top.{v}) (@category_theory.category.opposite.{v v+1} Top.{v} (@category_theory.bundled_hom.category.{v} topological_space.{v} (λ (α β : Type v) (Iα : topological_space.{v} α) (Iβ : topological_space.{v} β), @subtype.{v+1} (α → β) (@continuous.{v v} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{v} (λ (α : Type v), topological_space.{v} α) continuous.{v v} Top.concrete_category_continuous.{v}))) CommRing.{v} (@category_theory.concrete_category.to_category.{v} CommRing.{v} CommRing.category_theory.concrete_category.{v}))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (v+1)} [_inst_1 : category_theory.category.{v v+1} C] {D : Type (v+1)} [_inst_2 : category_theory.category.{v+1 v+1} D], @category_theory.functor.{v v+1 v+1 v+1} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='TopCommRing.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' An upgraded version of the Yoneda embedding, observing that the continuous maps
from `X : Top` to `R : TopCommRing` form a commutative ring, functorial in both `X` and `R`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80  /-- The presheaf (of commutative rings) of real valued functions. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81  noncomputable def presheaf_ℝ (Y : Top) : Y.presheaf CommRing :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='Top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Top.presheaf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='CommRing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/Top/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/sheaves/presheaf.lean&#x27;, &#x27;line&#x27;: 20, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/category/CommRing/basic.lean&#x27;, &#x27;line&#x27;: 119, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Top.{0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (C : Type 1) [𝒞 : category_theory.category.{0 1} C], Top.{0} → Type 1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='The category of topological spaces and continuous maps.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The category of commutative rings.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82  presheaf_to_TopCommRing Y (TopCommRing.of ℝ)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Top.presheaf_to_TopCommRing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='TopCommRing.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 76, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/TopCommRing.lean&#x27;, &#x27;line&#x27;: 42, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (X : Top.{v}), TopCommRing.{v} → @Top.presheaf.{v v+1} CommRing.{v} (@category_theory.concrete_category.to_category.{v} CommRing.{v} CommRing.category_theory.concrete_category.{v}) X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Top.{0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (X : Type u) [_inst_1 : comm_ring.{u} X] [_inst_2 : topological_space.{u} X] [_inst_3 : @topological_ring.{u} X _inst_2 (@comm_ring.to_ring.{u} X _inst_1)], TopCommRing.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' The presheaf (of commutative rings), consisting of functions on an open set `U ⊆ X` with
values in some topological commutative ring `T`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Construct a bundled `TopCommRing` from the underlying type and the appropriate typeclasses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84  /-- The presheaf (of commutative rings) of complex valued functions. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85  noncomputable def presheaf_ℂ (Y : Top) : Y.presheaf CommRing :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='Top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Top.presheaf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='CommRing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/Top/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/sheaves/presheaf.lean&#x27;, &#x27;line&#x27;: 20, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/category/CommRing/basic.lean&#x27;, &#x27;line&#x27;: 119, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Top.{0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (C : Type 1) [𝒞 : category_theory.category.{0 1} C], Top.{0} → Type 1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='The category of topological spaces and continuous maps.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The category of commutative rings.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86  presheaf_to_TopCommRing Y (TopCommRing.of ℂ)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Top.presheaf_to_TopCommRing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='TopCommRing.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 76, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/TopCommRing.lean&#x27;, &#x27;line&#x27;: 42, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (X : Top.{v}), TopCommRing.{v} → @Top.presheaf.{v v+1} CommRing.{v} (@category_theory.concrete_category.to_category.{v} CommRing.{v} CommRing.category_theory.concrete_category.{v}) X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Top.{0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (X : Type u) [_inst_1 : comm_ring.{u} X] [_inst_2 : topological_space.{u} X] [_inst_3 : @topological_ring.{u} X _inst_2 (@comm_ring.to_ring.{u} X _inst_1)], TopCommRing.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' The presheaf (of commutative rings), consisting of functions on an open set `U ⊆ X` with
values in some topological commutative ring `T`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Construct a bundled `TopCommRing` from the underlying type and the appropriate typeclasses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88  end Top</code></pre>
</body>