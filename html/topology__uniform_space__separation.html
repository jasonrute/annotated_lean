<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2017 Johannes Hölzl. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Johannes Hölzl, Patrick Massot</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  Hausdorff properties of uniform spaces. Separation quotient.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  import topology.uniform_space.basic</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  open filter topological_space lattice set classical</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  open_locale classical topological_space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  noncomputable theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  set_option eqn_compiler.zeta true</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='(equation compiler) apply zeta-expansion (expand references to let-declarations) before creating auxiliary definitions.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  universes u v w</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  variables {α : Type u} {β : Type v} {γ : Type w}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  variables [uniform_space α] [uniform_space β] [uniform_space γ]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='uniform_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='uniform_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='uniform_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type w → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A uniform space is a generalization of the &quot;uniform&quot; topological aspects of a
 metric space. It consists of a filter on `α × α` called the &quot;uniformity&quot;, which
 satisfies properties analogous to the reflexivity, symmetry, and triangle properties
 of a metric.

 A metric space has a natural uniformity, and a uniform space has a natural topology.
 A topological group also has a natural uniformity, even when it is not metrizable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A uniform space is a generalization of the &quot;uniform&quot; topological aspects of a
 metric space. It consists of a filter on `α × α` called the &quot;uniformity&quot;, which
 satisfies properties analogous to the reflexivity, symmetry, and triangle properties
 of a metric.

 A metric space has a natural uniformity, and a uniform space has a natural topology.
 A topological group also has a natural uniformity, even when it is not metrizable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A uniform space is a generalization of the &quot;uniform&quot; topological aspects of a
 metric space. It consists of a filter on `α × α` called the &quot;uniformity&quot;, which
 satisfies properties analogous to the reflexivity, symmetry, and triangle properties
 of a metric.

 A metric space has a natural uniformity, and a uniform space has a natural topology.
 A topological group also has a natural uniformity, even when it is not metrizable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  open_locale uniformity</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  /- separated uniformity -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  /-- The separation relation is the intersection of all entourages.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24    Two points which are related by the separation relation are &quot;indistinguishable&quot;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25    according to the uniform structure. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  protected def separation_rel (α : Type u) [u : uniform_space α] :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='blue'><a title='uniform_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='orange'><a title='A uniform space is a generalization of the &quot;uniform&quot; topological aspects of a
 metric space. It consists of a filter on `α × α` called the &quot;uniformity&quot;, which
 satisfies properties analogous to the reflexivity, symmetry, and triangle properties
 of a metric.

 A metric space has a natural uniformity, and a uniform space has a natural topology.
 A topological group also has a natural uniformity, even when it is not metrizable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  ⋂₀ (𝓤 α).sets</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='set.sInter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, set.{u} (set.{u} α) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u) [_inst_2 : uniform_space.{u} α], filter.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, filter.{u} α → set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Intersection of a set of sets.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  lemma separated_equiv : equivalence (λx y, (x, y) ∈ separation_rel α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='equivalence'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='separation_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 1043, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 26, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Π {β : Sort v}, (β → β → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [u : uniform_space.{u} α], set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='orange'><a title='The separation relation is the intersection of all entourages.
 Two points which are related by the separation relation are &quot;indistinguishable&quot;
 according to the uniform structure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  ⟨assume x, assume s, refl_mem_uniformity,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='refl_mem_uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 167, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : uniform_space.{u} α] {x : α} {s : set.{u} (prod.{u u} α α)}, @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) s (@uniformity.{u} α _inst_1) → @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α x x) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31    assume x y, assume h (s : set (α×α)) hs,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='(λ (x y : α), @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α x y) (@separation_rel.{u} α _inst_1)) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (set.{u} (set.{u} (prod.{u u} α α))) (@set.has_mem.{u} (set.{u} (prod.{u u} α α))) s (@filter.sets.{u} (prod.{u u} α α) (@uniformity.{u} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32      have preimage prod.swap s ∈ 𝓤 α,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod.swap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/prod.lean&#x27;, &#x27;line&#x27;: 49, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α β : Type u}, (α → β) → set.{u} β → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → prod.{u u} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [_inst_2 : uniform_space.{u} α], filter.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Swap the factors of a product. `swap (a, b) = (b, a)`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33        from symm_le_uniformity hs,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='symm_le_uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 171, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : uniform_space.{u} α], @has_le.le.{u} (filter.{u} (prod.{u u} α α)) (@preorder.to_has_le.{u} (filter.{u} (prod.{u u} α α)) (@partial_order.to_preorder.{u} (filter.{u} (prod.{u u} α α)) (@filter.partial_order.{u} (prod.{u u} α α)))) (@filter.map.{u u} (prod.{u u} α α) (prod.{u u} α α) (@prod.swap.{u u} α α) (@uniformity.{u} α _inst_1)) (@uniformity.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (set.{u} (set.{u} (prod.{u u} α α))) (@set.has_mem.{u} (set.{u} (prod.{u u} α α))) s (@filter.sets.{u} (prod.{u u} α α) (@uniformity.{u} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34      h _ this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='(λ (x y : α), @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α x y) (@separation_rel.{u} α _inst_1)) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) (@set.preimage.{u u} (prod.{u u} α α) (prod.{u u} α α) (@prod.swap.{u u} α α) s) (@uniformity.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35    assume x y z (hxy : (x, y) ∈ separation_rel α) (hyz : (y, z) ∈ separation_rel α)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='separation_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='separation_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 26, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 26, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [u : uniform_space.{u} α], set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [u : uniform_space.{u} α], set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='The separation relation is the intersection of all entourages.
 Two points which are related by the separation relation are &quot;indistinguishable&quot;
 according to the uniform structure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The separation relation is the intersection of all entourages.
 Two points which are related by the separation relation are &quot;indistinguishable&quot;
 according to the uniform structure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36        s (hs : s ∈ 𝓤 α),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [_inst_2 : uniform_space.{u} α], filter.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37      let ⟨t, ht, (h_ts : comp_rel t t ⊆ s)⟩ := comp_mem_uniformity_sets hs in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ht'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h_ts'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='comp_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='comp_mem_uniformity_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@Exists.{u+1} (set.{u} (prod.{u u} α α)) (λ (t : set.{u} (prod.{u u} α α)), @Exists.{0} (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) t (@uniformity.{u} α _inst_1)) (λ (H : @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) t (@uniformity.{u} α _inst_1)), @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α)) (@comp_rel.{u} α t t) s)) → @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α x z) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) t (@uniformity.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α)) (@comp_rel.{u} α t t) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u}, set.{u} (prod.{u u} α α) → set.{u} (prod.{u u} α α) → set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : uniform_space.{u} α] {s : set.{u} (prod.{u u} α α)}, @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) s (@uniformity.{u} α _inst_1) → @Exists.{u+1} (set.{u} (prod.{u u} α α)) (λ (t : set.{u} (prod.{u u} α α)), @Exists.{0} (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) t (@uniformity.{u} α _inst_1)) (λ (H : @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) t (@uniformity.{u} α _inst_1)), @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α)) (@comp_rel.{u} α t t) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) s (@uniformity.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='The composition of relations'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38      h_ts $ show (x, z) ∈ comp_rel t t,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='comp_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} (prod.{u u} α α) → set.{u} (prod.{u u} α α) → set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='The composition of relations'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39        from ⟨y, hxy t ht, hyz t ht⟩⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hxy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='hyz'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α x y) (@separation_rel.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α y z) (@separation_rel.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  @[class] def separated (α : Type u) [uniform_space α] :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='uniform_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='A uniform space is a generalization of the &quot;uniform&quot; topological aspects of a
 metric space. It consists of a filter on `α × α` called the &quot;uniformity&quot;, which
 satisfies properties analogous to the reflexivity, symmetry, and triangle properties
 of a metric.

 A metric space has a natural uniformity, and a uniform space has a natural topology.
 A topological group also has a natural uniformity, even when it is not metrizable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  separation_rel α = id_rel</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='separation_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='id_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 26, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type u) [u : uniform_space.{u} α], set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, set.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The separation relation is the intersection of all entourages.
 Two points which are related by the separation relation are &quot;indistinguishable&quot;
 according to the uniform structure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The identity relation, or the graph of the identity function'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  theorem separated_def {α : Type u} [uniform_space α] :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='uniform_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='A uniform space is a generalization of the &quot;uniform&quot; topological aspects of a
 metric space. It consists of a filter on `α × α` called the &quot;uniformity&quot;, which
 satisfies properties analogous to the reflexivity, symmetry, and triangle properties
 of a metric.

 A metric space has a natural uniformity, and a uniform space has a natural topology.
 A topological group also has a natural uniformity, even when it is not metrizable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45    separated α ↔ ∀ x y, (∀ r ∈ 𝓤 α, (x, y) ∈ r) → x = y :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='separated'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 41, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u) [_inst_4 : uniform_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u) [_inst_2 : uniform_space.{u} α], filter.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  by simp [separated, id_rel_subset.2 separated_equiv.1, subset.antisymm_iff];</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47     simp [subset_def, separation_rel]</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  theorem separated_def&#x27; {α : Type u} [uniform_space α] :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='uniform_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='A uniform space is a generalization of the &quot;uniform&quot; topological aspects of a
 metric space. It consists of a filter on `α × α` called the &quot;uniformity&quot;, which
 satisfies properties analogous to the reflexivity, symmetry, and triangle properties
 of a metric.

 A metric space has a natural uniformity, and a uniform space has a natural topology.
 A topological group also has a natural uniformity, even when it is not metrizable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50    separated α ↔ ∀ x y, x ≠ y → ∃ r ∈ 𝓤 α, (x, y) ∉ r :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='separated'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='not'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 41, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u) [_inst_4 : uniform_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u) [_inst_2 : uniform_space.{u} α], filter.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  separated_def.trans $ forall_congr $ λ x, forall_congr $ λ y,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='separated_def'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='forall_congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='forall_congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 248, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 571, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 571, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_4 : uniform_space.{u} α], iff (@separated.{u} α _inst_4) (∀ (x y : α), (∀ (r : set.{u} (prod.{u u} α α)), @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) r (@uniformity.{u} α _inst_4) → @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α x y) r) → @eq.{u+1} α x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b c : Prop}, iff a b → iff b c → iff a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} {p q : α → Prop}, (∀ (a : α), iff (p a) (q a)) → iff (∀ (a : α), p a) (∀ (a : α), q a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {p q : α → Prop}, (∀ (a : α), iff (p a) (q a)) → iff (∀ (a : α), p a) (∀ (a : α), q a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  by rw ← not_imp_not; simp [classical.not_forall]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='not_imp_not'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='classical.not_forall'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 250, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 576, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop} [_inst_1 : decidable a], iff (not a → not b) (b → a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Sort ?l_1} {p : α → Prop}, iff (not (∀ (x : α), p x)) (@Exists.{?l_1} α (λ (x : α), not (p x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
_inst_4 : uniform_space.{u} α,
x y : α
⊢ iff
    ((∀ (r : set.{u} (prod.{u u} α α)),
        @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
          (@filter.has_mem.{u} (prod.{u u} α α))
          r
          (@uniformity.{u} α _inst_4) →
        @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
          (@prod.mk.{u u} α α x y)
          r) →
     @eq.{u+1} α x y)
    (@ne.{u+1} α x y →
     @Exists.{u+1} (set.{u} (prod.{u u} α α))
       (λ (r : set.{u} (prod.{u u} α α)),
          @Exists.{0}
            (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
               (@filter.has_mem.{u} (prod.{u u} α α))
               r
               (@uniformity.{u} α _inst_4))
            (λ
             (H :
               @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
                 (@filter.has_mem.{u} (prod.{u u} α α))
                 r
                 (@uniformity.{u} α _inst_4)),
               not
                 (@has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α))
                    (@set.has_mem.{u} (prod.{u u} α α))
                    (@prod.mk.{u u} α α x y)
                    r))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_4 : uniform_space.{u} α,
x y : α
⊢ iff
    ((∀ (r : set.{u} (prod.{u u} α α)),
        @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
          (@filter.has_mem.{u} (prod.{u u} α α))
          r
          (@uniformity.{u} α _inst_4) →
        @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
          (@prod.mk.{u u} α α x y)
          r) →
     @eq.{u+1} α x y)
    (@ne.{u+1} α x y →
     @Exists.{u+1} (set.{u} (prod.{u u} α α))
       (λ (r : set.{u} (prod.{u u} α α)),
          @Exists.{0}
            (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
               (@filter.has_mem.{u} (prod.{u u} α α))
               r
               (@uniformity.{u} α _inst_4))
            (λ
             (H :
               @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
                 (@filter.has_mem.{u} (prod.{u u} α α))
                 r
                 (@uniformity.{u} α _inst_4)),
               not
                 (@has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α))
                    (@set.has_mem.{u} (prod.{u u} α α))
                    (@prod.mk.{u u} α α x y)
                    r))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54  @[priority 100] -- see Note [lower instance priority]</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  instance separated_t2 [s : separated α] : t2_space α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='separated'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='t2_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;line&#x27;: 41, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/separation.lean&#x27;, &#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Π (α : Type u) [_inst_4 : uniform_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='orange'><a title='A T₂ space, also known as a Hausdorff space, is one in which for every
 `x ≠ y` there exists disjoint open sets around `x` and `y`. This is
 the most widely used of the separation axioms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56  ⟨assume x y, assume h : x ≠ y,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57  let ⟨d, hd, (hxy : (x, y) ∉ d)⟩ := separated_def&#x27;.1 s x y h in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hxy'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='not'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='separated_def&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{u+1} (set.{u} (prod.{u u} α α)) (λ (r : set.{u} (prod.{u u} α α)), @Exists.{0} (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) r (@uniformity.{u} α _inst_1)) (λ (H : @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) r (@uniformity.{u} α _inst_1)), not (@has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α x y) r))) → @Exists.{(max (u+1) 1)} (set.{u} α) (λ (u : set.{u} α), @Exists.{(max (u+1) 1)} (set.{u} α) (λ (v : set.{u} α), and (@is_open.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) u) (and (@is_open.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) v) (and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x u) (and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y v) (@eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) u v) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) d (@uniformity.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='not (@has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α x y) d)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='∀ {α : Type u} [_inst_4 : uniform_space.{u} α], iff (@separated.{u} α _inst_4) (∀ (x y : α), @ne.{u+1} α x y → @Exists.{u+1} (set.{u} (prod.{u u} α α)) (λ (r : set.{u} (prod.{u u} α α)), @Exists.{0} (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) r (@uniformity.{u} α _inst_4)) (λ (H : @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) r (@uniformity.{u} α _inst_4)), not (@has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α x y) r))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@separated.{u} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{u+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58  let ⟨d&#x27;, hd&#x27;, (hd&#x27;d&#x27; : comp_rel d&#x27; d&#x27; ⊆ d)⟩ := comp_mem_uniformity_sets hd in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='d&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hd&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hd&#x27;d&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='comp_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='comp_mem_uniformity_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{u+1} (set.{u} (prod.{u u} α α)) (λ (t : set.{u} (prod.{u u} α α)), @Exists.{0} (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) t (@uniformity.{u} α _inst_1)) (λ (H : @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) t (@uniformity.{u} α _inst_1)), @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α)) (@comp_rel.{u} α t t) d)) → @Exists.{(max (u+1) 1)} (set.{u} α) (λ (u : set.{u} α), @Exists.{(max (u+1) 1)} (set.{u} α) (λ (v : set.{u} α), and (@is_open.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) u) (and (@is_open.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) v) (and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x u) (and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y v) (@eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) u v) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) d&#x27; (@uniformity.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α)) (@comp_rel.{u} α d&#x27; d&#x27;) d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u}, set.{u} (prod.{u u} α α) → set.{u} (prod.{u u} α α) → set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : uniform_space.{u_1} α] {s : set.{u_1} (prod.{u_1 u_1} α α)}, @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) s (@uniformity.{u_1} α _inst_1) → @Exists.{u_1+1} (set.{u_1} (prod.{u_1 u_1} α α)) (λ (t : set.{u_1} (prod.{u_1 u_1} α α)), @Exists.{0} (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) t (@uniformity.{u_1} α _inst_1)) (λ (H : @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) t (@uniformity.{u_1} α _inst_1)), @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α)) (@comp_rel.{u_1} α t t) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The composition of relations'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  have {y | (x, y) ∈ d&#x27;} ∈ 𝓝 x,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60    from mem_nhds_left x hd&#x27;,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='mem_nhds_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 284, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : uniform_space.{u_1} α] (x : α) {s : set.{u_1} (prod.{u_1 u_1} α α)}, @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) s (@uniformity.{u_1} α _inst_1) → @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) (@set_of.{u_1} α (λ (y : α), @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α x y) s)) (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  let ⟨u, hu₁, hu₂, hu₃⟩ := mem_nhds_sets_iff.mp this in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hu₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hu₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hu₃'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='mem_nhds_sets_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 421, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{u+1} (set.{u} α) (λ (t : set.{u} α), @Exists.{0} (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α x y) d&#x27;))) (λ (H : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α x y) d&#x27;))), and (@is_open.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) t) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t))) → @Exists.{(max (u+1) 1)} (set.{u} α) (λ (u : set.{u} α), @Exists.{(max (u+1) 1)} (set.{u} α) (λ (v : set.{u} α), and (@is_open.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) u) (and (@is_open.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) v) (and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x u) (and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y v) (@eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) u v) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) u (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α x y) d&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@is_open.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {a : α} {s : set.{u} α}, iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 a)) (@Exists.{u+1} (set.{u} α) (λ (t : set.{u} α), @Exists.{0} (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s) (λ (H : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s), and (@is_open.{u} α _inst_1 t) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α x y) d&#x27;)) (@nhds.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  have {x | (x, y) ∈ d&#x27;} ∈ 𝓝 y,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63    from mem_nhds_right y hd&#x27;,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='mem_nhds_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 290, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : uniform_space.{u_1} α] (y : α) {s : set.{u_1} (prod.{u_1 u_1} α α)}, @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) s (@uniformity.{u_1} α _inst_1) → @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) (@set_of.{u_1} α (λ (x : α), @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α x y) s)) (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  let ⟨v, hv₁, hv₂, hv₃⟩ := mem_nhds_sets_iff.mp this in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hv₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hv₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hv₃'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='mem_nhds_sets_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 421, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{u+1} (set.{u} α) (λ (t : set.{u} α), @Exists.{0} (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t (@set_of.{u} α (λ (x : α), @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α x y) d&#x27;))) (λ (H : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t (@set_of.{u} α (λ (x : α), @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α x y) d&#x27;))), and (@is_open.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) t) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y t))) → @Exists.{(max (u+1) 1)} (set.{u} α) (λ (u : set.{u} α), @Exists.{(max (u+1) 1)} (set.{u} α) (λ (v : set.{u} α), and (@is_open.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) u) (and (@is_open.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) v) (and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x u) (and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y v) (@eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) u v) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) v (@set_of.{u} α (λ (x : α), @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α x y) d&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@is_open.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {a : α} {s : set.{u} α}, iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 a)) (@Exists.{u+1} (set.{u} α) (λ (t : set.{u} α), @Exists.{0} (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s) (λ (H : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s), and (@is_open.{u} α _inst_1 t) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) (@set_of.{u} α (λ (x : α), @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α x y) d&#x27;)) (@nhds.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65  have u ∩ v = ∅, from</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_emptyc.emptyc'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 332, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u} [c : has_inter.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [c : has_emptyc.{u} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66    eq_empty_of_subset_empty $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.eq_empty_of_subset_empty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {s : set.{u} α}, @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)) → @eq.{(max (u+1) 1)} (set.{u} α) s (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67    assume z ⟨(h₁ : z ∈ u), (h₂ : z ∈ v)⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='h₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68    have (x, y) ∈ comp_rel d&#x27; d&#x27;, from ⟨z, hu₁ h₁, hv₁ h₂⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='comp_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} (prod.{u u} α α) → set.{u} (prod.{u u} α α) → set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The composition of relations'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69    hxy $ hd&#x27;d&#x27; this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α x y) (@comp_rel.{u} α d&#x27; d&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  ⟨u, v, hu₂, hv₂, hu₃, hv₃, this⟩⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='@eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) u v) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72  @[priority 100] -- see Note [lower instance priority]</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73  instance separated_regular [separated α] : regular_space α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='separated'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='regular_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;line&#x27;: 41, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/separation.lean&#x27;, &#x27;line&#x27;: 309, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Π (α : Type u) [_inst_4 : uniform_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='orange'><a title='A T₃ space, also known as a regular space (although this condition sometimes
 omits T₂), is one in which for every closed `C` and `x ∉ C`, there exist
 disjoint open sets containing `x` and `C` respectively.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74  { regular := λs a hs ha,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_closed.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75      have -s ∈ 𝓝 a,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76        from mem_nhds_sets hs ha,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='mem_nhds_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 428, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {a : α} {s : set.{u} α}, @is_open.{u} α _inst_1 s → @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s → @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_closed.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77      have {p : α × α | p.1 = a → p.2 ∈ -s} ∈ 𝓤 α,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='prod.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='prod.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [_inst_2 : uniform_space.{u} α], filter.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78        from mem_nhds_uniformity_iff.mp this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='mem_nhds_uniformity_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 245, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : uniform_space.{u} α] {x : α} {s : set.{u} α}, iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) x)) (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) (@set_of.{u} (prod.{u u} α α) (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) x → @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p) s)) (@uniformity.{u} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s) (@nhds.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79      let ⟨d, hd, h⟩ := comp_mem_uniformity_sets this in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='comp_mem_uniformity_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@Exists.{u+1} (set.{u} (prod.{u u} α α)) (λ (t : set.{u} (prod.{u u} α α)), @Exists.{0} (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) t (@uniformity.{u} α _inst_1)) (λ (H : @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) t (@uniformity.{u} α _inst_1)), @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α)) (@comp_rel.{u} α t t) (@set_of.{u} (prod.{u u} α α) (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) a → @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))))) → @Exists.{(max (u+1) 1)} (set.{u} α) (λ (t : set.{u} α), and (@is_open.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) t) (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t) (@eq.{u+1} (filter.{u} α) (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) a) (@filter.principal.{u} α t)) (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) d (@uniformity.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α)) (@comp_rel.{u} α d d) (@set_of.{u} (prod.{u u} α α) (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) a → @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : uniform_space.{u_1} α] {s : set.{u_1} (prod.{u_1 u_1} α α)}, @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) s (@uniformity.{u_1} α _inst_1) → @Exists.{u_1+1} (set.{u_1} (prod.{u_1 u_1} α α)) (λ (t : set.{u_1} (prod.{u_1 u_1} α α)), @Exists.{0} (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) t (@uniformity.{u_1} α _inst_1)) (λ (H : @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) t (@uniformity.{u_1} α _inst_1)), @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α)) (@comp_rel.{u_1} α t t) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) (@set_of.{u} (prod.{u u} α α) (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) a → @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))) (@uniformity.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80      let e := {y:α| (a, y) ∈ d} in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81      have hae : a ∈ closure e, from subset_closure $ refl_mem_uniformity hd,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='subset_closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='refl_mem_uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 245, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 250, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 167, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {s : set.{u} α}, @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s (@closure.{u} α _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : uniform_space.{u_1} α] {x : α} {s : set.{u_1} (prod.{u_1 u_1} α α)}, @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) s (@uniformity.{u_1} α _inst_1) → @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α x x) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The closure of `s` is the smallest closed set containing `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82      have set.prod (closure e) (closure e) ⊆ comp_rel d (comp_rel (set.prod e e) d),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='set.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='comp_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='comp_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1408, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 245, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 245, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1408, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α β : Type u}, set.{u} α → set.{u} β → set.{u} (prod.{u u} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} (prod.{u u} α α) → set.{u} (prod.{u u} α α) → set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u}, set.{u} (prod.{u u} α α) → set.{u} (prod.{u u} α α) → set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, set.{u_1} α → set.{u_2} β → set.{(max u_1 u_2)} (prod.{u_1 u_2} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The cartesian product `prod s t` is the set of `(a, b)`
 such that `a ∈ s` and `b ∈ t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The closure of `s` is the smallest closed set containing `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The closure of `s` is the smallest closed set containing `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The composition of relations'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The composition of relations'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The cartesian product `prod s t` is the set of `(a, b)`
 such that `a ∈ s` and `b ∈ t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83      begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='α : Type u,
_inst_1 : uniform_space.{u} α,
_inst_4 : @separated.{u} α _inst_1,
s : set.{u} α,
a : α,
hs : @is_closed.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) s,
ha : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s),
this :
  @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α)
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@nhds.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) a),
this :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (p : prod.{u u} α α),
          @eq.{u+1} α (@prod.fst.{u u} α α p) a →
          @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p)
            (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)))
    (@uniformity.{u} α _inst_1),
_let_match :
  @Exists.{u+1} (set.{u} (prod.{u u} α α))
    (λ (t : set.{u} (prod.{u u} α α)),
       @Exists.{0}
         (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
            (@filter.has_mem.{u} (prod.{u u} α α))
            t
            (@uniformity.{u} α _inst_1))
         (λ
          (H :
            @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
              (@filter.has_mem.{u} (prod.{u u} α α))
              t
              (@uniformity.{u} α _inst_1)),
            @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α))
              (@comp_rel.{u} α t t)
              (@set_of.{u} (prod.{u u} α α)
                 (λ (p : prod.{u u} α α),
                    @eq.{u+1} α (@prod.fst.{u u} α α p) a →
                    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p)
                      (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))))) →
  @Exists.{(max (u+1) 1)} (set.{u} α)
    (λ (t : set.{u} α),
       and (@is_open.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) t)
         (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t)
            (@eq.{u+1} (filter.{u} α)
               (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α)
                  (@nhds.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) a)
                  (@filter.principal.{u} α t))
               (@lattice.has_bot.bot.{u} (filter.{u} α)
                  (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
                     (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                        (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                           (@filter.lattice.complete_lattice.{u} α)))))))),
d : set.{u} (prod.{u u} α α),
hd :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    d
    (@uniformity.{u} α _inst_1),
h :
  @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α)) (@comp_rel.{u} α d d)
    (@set_of.{u} (prod.{u u} α α)
       (λ (p : prod.{u u} α α),
          @eq.{u+1} α (@prod.fst.{u u} α α p) a →
          @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p)
            (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))),
e : set.{u} α :=
  @set_of.{u} α
    (λ (y : α),
       @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
         (@prod.mk.{u u} α α a y)
         d),
hae :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
    (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e)
⊢ @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α))
    (@set.prod.{u u} α α (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e)
       (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e))
    (@comp_rel.{u} α d (@comp_rel.{u} α (@set.prod.{u u} α α e e) d))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84        rw [←closure_prod_eq, closure_eq_inter_uniformity],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='closure_prod_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='closure_eq_inter_uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 263, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 364, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : topological_space.{u} α] [_inst_2 : topological_space.{u} β] {s : set.{u} α} {t : set.{u} β}, @eq.{(max (u+1) 1)} (set.{u} (prod.{u u} α β)) (@closure.{u} (prod.{u u} α β) (@prod.topological_space.{u u} α β _inst_1 _inst_2) (@set.prod.{u u} α β s t)) (@set.prod.{u u} α β (@closure.{u} α _inst_1 s) (@closure.{u} β _inst_2 t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : uniform_space.{u} α] {t : set.{u} (prod.{u u} α α)}, @eq.{(max (u+1) 1)} (set.{u} (prod.{u u} α α)) (@closure.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α (@uniform_space.to_topological_space.{u} α _inst_1) (@uniform_space.to_topological_space.{u} α _inst_1)) t) (@set.Inter.{u u+1} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (λ (d : set.{u} (prod.{u u} α α)), @set.Inter.{u 0} (prod.{u u} α α) (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) d (@uniformity.{u} α _inst_1)) (λ (H : @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) d (@uniformity.{u} α _inst_1)), @comp_rel.{u} α d (@comp_rel.{u} α t d))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : uniform_space.{u} α,
_inst_4 : @separated.{u} α _inst_1,
s : set.{u} α,
a : α,
hs : @is_closed.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) s,
ha : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s),
this :
  @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α)
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@nhds.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) a),
this :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (p : prod.{u u} α α),
          @eq.{u+1} α (@prod.fst.{u u} α α p) a →
          @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p)
            (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)))
    (@uniformity.{u} α _inst_1),
_let_match :
  @Exists.{u+1} (set.{u} (prod.{u u} α α))
    (λ (t : set.{u} (prod.{u u} α α)),
       @Exists.{0}
         (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
            (@filter.has_mem.{u} (prod.{u u} α α))
            t
            (@uniformity.{u} α _inst_1))
         (λ
          (H :
            @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
              (@filter.has_mem.{u} (prod.{u u} α α))
              t
              (@uniformity.{u} α _inst_1)),
            @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α))
              (@comp_rel.{u} α t t)
              (@set_of.{u} (prod.{u u} α α)
                 (λ (p : prod.{u u} α α),
                    @eq.{u+1} α (@prod.fst.{u u} α α p) a →
                    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p)
                      (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))))) →
  @Exists.{(max (u+1) 1)} (set.{u} α)
    (λ (t : set.{u} α),
       and (@is_open.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) t)
         (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t)
            (@eq.{u+1} (filter.{u} α)
               (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α)
                  (@nhds.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) a)
                  (@filter.principal.{u} α t))
               (@lattice.has_bot.bot.{u} (filter.{u} α)
                  (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
                     (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                        (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                           (@filter.lattice.complete_lattice.{u} α)))))))),
d : set.{u} (prod.{u u} α α),
hd :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    d
    (@uniformity.{u} α _inst_1),
h :
  @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α)) (@comp_rel.{u} α d d)
    (@set_of.{u} (prod.{u u} α α)
       (λ (p : prod.{u u} α α),
          @eq.{u+1} α (@prod.fst.{u u} α α p) a →
          @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p)
            (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))),
e : set.{u} α :=
  @set_of.{u} α
    (λ (y : α),
       @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
         (@prod.mk.{u u} α α a y)
         d),
hae :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
    (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e)
⊢ @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α))
    (@set.prod.{u u} α α (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e)
       (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e))
    (@comp_rel.{u} α d (@comp_rel.{u} α (@set.prod.{u u} α α e e) d))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : uniform_space.{u} α,
_inst_4 : @separated.{u} α _inst_1,
s : set.{u} α,
a : α,
hs : @is_closed.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) s,
ha : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s),
this :
  @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α)
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@nhds.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) a),
this :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (p : prod.{u u} α α),
          @eq.{u+1} α (@prod.fst.{u u} α α p) a →
          @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p)
            (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)))
    (@uniformity.{u} α _inst_1),
_let_match :
  @Exists.{u+1} (set.{u} (prod.{u u} α α))
    (λ (t : set.{u} (prod.{u u} α α)),
       @Exists.{0}
         (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
            (@filter.has_mem.{u} (prod.{u u} α α))
            t
            (@uniformity.{u} α _inst_1))
         (λ
          (H :
            @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
              (@filter.has_mem.{u} (prod.{u u} α α))
              t
              (@uniformity.{u} α _inst_1)),
            @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α))
              (@comp_rel.{u} α t t)
              (@set_of.{u} (prod.{u u} α α)
                 (λ (p : prod.{u u} α α),
                    @eq.{u+1} α (@prod.fst.{u u} α α p) a →
                    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p)
                      (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))))) →
  @Exists.{(max (u+1) 1)} (set.{u} α)
    (λ (t : set.{u} α),
       and (@is_open.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) t)
         (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t)
            (@eq.{u+1} (filter.{u} α)
               (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α)
                  (@nhds.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) a)
                  (@filter.principal.{u} α t))
               (@lattice.has_bot.bot.{u} (filter.{u} α)
                  (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
                     (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                        (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                           (@filter.lattice.complete_lattice.{u} α)))))))),
d : set.{u} (prod.{u u} α α),
hd :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    d
    (@uniformity.{u} α _inst_1),
h :
  @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α)) (@comp_rel.{u} α d d)
    (@set_of.{u} (prod.{u u} α α)
       (λ (p : prod.{u u} α α),
          @eq.{u+1} α (@prod.fst.{u u} α α p) a →
          @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p)
            (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))),
e : set.{u} α :=
  @set_of.{u} α
    (λ (y : α),
       @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
         (@prod.mk.{u u} α α a y)
         d),
hae :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
    (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e)
⊢ @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α))
    (@closure.{u} (prod.{u u} α α)
       (@prod.topological_space.{u u} α α (@uniform_space.to_topological_space.{u} α _inst_1)
          (@uniform_space.to_topological_space.{u} α _inst_1))
       (@set.prod.{u u} α α e e))
    (@comp_rel.{u} α d (@comp_rel.{u} α (@set.prod.{u u} α α e e) d))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : uniform_space.{u} α,
_inst_4 : @separated.{u} α _inst_1,
s : set.{u} α,
a : α,
hs : @is_closed.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) s,
ha : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s),
this :
  @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α)
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@nhds.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) a),
this :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (p : prod.{u u} α α),
          @eq.{u+1} α (@prod.fst.{u u} α α p) a →
          @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p)
            (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)))
    (@uniformity.{u} α _inst_1),
_let_match :
  @Exists.{u+1} (set.{u} (prod.{u u} α α))
    (λ (t : set.{u} (prod.{u u} α α)),
       @Exists.{0}
         (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
            (@filter.has_mem.{u} (prod.{u u} α α))
            t
            (@uniformity.{u} α _inst_1))
         (λ
          (H :
            @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
              (@filter.has_mem.{u} (prod.{u u} α α))
              t
              (@uniformity.{u} α _inst_1)),
            @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α))
              (@comp_rel.{u} α t t)
              (@set_of.{u} (prod.{u u} α α)
                 (λ (p : prod.{u u} α α),
                    @eq.{u+1} α (@prod.fst.{u u} α α p) a →
                    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p)
                      (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))))) →
  @Exists.{(max (u+1) 1)} (set.{u} α)
    (λ (t : set.{u} α),
       and (@is_open.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) t)
         (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t)
            (@eq.{u+1} (filter.{u} α)
               (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α)
                  (@nhds.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) a)
                  (@filter.principal.{u} α t))
               (@lattice.has_bot.bot.{u} (filter.{u} α)
                  (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
                     (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                        (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                           (@filter.lattice.complete_lattice.{u} α)))))))),
d : set.{u} (prod.{u u} α α),
hd :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    d
    (@uniformity.{u} α _inst_1),
h :
  @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α)) (@comp_rel.{u} α d d)
    (@set_of.{u} (prod.{u u} α α)
       (λ (p : prod.{u u} α α),
          @eq.{u+1} α (@prod.fst.{u u} α α p) a →
          @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p)
            (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))),
e : set.{u} α :=
  @set_of.{u} α
    (λ (y : α),
       @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
         (@prod.mk.{u u} α α a y)
         d),
hae :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
    (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e)
⊢ @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α))
    (@set.Inter.{u u+1} (prod.{u u} α α) (set.{u} (prod.{u u} α α))
       (λ (d : set.{u} (prod.{u u} α α)),
          @set.Inter.{u 0} (prod.{u u} α α)
            (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
               (@filter.has_mem.{u} (prod.{u u} α α))
               d
               (@uniformity.{u} α _inst_1))
            (λ
             (H :
               @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
                 (@filter.has_mem.{u} (prod.{u u} α α))
                 d
                 (@uniformity.{u} α _inst_1)), @comp_rel.{u} α d (@comp_rel.{u} α (@set.prod.{u u} α α e e) d))))
    (@comp_rel.{u} α d (@comp_rel.{u} α (@set.prod.{u u} α α e e) d))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85        change (⨅d&#x27; ∈ 𝓤 α, _) ≤ comp_rel d (comp_rel _ d),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='lattice.infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='lattice.infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='comp_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α ι : Type u} [_inst_1 : lattice.has_Inf.{u} α], (ι → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type u) [_inst_2 : uniform_space.{u} α], filter.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α ι : Type u} [_inst_1 : lattice.has_Inf.{u} α], (ι → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [c : has_le.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} (prod.{u u} α α) → set.{u} (prod.{u u} α α) → set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Indexed infimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Indexed infimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The composition of relations'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : uniform_space.{u} α,
_inst_4 : @separated.{u} α _inst_1,
s : set.{u} α,
a : α,
hs : @is_closed.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) s,
ha : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s),
this :
  @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α)
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@nhds.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) a),
this :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (p : prod.{u u} α α),
          @eq.{u+1} α (@prod.fst.{u u} α α p) a →
          @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p)
            (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)))
    (@uniformity.{u} α _inst_1),
_let_match :
  @Exists.{u+1} (set.{u} (prod.{u u} α α))
    (λ (t : set.{u} (prod.{u u} α α)),
       @Exists.{0}
         (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
            (@filter.has_mem.{u} (prod.{u u} α α))
            t
            (@uniformity.{u} α _inst_1))
         (λ
          (H :
            @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
              (@filter.has_mem.{u} (prod.{u u} α α))
              t
              (@uniformity.{u} α _inst_1)),
            @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α))
              (@comp_rel.{u} α t t)
              (@set_of.{u} (prod.{u u} α α)
                 (λ (p : prod.{u u} α α),
                    @eq.{u+1} α (@prod.fst.{u u} α α p) a →
                    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p)
                      (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))))) →
  @Exists.{(max (u+1) 1)} (set.{u} α)
    (λ (t : set.{u} α),
       and (@is_open.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) t)
         (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t)
            (@eq.{u+1} (filter.{u} α)
               (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α)
                  (@nhds.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) a)
                  (@filter.principal.{u} α t))
               (@lattice.has_bot.bot.{u} (filter.{u} α)
                  (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
                     (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                        (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                           (@filter.lattice.complete_lattice.{u} α)))))))),
d : set.{u} (prod.{u u} α α),
hd :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    d
    (@uniformity.{u} α _inst_1),
h :
  @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α)) (@comp_rel.{u} α d d)
    (@set_of.{u} (prod.{u u} α α)
       (λ (p : prod.{u u} α α),
          @eq.{u+1} α (@prod.fst.{u u} α α p) a →
          @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p)
            (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))),
e : set.{u} α :=
  @set_of.{u} α
    (λ (y : α),
       @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
         (@prod.mk.{u u} α α a y)
         d),
hae :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
    (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e)
⊢ @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α))
    (@set.Inter.{u u+1} (prod.{u u} α α) (set.{u} (prod.{u u} α α))
       (λ (d : set.{u} (prod.{u u} α α)),
          @set.Inter.{u 0} (prod.{u u} α α)
            (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
               (@filter.has_mem.{u} (prod.{u u} α α))
               d
               (@uniformity.{u} α _inst_1))
            (λ
             (H :
               @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
                 (@filter.has_mem.{u} (prod.{u u} α α))
                 d
                 (@uniformity.{u} α _inst_1)), @comp_rel.{u} α d (@comp_rel.{u} α (@set.prod.{u u} α α e e) d))))
    (@comp_rel.{u} α d (@comp_rel.{u} α (@set.prod.{u u} α α e e) d))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : uniform_space.{u} α,
_inst_4 : @separated.{u} α _inst_1,
s : set.{u} α,
a : α,
hs : @is_closed.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) s,
ha : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s),
this :
  @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α)
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@nhds.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) a),
this :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (p : prod.{u u} α α),
          @eq.{u+1} α (@prod.fst.{u u} α α p) a →
          @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p)
            (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)))
    (@uniformity.{u} α _inst_1),
_let_match :
  @Exists.{u+1} (set.{u} (prod.{u u} α α))
    (λ (t : set.{u} (prod.{u u} α α)),
       @Exists.{0}
         (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
            (@filter.has_mem.{u} (prod.{u u} α α))
            t
            (@uniformity.{u} α _inst_1))
         (λ
          (H :
            @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
              (@filter.has_mem.{u} (prod.{u u} α α))
              t
              (@uniformity.{u} α _inst_1)),
            @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α))
              (@comp_rel.{u} α t t)
              (@set_of.{u} (prod.{u u} α α)
                 (λ (p : prod.{u u} α α),
                    @eq.{u+1} α (@prod.fst.{u u} α α p) a →
                    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p)
                      (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))))) →
  @Exists.{(max (u+1) 1)} (set.{u} α)
    (λ (t : set.{u} α),
       and (@is_open.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) t)
         (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t)
            (@eq.{u+1} (filter.{u} α)
               (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α)
                  (@nhds.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) a)
                  (@filter.principal.{u} α t))
               (@lattice.has_bot.bot.{u} (filter.{u} α)
                  (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
                     (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                        (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                           (@filter.lattice.complete_lattice.{u} α)))))))),
d : set.{u} (prod.{u u} α α),
hd :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    d
    (@uniformity.{u} α _inst_1),
h :
  @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α)) (@comp_rel.{u} α d d)
    (@set_of.{u} (prod.{u u} α α)
       (λ (p : prod.{u u} α α),
          @eq.{u+1} α (@prod.fst.{u u} α α p) a →
          @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p)
            (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))),
e : set.{u} α :=
  @set_of.{u} α
    (λ (y : α),
       @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
         (@prod.mk.{u u} α α a y)
         d),
hae :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
    (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e)
⊢ @has_le.le.{u} (set.{u} (prod.{u u} α α))
    (@preorder.to_has_le.{u} (set.{u} (prod.{u u} α α))
       (@partial_order.to_preorder.{u} (set.{u} (prod.{u u} α α))
          (@lattice.order_bot.to_partial_order.{u} (set.{u} (prod.{u u} α α))
             (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} (prod.{u u} α α))
                (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} (prod.{u u} α α))
                   (@set.lattice_set.{u} (prod.{u u} α α)))))))
    (@lattice.infi.{u u+1} (set.{u} (prod.{u u} α α)) (set.{u} (prod.{u u} α α))
       (@lattice.complete_lattice.to_has_Inf.{u} (set.{u} (prod.{u u} α α)) (@set.lattice_set.{u} (prod.{u u} α α)))
       (λ (d&#x27; : set.{u} (prod.{u u} α α)),
          @lattice.infi.{u 0} (set.{u} (prod.{u u} α α))
            (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
               (@filter.has_mem.{u} (prod.{u u} α α))
               d&#x27;
               (@uniformity.{u} α _inst_1))
            (@lattice.complete_lattice.to_has_Inf.{u} (set.{u} (prod.{u u} α α))
               (@set.lattice_set.{u} (prod.{u u} α α)))
            (λ
             (H :
               @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
                 (@filter.has_mem.{u} (prod.{u u} α α))
                 d&#x27;
                 (@uniformity.{u} α _inst_1)), @comp_rel.{u} α d&#x27; (@comp_rel.{u} α (@set.prod.{u u} α α e e) d&#x27;))))
    (@comp_rel.{u} α d (@comp_rel.{u} α (@set.prod.{u u} α α e e) d))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86        exact (infi_le_of_le d $ infi_le_of_le hd $ le_refl _)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='lattice.infi_le_of_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='le_refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 297, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {ι : Type u} [_inst_1 : lattice.complete_lattice.{u} α] {s : ι → α} {a : α} (i : ι), @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.order_bot.to_partial_order.{u} α (@lattice.bounded_lattice.to_order_bot.{u} α (@lattice.complete_lattice.to_bounded_lattice.{u} α _inst_1))))) (s i) a → @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.order_bot.to_partial_order.{u} α (@lattice.bounded_lattice.to_order_bot.{u} α (@lattice.complete_lattice.to_bounded_lattice.{u} α _inst_1))))) (@lattice.infi.{u (max (u+1) 1)} α ι (@lattice.complete_lattice.to_has_Inf.{u} α _inst_1) s) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) d (@uniformity.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] (a : α), @has_le.le.{u} α (@preorder.to_has_le.{u} α _inst_1) a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : uniform_space.{u} α,
_inst_4 : @separated.{u} α _inst_1,
s : set.{u} α,
a : α,
hs : @is_closed.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) s,
ha : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s),
this :
  @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α)
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@nhds.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) a),
this :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (p : prod.{u u} α α),
          @eq.{u+1} α (@prod.fst.{u u} α α p) a →
          @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p)
            (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)))
    (@uniformity.{u} α _inst_1),
_let_match :
  @Exists.{u+1} (set.{u} (prod.{u u} α α))
    (λ (t : set.{u} (prod.{u u} α α)),
       @Exists.{0}
         (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
            (@filter.has_mem.{u} (prod.{u u} α α))
            t
            (@uniformity.{u} α _inst_1))
         (λ
          (H :
            @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
              (@filter.has_mem.{u} (prod.{u u} α α))
              t
              (@uniformity.{u} α _inst_1)),
            @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α))
              (@comp_rel.{u} α t t)
              (@set_of.{u} (prod.{u u} α α)
                 (λ (p : prod.{u u} α α),
                    @eq.{u+1} α (@prod.fst.{u u} α α p) a →
                    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p)
                      (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))))) →
  @Exists.{(max (u+1) 1)} (set.{u} α)
    (λ (t : set.{u} α),
       and (@is_open.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) t)
         (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t)
            (@eq.{u+1} (filter.{u} α)
               (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α)
                  (@nhds.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) a)
                  (@filter.principal.{u} α t))
               (@lattice.has_bot.bot.{u} (filter.{u} α)
                  (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
                     (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                        (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                           (@filter.lattice.complete_lattice.{u} α)))))))),
d : set.{u} (prod.{u u} α α),
hd :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    d
    (@uniformity.{u} α _inst_1),
h :
  @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α)) (@comp_rel.{u} α d d)
    (@set_of.{u} (prod.{u u} α α)
       (λ (p : prod.{u u} α α),
          @eq.{u+1} α (@prod.fst.{u u} α α p) a →
          @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p)
            (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))),
e : set.{u} α :=
  @set_of.{u} α
    (λ (y : α),
       @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
         (@prod.mk.{u u} α α a y)
         d),
hae :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
    (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e)
⊢ @has_le.le.{u} (set.{u} (prod.{u u} α α))
    (@preorder.to_has_le.{u} (set.{u} (prod.{u u} α α))
       (@partial_order.to_preorder.{u} (set.{u} (prod.{u u} α α))
          (@lattice.order_bot.to_partial_order.{u} (set.{u} (prod.{u u} α α))
             (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} (prod.{u u} α α))
                (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} (prod.{u u} α α))
                   (@set.lattice_set.{u} (prod.{u u} α α)))))))
    (@lattice.infi.{u u+1} (set.{u} (prod.{u u} α α)) (set.{u} (prod.{u u} α α))
       (@lattice.complete_lattice.to_has_Inf.{u} (set.{u} (prod.{u u} α α)) (@set.lattice_set.{u} (prod.{u u} α α)))
       (λ (d&#x27; : set.{u} (prod.{u u} α α)),
          @lattice.infi.{u 0} (set.{u} (prod.{u u} α α))
            (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
               (@filter.has_mem.{u} (prod.{u u} α α))
               d&#x27;
               (@uniformity.{u} α _inst_1))
            (@lattice.complete_lattice.to_has_Inf.{u} (set.{u} (prod.{u u} α α))
               (@set.lattice_set.{u} (prod.{u u} α α)))
            (λ
             (H :
               @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
                 (@filter.has_mem.{u} (prod.{u u} α α))
                 d&#x27;
                 (@uniformity.{u} α _inst_1)), @comp_rel.{u} α d&#x27; (@comp_rel.{u} α (@set.prod.{u u} α α e e) d&#x27;))))
    (@comp_rel.{u} α d (@comp_rel.{u} α (@set.prod.{u u} α α e e) d))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87      end,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : uniform_space.{u} α,
_inst_4 : @separated.{u} α _inst_1,
s : set.{u} α,
a : α,
hs : @is_closed.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) s,
ha : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s),
this :
  @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α)
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@nhds.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) a),
this :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (p : prod.{u u} α α),
          @eq.{u+1} α (@prod.fst.{u u} α α p) a →
          @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p)
            (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)))
    (@uniformity.{u} α _inst_1),
_let_match :
  @Exists.{u+1} (set.{u} (prod.{u u} α α))
    (λ (t : set.{u} (prod.{u u} α α)),
       @Exists.{0}
         (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
            (@filter.has_mem.{u} (prod.{u u} α α))
            t
            (@uniformity.{u} α _inst_1))
         (λ
          (H :
            @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
              (@filter.has_mem.{u} (prod.{u u} α α))
              t
              (@uniformity.{u} α _inst_1)),
            @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α))
              (@comp_rel.{u} α t t)
              (@set_of.{u} (prod.{u u} α α)
                 (λ (p : prod.{u u} α α),
                    @eq.{u+1} α (@prod.fst.{u u} α α p) a →
                    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p)
                      (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))))) →
  @Exists.{(max (u+1) 1)} (set.{u} α)
    (λ (t : set.{u} α),
       and (@is_open.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) t)
         (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t)
            (@eq.{u+1} (filter.{u} α)
               (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α)
                  (@nhds.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) a)
                  (@filter.principal.{u} α t))
               (@lattice.has_bot.bot.{u} (filter.{u} α)
                  (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
                     (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                        (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                           (@filter.lattice.complete_lattice.{u} α)))))))),
d : set.{u} (prod.{u u} α α),
hd :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    d
    (@uniformity.{u} α _inst_1),
h :
  @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α)) (@comp_rel.{u} α d d)
    (@set_of.{u} (prod.{u u} α α)
       (λ (p : prod.{u u} α α),
          @eq.{u+1} α (@prod.fst.{u u} α α p) a →
          @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p)
            (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))),
e : set.{u} α :=
  @set_of.{u} α
    (λ (y : α),
       @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
         (@prod.mk.{u u} α α a y)
         d),
hae :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
    (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e)
⊢ @has_le.le.{u} (set.{u} (prod.{u u} α α))
    (@preorder.to_has_le.{u} (set.{u} (prod.{u u} α α))
       (@partial_order.to_preorder.{u} (set.{u} (prod.{u u} α α))
          (@lattice.order_bot.to_partial_order.{u} (set.{u} (prod.{u u} α α))
             (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} (prod.{u u} α α))
                (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} (prod.{u u} α α))
                   (@set.lattice_set.{u} (prod.{u u} α α)))))))
    (@lattice.infi.{u u+1} (set.{u} (prod.{u u} α α)) (set.{u} (prod.{u u} α α))
       (@lattice.complete_lattice.to_has_Inf.{u} (set.{u} (prod.{u u} α α)) (@set.lattice_set.{u} (prod.{u u} α α)))
       (λ (d&#x27; : set.{u} (prod.{u u} α α)),
          @lattice.infi.{u 0} (set.{u} (prod.{u u} α α))
            (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
               (@filter.has_mem.{u} (prod.{u u} α α))
               d&#x27;
               (@uniformity.{u} α _inst_1))
            (@lattice.complete_lattice.to_has_Inf.{u} (set.{u} (prod.{u u} α α))
               (@set.lattice_set.{u} (prod.{u u} α α)))
            (λ
             (H :
               @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
                 (@filter.has_mem.{u} (prod.{u u} α α))
                 d&#x27;
                 (@uniformity.{u} α _inst_1)), @comp_rel.{u} α d&#x27; (@comp_rel.{u} α (@set.prod.{u u} α α e e) d&#x27;))))
    (@comp_rel.{u} α d (@comp_rel.{u} α (@set.prod.{u u} α α e e) d))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88      have e_subset : closure e ⊆ -s,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 245, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The closure of `s` is the smallest closed set containing `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89        from assume a&#x27; ha&#x27;,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='a&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ha&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a&#x27; (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90          let ⟨x, (hx : (a, x) ∈ d), y, ⟨hx₁, hx₂⟩, (hy : (y, _) ∈ d)⟩ := @this ⟨a, a&#x27;⟩ ⟨hae, ha&#x27;⟩ in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hx₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hae'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ha&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α a a&#x27;) (@comp_rel.{u} α d (@comp_rel.{u} α (@set.prod.{u u} α α e e) d)) → @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a&#x27; (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α (@prod.mk.{u u} α α (@prod.fst.{u u} α α (@prod.mk.{u u} α α x (@prod.snd.{u u} α α (@prod.mk.{u u} α α a a&#x27;)))) y)) e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α y (@prod.snd.{u u} α α (@prod.mk.{u u} α α x (@prod.snd.{u u} α α (@prod.mk.{u u} α α a a&#x27;))))) d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α)) (@set.prod.{u u} α α (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e) (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e)) (@comp_rel.{u} α d (@comp_rel.{u} α (@set.prod.{u u} α α e e) d))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a&#x27; (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91          have (a, a&#x27;) ∈ comp_rel d d, from ⟨y, hx₂, hy⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='comp_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} (prod.{u u} α α) → set.{u} (prod.{u u} α α) → set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The composition of relations'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92          h this rfl,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α a a&#x27;) (@comp_rel.{u} α d d)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Sort u} {a : α}, @eq.{u} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93      have closure e ∈ 𝓝 a, from (𝓝 a).sets_of_superset (mem_nhds_left a hd) subset_closure,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.sets_of_superset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='mem_nhds_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='subset_closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 245, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 284, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 250, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} (c : filter.{u} α) {x y : set.{u} α}, @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x (@filter.sets.{u} α c) → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) x y → @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) y (@filter.sets.{u} α c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : uniform_space.{u_1} α] (x : α) {s : set.{u_1} (prod.{u_1 u_1} α α)}, @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) s (@uniformity.{u_1} α _inst_1) → @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) (@set_of.{u_1} α (λ (y : α), @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α x y) s)) (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {s : set.{u} α}, @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s (@closure.{u} α _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The closure of `s` is the smallest closed set containing `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94      have 𝓝 a ⊓ principal (-closure e) = ⊥,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_inf.inf'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.principal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/lattice.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 245, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : lattice.has_inf.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [c : lattice.has_bot.{u} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The principal filter of `s` is the collection of all supersets of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The closure of `s` is the smallest closed set containing `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95        from (@inf_eq_bot_iff_le_compl _ _ _ (principal (- closure e)) (principal (closure e))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='lattice.inf_eq_bot_iff_le_compl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='filter.principal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='filter.principal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 280, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 245, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 245, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : lattice.bounded_distrib_lattice.{u} α] {a b c : α}, @eq.{u+1} α (@lattice.has_sup.sup.{u} α (@lattice.semilattice_sup.to_has_sup.{u} α (@lattice.semilattice_sup_bot.to_semilattice_sup.{u} α (@lattice.semilattice_sup_bot_of_bounded_lattice.{u} α (@lattice.bounded_distrib_lattice.to_bounded_lattice.{u} α _inst_1)))) b c) (@lattice.has_top.top.{u} α (@lattice.order_top.to_has_top.{u} α (@lattice.bounded_lattice.to_order_top.{u} α (@lattice.bounded_distrib_lattice.to_bounded_lattice.{u} α _inst_1)))) → @eq.{u+1} α (@lattice.has_inf.inf.{u} α (@lattice.semilattice_inf.to_has_inf.{u} α (@lattice.semilattice_inf_bot.to_semilattice_inf.{u} α (@lattice.semilattice_inf_bot_of_bounded_lattice.{u} α (@lattice.bounded_distrib_lattice.to_bounded_lattice.{u} α _inst_1)))) b c) (@lattice.has_bot.bot.{u} α (@lattice.order_bot.to_has_bot.{u} α (@lattice.bounded_lattice.to_order_bot.{u} α (@lattice.bounded_distrib_lattice.to_bounded_lattice.{u} α _inst_1)))) → iff (@eq.{u+1} α (@lattice.has_inf.inf.{u} α (@lattice.semilattice_inf.to_has_inf.{u} α (@lattice.semilattice_inf_bot.to_semilattice_inf.{u} α (@lattice.semilattice_inf_bot_of_bounded_lattice.{u} α (@lattice.bounded_distrib_lattice.to_bounded_lattice.{u} α _inst_1)))) a b) (@lattice.has_bot.bot.{u} α (@lattice.order_bot.to_has_bot.{u} α (@lattice.bounded_lattice.to_order_bot.{u} α (@lattice.bounded_distrib_lattice.to_bounded_lattice.{u} α _inst_1))))) (@has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.order_bot.to_partial_order.{u} α (@lattice.bounded_lattice.to_order_bot.{u} α (@lattice.bounded_distrib_lattice.to_bounded_lattice.{u} α _inst_1))))) a c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u}, set.{u} α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u}, set.{u} α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='orange'><a title='The principal filter of `s` is the collection of all supersets of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The closure of `s` is the smallest closed set containing `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The principal filter of `s` is the collection of all supersets of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The closure of `s` is the smallest closed set containing `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96          (by simp [principal_univ, union_comm]) (by simp)).mpr (by simp [this]),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='filter.principal_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.union_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 714, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 289, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1}, @eq.{?l_1+1} (filter.{?l_1} α) (@filter.principal.{?l_1} α (@set.univ.{?l_1} α)) (@lattice.has_top.top.{?l_1} (filter.{?l_1} α) (@filter.lattice.has_top.{?l_1} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} (a b : set.{?l_1} α), @eq.{?l_1+1} (set.{?l_1} α) (@has_union.union.{?l_1} (set.{?l_1} α) (@set.has_union.{?l_1} α) a b) (@has_union.union.{?l_1} (set.{?l_1} α) (@set.has_union.{?l_1} α) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e) (@nhds.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='lime'><a title='α : Type u,
_inst_1 : uniform_space.{u} α,
_inst_4 : @separated.{u} α _inst_1,
s : set.{u} α,
a : α,
hs : @is_closed.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) s,
ha : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s),
this :
  @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α)
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@nhds.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) a),
this :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (p : prod.{u u} α α),
          @eq.{u+1} α (@prod.fst.{u u} α α p) a →
          @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p)
            (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)))
    (@uniformity.{u} α _inst_1),
_let_match :
  @Exists.{u+1} (set.{u} (prod.{u u} α α))
    (λ (t : set.{u} (prod.{u u} α α)),
       @Exists.{0}
         (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
            (@filter.has_mem.{u} (prod.{u u} α α))
            t
            (@uniformity.{u} α _inst_1))
         (λ
          (H :
            @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
              (@filter.has_mem.{u} (prod.{u u} α α))
              t
              (@uniformity.{u} α _inst_1)),
            @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α))
              (@comp_rel.{u} α t t)
              (@set_of.{u} (prod.{u u} α α)
                 (λ (p : prod.{u u} α α),
                    @eq.{u+1} α (@prod.fst.{u u} α α p) a →
                    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p)
                      (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))))) →
  @Exists.{(max (u+1) 1)} (set.{u} α)
    (λ (t : set.{u} α),
       and (@is_open.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) t)
         (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t)
            (@eq.{u+1} (filter.{u} α)
               (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α)
                  (@nhds.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) a)
                  (@filter.principal.{u} α t))
               (@lattice.has_bot.bot.{u} (filter.{u} α)
                  (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
                     (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                        (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                           (@filter.lattice.complete_lattice.{u} α)))))))),
d : set.{u} (prod.{u u} α α),
hd :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    d
    (@uniformity.{u} α _inst_1),
h :
  @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α)) (@comp_rel.{u} α d d)
    (@set_of.{u} (prod.{u u} α α)
       (λ (p : prod.{u u} α α),
          @eq.{u+1} α (@prod.fst.{u u} α α p) a →
          @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p)
            (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))),
e : set.{u} α :=
  @set_of.{u} α
    (λ (y : α),
       @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
         (@prod.mk.{u u} α α a y)
         d),
hae :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
    (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e),
this :
  @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α))
    (@set.prod.{u u} α α (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e)
       (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e))
    (@comp_rel.{u} α d (@comp_rel.{u} α (@set.prod.{u u} α α e e) d)),
e_subset :
  @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e)
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s),
this :
  @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α)
    (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e)
    (@nhds.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) a)
⊢ @eq.{u+1} (filter.{u} α)
    (@lattice.has_sup.sup.{u} (filter.{u} α)
       (@lattice.semilattice_sup.to_has_sup.{u} (filter.{u} α)
          (@lattice.semilattice_sup_bot.to_semilattice_sup.{u} (filter.{u} α)
             (@lattice.semilattice_sup_bot_of_bounded_lattice.{u} (filter.{u} α)
                (@lattice.bounded_distrib_lattice.to_bounded_lattice.{u} (filter.{u} α)
                   (@filter.lattice.bounded_distrib_lattice.{u} α)))))
       (@filter.principal.{u} α
          (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
             (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e)))
       (@filter.principal.{u} α (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e)))
    (@lattice.has_top.top.{u} (filter.{u} α)
       (@lattice.order_top.to_has_top.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_top.{u} (filter.{u} α)
             (@lattice.bounded_distrib_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.bounded_distrib_lattice.{u} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='lime'><a title='α : Type u,
_inst_1 : uniform_space.{u} α,
_inst_4 : @separated.{u} α _inst_1,
s : set.{u} α,
a : α,
hs : @is_closed.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) s,
ha : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s),
this :
  @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α)
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@nhds.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) a),
this :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (p : prod.{u u} α α),
          @eq.{u+1} α (@prod.fst.{u u} α α p) a →
          @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p)
            (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)))
    (@uniformity.{u} α _inst_1),
_let_match :
  @Exists.{u+1} (set.{u} (prod.{u u} α α))
    (λ (t : set.{u} (prod.{u u} α α)),
       @Exists.{0}
         (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
            (@filter.has_mem.{u} (prod.{u u} α α))
            t
            (@uniformity.{u} α _inst_1))
         (λ
          (H :
            @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
              (@filter.has_mem.{u} (prod.{u u} α α))
              t
              (@uniformity.{u} α _inst_1)),
            @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α))
              (@comp_rel.{u} α t t)
              (@set_of.{u} (prod.{u u} α α)
                 (λ (p : prod.{u u} α α),
                    @eq.{u+1} α (@prod.fst.{u u} α α p) a →
                    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p)
                      (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))))) →
  @Exists.{(max (u+1) 1)} (set.{u} α)
    (λ (t : set.{u} α),
       and (@is_open.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) t)
         (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t)
            (@eq.{u+1} (filter.{u} α)
               (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α)
                  (@nhds.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) a)
                  (@filter.principal.{u} α t))
               (@lattice.has_bot.bot.{u} (filter.{u} α)
                  (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
                     (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                        (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                           (@filter.lattice.complete_lattice.{u} α)))))))),
d : set.{u} (prod.{u u} α α),
hd :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    d
    (@uniformity.{u} α _inst_1),
h :
  @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α)) (@comp_rel.{u} α d d)
    (@set_of.{u} (prod.{u u} α α)
       (λ (p : prod.{u u} α α),
          @eq.{u+1} α (@prod.fst.{u u} α α p) a →
          @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p)
            (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))),
e : set.{u} α :=
  @set_of.{u} α
    (λ (y : α),
       @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
         (@prod.mk.{u u} α α a y)
         d),
hae :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
    (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e),
this :
  @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α))
    (@set.prod.{u u} α α (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e)
       (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e))
    (@comp_rel.{u} α d (@comp_rel.{u} α (@set.prod.{u u} α α e e) d)),
e_subset :
  @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e)
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s),
this :
  @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α)
    (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e)
    (@nhds.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) a)
⊢ @eq.{u+1} (filter.{u} α)
    (@lattice.has_inf.inf.{u} (filter.{u} α)
       (@lattice.semilattice_inf.to_has_inf.{u} (filter.{u} α)
          (@lattice.semilattice_inf_bot.to_semilattice_inf.{u} (filter.{u} α)
             (@lattice.semilattice_inf_bot_of_bounded_lattice.{u} (filter.{u} α)
                (@lattice.bounded_distrib_lattice.to_bounded_lattice.{u} (filter.{u} α)
                   (@filter.lattice.bounded_distrib_lattice.{u} α)))))
       (@filter.principal.{u} α
          (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
             (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e)))
       (@filter.principal.{u} α (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e)))
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.bounded_distrib_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.bounded_distrib_lattice.{u} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='lime'><a title='α : Type u,
_inst_1 : uniform_space.{u} α,
_inst_4 : @separated.{u} α _inst_1,
s : set.{u} α,
a : α,
hs : @is_closed.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) s,
ha : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s),
this :
  @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α)
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@nhds.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) a),
this :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (p : prod.{u u} α α),
          @eq.{u+1} α (@prod.fst.{u u} α α p) a →
          @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p)
            (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)))
    (@uniformity.{u} α _inst_1),
_let_match :
  @Exists.{u+1} (set.{u} (prod.{u u} α α))
    (λ (t : set.{u} (prod.{u u} α α)),
       @Exists.{0}
         (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
            (@filter.has_mem.{u} (prod.{u u} α α))
            t
            (@uniformity.{u} α _inst_1))
         (λ
          (H :
            @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
              (@filter.has_mem.{u} (prod.{u u} α α))
              t
              (@uniformity.{u} α _inst_1)),
            @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α))
              (@comp_rel.{u} α t t)
              (@set_of.{u} (prod.{u u} α α)
                 (λ (p : prod.{u u} α α),
                    @eq.{u+1} α (@prod.fst.{u u} α α p) a →
                    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p)
                      (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))))) →
  @Exists.{(max (u+1) 1)} (set.{u} α)
    (λ (t : set.{u} α),
       and (@is_open.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) t)
         (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t)
            (@eq.{u+1} (filter.{u} α)
               (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α)
                  (@nhds.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) a)
                  (@filter.principal.{u} α t))
               (@lattice.has_bot.bot.{u} (filter.{u} α)
                  (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
                     (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                        (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                           (@filter.lattice.complete_lattice.{u} α)))))))),
d : set.{u} (prod.{u u} α α),
hd :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    d
    (@uniformity.{u} α _inst_1),
h :
  @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α)) (@comp_rel.{u} α d d)
    (@set_of.{u} (prod.{u u} α α)
       (λ (p : prod.{u u} α α),
          @eq.{u+1} α (@prod.fst.{u u} α α p) a →
          @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p)
            (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))),
e : set.{u} α :=
  @set_of.{u} α
    (λ (y : α),
       @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
         (@prod.mk.{u u} α α a y)
         d),
hae :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
    (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e),
this :
  @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α))
    (@set.prod.{u u} α α (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e)
       (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e))
    (@comp_rel.{u} α d (@comp_rel.{u} α (@set.prod.{u u} α α e e) d)),
e_subset :
  @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e)
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s),
this :
  @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α)
    (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e)
    (@nhds.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) a)
⊢ @has_le.le.{u} (filter.{u} α)
    (@preorder.to_has_le.{u} (filter.{u} α)
       (@partial_order.to_preorder.{u} (filter.{u} α)
          (@lattice.order_bot.to_partial_order.{u} (filter.{u} α)
             (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                (@lattice.bounded_distrib_lattice.to_bounded_lattice.{u} (filter.{u} α)
                   (@filter.lattice.bounded_distrib_lattice.{u} α))))))
    (@nhds.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) a)
    (@filter.principal.{u} α (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97      ⟨- closure e, is_closed_closure, assume x h₁ h₂, @e_subset x h₂ h₁, this⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_closed_closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='e_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 245, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {s : set.{u} α}, @is_closed.{u} α _inst_1 (@closure.{u} α _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@eq.{u+1} (filter.{u} α) (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) a) (@filter.principal.{u} α (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) (@closure.{u} α (@uniform_space.to_topological_space.{u} α _inst_1) e)))) (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The closure of `s` is the smallest closed set containing `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98    ..separated_t2 }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='separated_t2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 55, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : uniform_space.{u} α] [s : @separated.{u} α _inst_1], @t2_space.{u} α (@uniform_space.to_topological_space.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100  /- separation space -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101  namespace uniform_space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102  def separation_setoid (α : Type u) [uniform_space α] : setoid α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='uniform_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='setoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/setoid.lean&#x27;, &#x27;line&#x27;: 10, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (@quotient.{u+1} α (uniform_space.separation_setoid.{u} α u)) (set.{u} (@quotient.{u+1} α (uniform_space.separation_setoid.{u} α u))) (@set.has_mem.{u} (@quotient.{u+1} α (uniform_space.separation_setoid.{u} α u))) (@quotient.mk.{u+1} α (uniform_space.separation_setoid.{u} α u) a) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Sort u → Sort (max 1 u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='A uniform space is a generalization of the &quot;uniform&quot; topological aspects of a
 metric space. It consists of a filter on `α × α` called the &quot;uniformity&quot;, which
 satisfies properties analogous to the reflexivity, symmetry, and triangle properties
 of a metric.

 A metric space has a natural uniformity, and a uniform space has a natural topology.
 A topological group also has a natural uniformity, even when it is not metrizable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103  ⟨λx y, (x, y) ∈ separation_rel α, separated_equiv⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='separation_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 26, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 29, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [u : uniform_space.{u} α], set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ (x : α), @has_mem.mem.{u u} (@quotient.{u+1} α (uniform_space.separation_setoid.{u} α u)) (set.{u} (@quotient.{u+1} α (uniform_space.separation_setoid.{u} α u))) (@set.has_mem.{u} (@quotient.{u+1} α (uniform_space.separation_setoid.{u} α u))) (@quotient.mk.{u+1} α (uniform_space.separation_setoid.{u} α u) x) s → @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (set.{u} (set.{u} (prod.{u u} α α))) (@set.has_mem.{u} (set.{u} (prod.{u u} α α))) (@set_of.{u} (prod.{u u} α α) (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) x → @has_mem.mem.{u u} (@quotient.{u+1} α (uniform_space.separation_setoid.{u} α u)) (set.{u} (@quotient.{u+1} α (uniform_space.separation_setoid.{u} α u))) (@set.has_mem.{u} (@quotient.{u+1} α (uniform_space.separation_setoid.{u} α u))) (@quotient.mk.{u+1} α (uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p)) s)) (@filter.sets.{u} (prod.{u u} α α) (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The separation relation is the intersection of all entourages.
 Two points which are related by the separation relation are &quot;indistinguishable&quot;
 according to the uniform structure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105  local attribute [instance] separation_setoid</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='uniform_space.separation_setoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;line&#x27;: 102, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Π (α : Type u) [_inst_4 : uniform_space.{u} α], setoid.{u+1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107  instance separation_setoid.uniform_space {α : Type u} [u : uniform_space α] :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                           </code><font color='blue'><a title='uniform_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                           </code><font color='orange'><a title='A uniform space is a generalization of the &quot;uniform&quot; topological aspects of a
 metric space. It consists of a filter on `α × α` called the &quot;uniformity&quot;, which
 satisfies properties analogous to the reflexivity, symmetry, and triangle properties
 of a metric.

 A metric space has a natural uniformity, and a uniform space has a natural topology.
 A topological group also has a natural uniformity, even when it is not metrizable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108    uniform_space (quotient (separation_setoid α)) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='quotient'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_space.separation_setoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 88, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 102, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u}, setoid.{u} α → Sort u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u) [_inst_4 : uniform_space.{u} α], setoid.{u+1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A uniform space is a generalization of the &quot;uniform&quot; topological aspects of a
 metric space. It consists of a filter on `α × α` called the &quot;uniformity&quot;, which
 satisfies properties analogous to the reflexivity, symmetry, and triangle properties
 of a metric.

 A metric space has a natural uniformity, and a uniform space has a natural topology.
 A topological group also has a natural uniformity, even when it is not metrizable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109  { to_topological_space := u.to_topological_space.coinduced (λx, ⟦x⟧),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_space.to_topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_space.coinduced'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 265, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='uniform_space.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type u) [c : uniform_space.{u} α], topological_space.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, (α → β) → topological_space.{u} α → topological_space.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='orange'><a title='Given `f : α → β` and a topology on `α`, the coinduced topology on `β` is defined
 such that `s:set β` is open if the preimage of `s` is open. This is the finest topology that
 makes `f` continuous.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110    uniformity := map (λp:(α×α), (⟦p.1⟧, ⟦p.2⟧)) u.uniformity,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='filter.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_space.core.uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 764, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → filter.{u} α → filter.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='prod.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='prod.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='uniform_space.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, uniform_space.core.{u} α → filter.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The forward map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111    refl := le_trans (by simp [quotient.exists_rep]) (filter.map_mono refl_le_uniformity),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='le_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='quotient.exists_rep'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='filter.map_mono'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='refl_le_uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 931, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 164, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] {a b c : α}, @has_le.le.{u} α (@preorder.to_has_le.{u} α _inst_1) a b → @has_le.le.{u} α (@preorder.to_has_le.{u} α _inst_1) b c → @has_le.le.{u} α (@preorder.to_has_le.{u} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Sort ?l_1} [s : setoid.{?l_1} α] (q : @quotient.{?l_1} α s), @Exists.{?l_1} α (λ (a : α), @eq.{?l_1} (@quotient.{?l_1} α s) (@quotient.mk.{?l_1} α s a) q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} {β : Type v} {m : α → β}, @monotone.{u v} (filter.{u} α) (filter.{v} β) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)) (@partial_order.to_preorder.{v} (filter.{v} β) (@filter.partial_order.{v} β)) (@filter.map.{u v} α β m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : uniform_space.{u_1} α], @has_le.le.{u_1} (filter.{u_1} (prod.{u_1 u_1} α α)) (@preorder.to_has_le.{u_1} (filter.{u_1} (prod.{u_1 u_1} α α)) (@partial_order.to_preorder.{u_1} (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.partial_order.{u_1} (prod.{u_1 u_1} α α)))) (@filter.principal.{u_1} (prod.{u_1 u_1} α α) (@id_rel.{u_1} α)) (@uniformity.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='lime'><a title='α : Type u,
u : uniform_space.{u} α
⊢ @has_le.le.{u}
    (filter.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@preorder.to_has_le.{u}
       (filter.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (@partial_order.to_preorder.{u}
          (filter.{u}
             (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
          (@filter.partial_order.{u}
             (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))))
    (@filter.principal.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
       (@id_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@filter.map.{u u} (prod.{u u} α α)
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
       (λ (p : prod.{u u} α α),
          @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
            (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p)))
       (@filter.principal.{u} (prod.{u u} α α) (@id_rel.{u} α)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112    symm := tendsto_map&#x27; $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='filter.tendsto_map&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1411, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='∀ {α : Type u} {β : Type v} {γ : Type w} {f : β → γ} {g : α → β} {x : filter.{u} α} {y : filter.{w} γ}, @filter.tendsto.{u w} α γ (@function.comp.{u+1 v+1 w+1} α β γ f g) x y → @filter.tendsto.{v w} β γ f (@filter.map.{u v} α β g x) y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113      by simp [prod.swap, (∘)]; exact tendsto_map.comp tendsto_swap_uniformity,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='prod.swap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='filter.tendsto_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='tendsto_swap_uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/prod.lean&#x27;, &#x27;line&#x27;: 49, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1409, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 177, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2}, prod.{?l_1 ?l_2} α β → prod.{?l_2 ?l_1} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Sort ?l_1} {β : Sort ?l_2} {φ : Sort ?l_3}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} {f : α → β} {x : filter.{u} α}, @filter.tendsto.{u u} α β f x (@filter.map.{u u} α β f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : uniform_space.{u} α], @filter.tendsto.{u u} (prod.{u u} α α) (prod.{u u} α α) (@prod.swap.{u u} α α) (@uniformity.{u} α _inst_1) (@uniformity.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Swap the factors of a product. `swap (a, b) = (b, a)`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='lime'><a title='α : Type u,
u : uniform_space.{u} α
⊢ @filter.tendsto.{u u} (prod.{u u} α α)
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (@function.comp.{u+1 u+1 u+1} (prod.{u u} α α)
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
       (@prod.swap.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
       (λ (p : prod.{u u} α α),
          @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
            (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
    (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u))
    (@filter.map.{u u} (prod.{u u} α α)
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
       (λ (p : prod.{u u} α α),
          @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
            (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p)))
       (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114    comp := calc (map (λ (p : α × α), (⟦p.fst⟧, ⟦p.snd⟧)) u.uniformity).lift&#x27; (λs, comp_rel s s) =</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='filter.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_space.core.uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.lift&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='comp_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 764, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/lift.lean&#x27;, &#x27;line&#x27;: 175, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → filter.{u} α → filter.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='prod.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='prod.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='uniform_space.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, uniform_space.core.{u} α → filter.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u}, filter.{u} α → (set.{u} α → set.{u} β) → filter.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='set.{u} (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, set.{u} (prod.{u u} α α) → set.{u} (prod.{u u} α α) → set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The forward map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='orange'><a title=' Specialize `lift` to functions `set α → set β`. This can be viewed as a generalization of `map`.
This is essentially a push-forward along a function mapping each set to a set.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The composition of relations'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115            u.uniformity.lift&#x27; ((λs, comp_rel s s) ∘ image (λ (p : α × α), (⟦p.fst⟧, ⟦p.snd⟧))) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_space.core.uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='filter.lift&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='comp_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/lift.lean&#x27;, &#x27;line&#x27;: 175, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='uniform_space.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, uniform_space.core.{u} α → filter.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, filter.{u} α → (set.{u} α → set.{u} β) → filter.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='set.{u} (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, set.{u} (prod.{u u} α α) → set.{u} (prod.{u u} α α) → set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β φ : Type u}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → set.{u} α → set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='prod.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='prod.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title=' Specialize `lift` to functions `set α → set β`. This can be viewed as a generalization of `map`.
This is essentially a push-forward along a function mapping each set to a set.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The composition of relations'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116        map_lift&#x27;_eq2 $ monotone_comp_rel monotone_id monotone_id</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='filter.map_lift&#x27;_eq2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='monotone_comp_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='monotone_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='monotone_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/lift.lean&#x27;, &#x27;line&#x27;: 205, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 55, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {f : filter.{u_1} α} {g : set.{u_2} β → set.{u_3} γ} {m : α → β}, @monotone.{u_2 u_3} (set.{u_2} β) (set.{u_3} γ) (@partial_order.to_preorder.{u_2} (set.{u_2} β) (@lattice.order_bot.to_partial_order.{u_2} (set.{u_2} β) (@lattice.bounded_lattice.to_order_bot.{u_2} (set.{u_2} β) (@lattice.complete_lattice.to_bounded_lattice.{u_2} (set.{u_2} β) (@set.lattice_set.{u_2} β))))) (@partial_order.to_preorder.{u_3} (set.{u_3} γ) (@lattice.order_bot.to_partial_order.{u_3} (set.{u_3} γ) (@lattice.bounded_lattice.to_order_bot.{u_3} (set.{u_3} γ) (@lattice.complete_lattice.to_bounded_lattice.{u_3} (set.{u_3} γ) (@set.lattice_set.{u_3} γ))))) g → @eq.{u_3+1} (filter.{u_3} γ) (@filter.lift&#x27;.{u_2 u_3} β γ (@filter.map.{u_1 u_2} α β m f) g) (@filter.lift&#x27;.{u_1 u_3} α γ f (@function.comp.{(max (u_1+1) 1) (max (u_2+1) 1) (max (u_3+1) 1)} (set.{u_1} α) (set.{u_2} β) (set.{u_3} γ) g (@set.image.{u_1 u_2} α β m)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : preorder.{u_2} β] {f g : β → set.{u_1} (prod.{u_1 u_1} α α)}, @monotone.{u_2 u_1} β (set.{u_1} (prod.{u_1 u_1} α α)) _inst_1 (@partial_order.to_preorder.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.lattice_set.{u_1} (prod.{u_1 u_1} α α)))))) f → @monotone.{u_2 u_1} β (set.{u_1} (prod.{u_1 u_1} α α)) _inst_1 (@partial_order.to_preorder.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.lattice_set.{u_1} (prod.{u_1 u_1} α α)))))) g → @monotone.{u_2 u_1} β (set.{u_1} (prod.{u_1 u_1} α α)) _inst_1 (@partial_order.to_preorder.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.lattice_set.{u_1} (prod.{u_1 u_1} α α)))))) (λ (x : β), @comp_rel.{u_1} α (f x) (g x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α], @monotone.{u u} α α _inst_1 _inst_1 (@id.{u+1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α], @monotone.{u u} α α _inst_1 _inst_1 (@id.{u+1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117      ... ≤ u.uniformity.lift&#x27; (image (λ (p : α × α), (⟦p.fst⟧, ⟦p.snd⟧)) ∘ (λs:set (α×α), comp_rel s (comp_rel s s))) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_space.core.uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='filter.lift&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='comp_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='comp_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/lift.lean&#x27;, &#x27;line&#x27;: 175, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='uniform_space.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, uniform_space.core.{u} α → filter.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, filter.{u} α → (set.{u} α → set.{u} β) → filter.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → set.{u} α → set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='prod.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='prod.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β φ : Type u}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, set.{u} (prod.{u u} α α) → set.{u} (prod.{u u} α α) → set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, set.{u} (prod.{u u} α α) → set.{u} (prod.{u u} α α) → set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title=' Specialize `lift` to functions `set α → set β`. This can be viewed as a generalization of `map`.
This is essentially a push-forward along a function mapping each set to a set.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                             </code><font color='orange'><a title='The composition of relations'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The composition of relations'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118        lift&#x27;_mono&#x27; $ assume s hs ⟨a, b⟩ ⟨c, ⟨⟨a₁, a₂⟩, ha, a_eq⟩, ⟨⟨b₁, b₂⟩, hb, b_eq⟩⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='filter.lift&#x27;_mono&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/lift.lean&#x27;, &#x27;line&#x27;: 194, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {f : filter.{u_1} α} {h₁ h₂ : set.{u_1} α → set.{u_2} β}, (∀ (s : set.{u_1} α), @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) s f → @has_subset.subset.{u_2} (set.{u_2} β) (@set.has_subset.{u_2} β) (h₁ s) (h₂ s)) → @has_le.le.{u_2} (filter.{u_2} β) (@preorder.to_has_le.{u_2} (filter.{u_2} β) (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β))) (@filter.lift&#x27;.{u_1 u_2} α β f h₁) (@filter.lift&#x27;.{u_1 u_2} α β f h₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) s (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@has_mem.mem.{u u} (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))) (set.{u} (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))) (@set.has_mem.{u} (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))) (@prod.mk.{u u} . (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) . (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) a b) (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α)) (set.{u} (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))) (set.{u} (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))) (λ (s : set.{u} (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))), @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s) (@set.image.{u u} (prod.{u u} α α) (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))) (λ (p : prod.{u u} α α), @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p)))) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119        begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='lime'><a title='α : Type u,
u : uniform_space.{u} α,
s : set.{u} (prod.{u u} α α),
hs :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    s
    (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u)),
_x :
  prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
    (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)),
_fun_match :
  ∀
  (_a :
    prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
      (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))),
    @has_mem.mem.{u u}
      (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (set.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      (@set.has_mem.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      _a
      (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (λ
          (s :
            set.{u}
              (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
            @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
         (@set.image.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
         s) →
    @has_mem.mem.{u u}
      (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (set.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      (@set.has_mem.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      _a
      (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
         (set.{u} (prod.{u u} α α))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (@set.image.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
         (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
         s),
a b : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u),
_x :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (λ
        (s :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       s),
_fun_match :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (λ
        (s :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       s) →
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
       s),
c : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u),
a₁ a₂ : α,
ha :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α a₁ a₂)
    s,
a_eq :
  @eq.{u+1}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    ((λ (p : prod.{u u} α α),
        @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
          (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p)))
       (@prod.mk.{u u} α α a₁ a₂))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@prod.fst.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             a
             b))
       c),
b₁ b₂ : α,
hb :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α b₁ b₂)
    s,
b_eq :
  @eq.{u+1}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    ((λ (p : prod.{u u} α α),
        @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
          (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p)))
       (@prod.mk.{u u} α α b₁ b₂))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       c
       (@prod.snd.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             a
             b)))
⊢ @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120          simp at a_eq,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
u : uniform_space.{u} α,
s : set.{u} (prod.{u u} α α),
hs :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    s
    (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u)),
_x :
  prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
    (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)),
_fun_match :
  ∀
  (_a :
    prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
      (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))),
    @has_mem.mem.{u u}
      (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (set.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      (@set.has_mem.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      _a
      (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (λ
          (s :
            set.{u}
              (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
            @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
         (@set.image.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
         s) →
    @has_mem.mem.{u u}
      (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (set.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      (@set.has_mem.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      _a
      (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
         (set.{u} (prod.{u u} α α))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (@set.image.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
         (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
         s),
a b : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u),
_x :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (λ
        (s :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       s),
_fun_match :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (λ
        (s :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       s) →
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
       s),
c : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u),
a₁ a₂ : α,
ha :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α a₁ a₂)
    s,
a_eq :
  @eq.{u+1}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    ((λ (p : prod.{u u} α α),
        @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
          (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p)))
       (@prod.mk.{u u} α α a₁ a₂))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@prod.fst.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             a
             b))
       c),
b₁ b₂ : α,
hb :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α b₁ b₂)
    s,
b_eq :
  @eq.{u+1}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    ((λ (p : prod.{u u} α α),
        @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
          (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p)))
       (@prod.mk.{u u} α α b₁ b₂))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       c
       (@prod.snd.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             a
             b)))
⊢ @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
u : uniform_space.{u} α,
s : set.{u} (prod.{u u} α α),
hs :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    s
    (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u)),
_x :
  prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
    (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)),
_fun_match :
  ∀
  (_a :
    prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
      (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))),
    @has_mem.mem.{u u}
      (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (set.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      (@set.has_mem.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      _a
      (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (λ
          (s :
            set.{u}
              (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
            @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
         (@set.image.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
         s) →
    @has_mem.mem.{u u}
      (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (set.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      (@set.has_mem.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      _a
      (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
         (set.{u} (prod.{u u} α α))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (@set.image.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
         (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
         s),
a b : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u),
_x :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (λ
        (s :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       s),
_fun_match :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (λ
        (s :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       s) →
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
       s),
c : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u),
a₁ a₂ : α,
ha :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α a₁ a₂)
    s,
b₁ b₂ : α,
hb :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α b₁ b₂)
    s,
b_eq :
  @eq.{u+1}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    ((λ (p : prod.{u u} α α),
        @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
          (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p)))
       (@prod.mk.{u u} α α b₁ b₂))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       c
       (@prod.snd.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             a
             b))),
a_eq :
  and
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₁)
       a)
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₂)
       c)
⊢ @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121          simp at b_eq,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
u : uniform_space.{u} α,
s : set.{u} (prod.{u u} α α),
hs :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    s
    (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u)),
_x :
  prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
    (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)),
_fun_match :
  ∀
  (_a :
    prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
      (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))),
    @has_mem.mem.{u u}
      (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (set.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      (@set.has_mem.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      _a
      (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (λ
          (s :
            set.{u}
              (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
            @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
         (@set.image.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
         s) →
    @has_mem.mem.{u u}
      (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (set.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      (@set.has_mem.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      _a
      (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
         (set.{u} (prod.{u u} α α))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (@set.image.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
         (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
         s),
a b : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u),
_x :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (λ
        (s :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       s),
_fun_match :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (λ
        (s :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       s) →
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
       s),
c : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u),
a₁ a₂ : α,
ha :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α a₁ a₂)
    s,
b₁ b₂ : α,
hb :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α b₁ b₂)
    s,
b_eq :
  @eq.{u+1}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    ((λ (p : prod.{u u} α α),
        @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
          (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p)))
       (@prod.mk.{u u} α α b₁ b₂))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       c
       (@prod.snd.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             a
             b))),
a_eq :
  and
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₁)
       a)
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₂)
       c)
⊢ @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
u : uniform_space.{u} α,
s : set.{u} (prod.{u u} α α),
hs :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    s
    (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u)),
_x :
  prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
    (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)),
_fun_match :
  ∀
  (_a :
    prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
      (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))),
    @has_mem.mem.{u u}
      (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (set.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      (@set.has_mem.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      _a
      (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (λ
          (s :
            set.{u}
              (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
            @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
         (@set.image.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
         s) →
    @has_mem.mem.{u u}
      (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (set.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      (@set.has_mem.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      _a
      (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
         (set.{u} (prod.{u u} α α))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (@set.image.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
         (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
         s),
a b : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u),
_x :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (λ
        (s :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       s),
_fun_match :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (λ
        (s :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       s) →
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
       s),
c : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u),
a₁ a₂ : α,
ha :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α a₁ a₂)
    s,
b₁ b₂ : α,
hb :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α b₁ b₂)
    s,
a_eq :
  and
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₁)
       a)
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₂)
       c),
b_eq :
  and
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₁)
       c)
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₂)
       b)
⊢ @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122          have h : ⟦a₂⟧ = ⟦b₁⟧, { rw [a_eq.right, b_eq.left] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₂) c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₁) c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
u : uniform_space.{u} α,
s : set.{u} (prod.{u u} α α),
hs :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    s
    (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u)),
_x :
  prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
    (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)),
_fun_match :
  ∀
  (_a :
    prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
      (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))),
    @has_mem.mem.{u u}
      (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (set.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      (@set.has_mem.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      _a
      (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (λ
          (s :
            set.{u}
              (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
            @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
         (@set.image.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
         s) →
    @has_mem.mem.{u u}
      (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (set.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      (@set.has_mem.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      _a
      (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
         (set.{u} (prod.{u u} α α))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (@set.image.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
         (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
         s),
a b : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u),
_x :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (λ
        (s :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       s),
_fun_match :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (λ
        (s :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       s) →
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
       s),
c : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u),
a₁ a₂ : α,
ha :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α a₁ a₂)
    s,
b₁ b₂ : α,
hb :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α b₁ b₂)
    s,
a_eq :
  and
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₁)
       a)
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₂)
       c),
b_eq :
  and
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₁)
       c)
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₂)
       b)
⊢ @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
u : uniform_space.{u} α,
s : set.{u} (prod.{u u} α α),
hs :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    s
    (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u)),
_x :
  prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
    (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)),
_fun_match :
  ∀
  (_a :
    prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
      (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))),
    @has_mem.mem.{u u}
      (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (set.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      (@set.has_mem.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      _a
      (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (λ
          (s :
            set.{u}
              (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
            @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
         (@set.image.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
         s) →
    @has_mem.mem.{u u}
      (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (set.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      (@set.has_mem.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      _a
      (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
         (set.{u} (prod.{u u} α α))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (@set.image.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
         (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
         s),
a b : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u),
_x :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (λ
        (s :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       s),
_fun_match :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (λ
        (s :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       s) →
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
       s),
c : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u),
a₁ a₂ : α,
ha :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α a₁ a₂)
    s,
b₁ b₂ : α,
hb :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α b₁ b₂)
    s,
a_eq :
  and
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₁)
       a)
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₂)
       c),
b_eq :
  and
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₁)
       c)
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₂)
       b)
⊢ @eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
    (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₂)
    (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₁)

α : Type u,
u : uniform_space.{u} α,
s : set.{u} (prod.{u u} α α),
hs :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    s
    (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u)),
_x :
  prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
    (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)),
_fun_match :
  ∀
  (_a :
    prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
      (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))),
    @has_mem.mem.{u u}
      (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (set.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      (@set.has_mem.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      _a
      (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (λ
          (s :
            set.{u}
              (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
            @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
         (@set.image.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
         s) →
    @has_mem.mem.{u u}
      (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (set.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      (@set.has_mem.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      _a
      (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
         (set.{u} (prod.{u u} α α))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (@set.image.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
         (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
         s),
a b : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u),
_x :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (λ
        (s :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       s),
_fun_match :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (λ
        (s :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       s) →
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
       s),
c : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u),
a₁ a₂ : α,
ha :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α a₁ a₂)
    s,
b₁ b₂ : α,
hb :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α b₁ b₂)
    s,
a_eq :
  and
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₁)
       a)
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₂)
       c),
b_eq :
  and
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₁)
       c)
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₂)
       b),
h :
  @eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
    (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₂)
    (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₁)
⊢ @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
u : uniform_space.{u} α,
s : set.{u} (prod.{u u} α α),
hs :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    s
    (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u)),
_x :
  prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
    (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)),
_fun_match :
  ∀
  (_a :
    prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
      (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))),
    @has_mem.mem.{u u}
      (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (set.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      (@set.has_mem.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      _a
      (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (λ
          (s :
            set.{u}
              (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
            @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
         (@set.image.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
         s) →
    @has_mem.mem.{u u}
      (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (set.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      (@set.has_mem.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      _a
      (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
         (set.{u} (prod.{u u} α α))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (@set.image.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
         (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
         s),
a b : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u),
_x :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (λ
        (s :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       s),
_fun_match :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (λ
        (s :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       s) →
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
       s),
c : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u),
a₁ a₂ : α,
ha :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α a₁ a₂)
    s,
b₁ b₂ : α,
hb :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α b₁ b₂)
    s,
a_eq :
  and
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₁)
       a)
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₂)
       c),
b_eq :
  and
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₁)
       c)
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₂)
       b)
⊢ @eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
    (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₂)
    (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
u : uniform_space.{u} α,
s : set.{u} (prod.{u u} α α),
hs :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    s
    (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u)),
_x :
  prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
    (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)),
_fun_match :
  ∀
  (_a :
    prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
      (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))),
    @has_mem.mem.{u u}
      (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (set.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      (@set.has_mem.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      _a
      (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (λ
          (s :
            set.{u}
              (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
            @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
         (@set.image.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
         s) →
    @has_mem.mem.{u u}
      (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (set.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      (@set.has_mem.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      _a
      (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
         (set.{u} (prod.{u u} α α))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (@set.image.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
         (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
         s),
a b : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u),
_x :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (λ
        (s :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       s),
_fun_match :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (λ
        (s :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       s) →
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
       s),
c : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u),
a₁ a₂ : α,
ha :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α a₁ a₂)
    s,
b₁ b₂ : α,
hb :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α b₁ b₂)
    s,
a_eq :
  and
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₁)
       a)
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₂)
       c),
b_eq :
  and
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₁)
       c)
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₂)
       b)
⊢ @eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) c
    (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
u : uniform_space.{u} α,
s : set.{u} (prod.{u u} α α),
hs :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    s
    (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u)),
_x :
  prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
    (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)),
_fun_match :
  ∀
  (_a :
    prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
      (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))),
    @has_mem.mem.{u u}
      (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (set.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      (@set.has_mem.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      _a
      (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (λ
          (s :
            set.{u}
              (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
            @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
         (@set.image.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
         s) →
    @has_mem.mem.{u u}
      (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (set.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      (@set.has_mem.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      _a
      (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
         (set.{u} (prod.{u u} α α))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (@set.image.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
         (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
         s),
a b : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u),
_x :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (λ
        (s :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       s),
_fun_match :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (λ
        (s :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       s) →
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
       s),
c : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u),
a₁ a₂ : α,
ha :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α a₁ a₂)
    s,
b₁ b₂ : α,
hb :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α b₁ b₂)
    s,
a_eq :
  and
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₁)
       a)
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₂)
       c),
b_eq :
  and
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₁)
       c)
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₂)
       b)
⊢ @eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
    (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₂)
    (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
u : uniform_space.{u} α,
s : set.{u} (prod.{u u} α α),
hs :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    s
    (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u)),
_x :
  prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
    (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)),
_fun_match :
  ∀
  (_a :
    prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
      (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))),
    @has_mem.mem.{u u}
      (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (set.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      (@set.has_mem.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      _a
      (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (λ
          (s :
            set.{u}
              (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
            @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
         (@set.image.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
         s) →
    @has_mem.mem.{u u}
      (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (set.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      (@set.has_mem.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      _a
      (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
         (set.{u} (prod.{u u} α α))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (@set.image.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
         (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
         s),
a b : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u),
_x :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (λ
        (s :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       s),
_fun_match :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (λ
        (s :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       s) →
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
       s),
c : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u),
a₁ a₂ : α,
ha :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α a₁ a₂)
    s,
b₁ b₂ : α,
hb :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α b₁ b₂)
    s,
a_eq :
  and
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₁)
       a)
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₂)
       c),
b_eq :
  and
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₁)
       c)
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₂)
       b),
h :
  @eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
    (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₂)
    (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₁)
⊢ @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123          have h : (a₂, b₁) ∈ separation_rel α := quotient.exact h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='separation_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='quotient.exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 26, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 211, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type u) [u : uniform_space.{u} α], set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [s : setoid.{u+1} α] {a b : α}, @eq.{u+1} (@quotient.{u+1} α s) (@quotient.mk.{u+1} α s a) (@quotient.mk.{u+1} α s b) → @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α s) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₂) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The separation relation is the intersection of all entourages.
 Two points which are related by the separation relation are &quot;indistinguishable&quot;
 according to the uniform structure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
u : uniform_space.{u} α,
s : set.{u} (prod.{u u} α α),
hs :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    s
    (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u)),
_x :
  prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
    (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)),
_fun_match :
  ∀
  (_a :
    prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
      (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))),
    @has_mem.mem.{u u}
      (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (set.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      (@set.has_mem.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      _a
      (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (λ
          (s :
            set.{u}
              (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
            @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
         (@set.image.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
         s) →
    @has_mem.mem.{u u}
      (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (set.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      (@set.has_mem.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      _a
      (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
         (set.{u} (prod.{u u} α α))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (@set.image.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
         (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
         s),
a b : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u),
_x :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (λ
        (s :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       s),
_fun_match :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (λ
        (s :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       s) →
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
       s),
c : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u),
a₁ a₂ : α,
ha :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α a₁ a₂)
    s,
b₁ b₂ : α,
hb :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α b₁ b₂)
    s,
a_eq :
  and
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₁)
       a)
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₂)
       c),
b_eq :
  and
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₁)
       c)
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₂)
       b),
h :
  @eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
    (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₂)
    (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₁)
⊢ @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
u : uniform_space.{u} α,
s : set.{u} (prod.{u u} α α),
hs :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    s
    (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u)),
_x :
  prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
    (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)),
_fun_match :
  ∀
  (_a :
    prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
      (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))),
    @has_mem.mem.{u u}
      (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (set.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      (@set.has_mem.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      _a
      (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (λ
          (s :
            set.{u}
              (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
            @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
         (@set.image.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
         s) →
    @has_mem.mem.{u u}
      (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (set.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      (@set.has_mem.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      _a
      (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
         (set.{u} (prod.{u u} α α))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (@set.image.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
         (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
         s),
a b : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u),
_x :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (λ
        (s :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       s),
_fun_match :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (λ
        (s :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       s) →
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
       s),
c : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u),
a₁ a₂ : α,
ha :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α a₁ a₂)
    s,
b₁ b₂ : α,
hb :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α b₁ b₂)
    s,
a_eq :
  and
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₁)
       a)
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₂)
       c),
b_eq :
  and
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₁)
       c)
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₂)
       b),
h :
  @eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
    (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₂)
    (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₁),
h :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α a₂ b₁)
    (@separation_rel.{u} α u)
⊢ @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124          simp [function.comp, set.image, comp_rel, and.comm, and.left_comm, and.assoc],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='comp_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='and.comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='and.left_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='and.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 380, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 392, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Sort ?l_1} {β : Sort ?l_2} {φ : Sort ?l_3}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2}, (α → β) → set.{?l_1} α → set.{?l_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1}, set.{?l_1} (prod.{?l_1 ?l_1} α α) → set.{?l_1} (prod.{?l_1 ?l_1} α α) → set.{?l_1} (prod.{?l_1 ?l_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff (and a b) (and b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b c : Prop}, iff (and a (and b c)) (and b (and a c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b c : Prop}, iff (and (and a b) c) (and a (and b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The composition of relations'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
u : uniform_space.{u} α,
s : set.{u} (prod.{u u} α α),
hs :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    s
    (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u)),
_x :
  prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
    (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)),
_fun_match :
  ∀
  (_a :
    prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
      (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))),
    @has_mem.mem.{u u}
      (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (set.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      (@set.has_mem.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      _a
      (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (λ
          (s :
            set.{u}
              (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
            @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
         (@set.image.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
         s) →
    @has_mem.mem.{u u}
      (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (set.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      (@set.has_mem.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      _a
      (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
         (set.{u} (prod.{u u} α α))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (@set.image.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
         (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
         s),
a b : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u),
_x :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (λ
        (s :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       s),
_fun_match :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (λ
        (s :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       s) →
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
       s),
c : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u),
a₁ a₂ : α,
ha :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α a₁ a₂)
    s,
b₁ b₂ : α,
hb :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α b₁ b₂)
    s,
a_eq :
  and
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₁)
       a)
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₂)
       c),
b_eq :
  and
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₁)
       c)
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₂)
       b),
h :
  @eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
    (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₂)
    (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₁),
h :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α a₂ b₁)
    (@separation_rel.{u} α u)
⊢ @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
u : uniform_space.{u} α,
s : set.{u} (prod.{u u} α α),
hs :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    s
    (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u)),
_x :
  prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
    (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)),
_fun_match :
  ∀
  (_a :
    prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
      (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))),
    @has_mem.mem.{u u}
      (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (set.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      (@set.has_mem.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      _a
      (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (λ
          (s :
            set.{u}
              (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
            @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
         (@set.image.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
         s) →
    @has_mem.mem.{u u}
      (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (set.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      (@set.has_mem.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      _a
      (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
         (set.{u} (prod.{u u} α α))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (@set.image.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
         (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
         s),
a b : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u),
_x :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (λ
        (s :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       s),
_fun_match :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (λ
        (s :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       s) →
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
       s),
c : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u),
a₁ a₂ : α,
ha :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α a₁ a₂)
    s,
b₁ b₂ : α,
hb :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α b₁ b₂)
    s,
a_eq :
  and
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₁)
       a)
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₂)
       c),
b_eq :
  and
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₁)
       c)
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₂)
       b),
h :
  @eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
    (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₂)
    (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₁),
h :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α a₂ b₁)
    (@separation_rel.{u} α u)
⊢ @Exists.{u+1} α
    (λ (a_1 : α),
       and
         (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a_1)
            a)
         (@Exists.{u+1} α
            (λ (x : α),
               and
                 (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                    (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) x)
                    b)
                 (@Exists.{u+1} α
                    (λ (z : α),
                       and
                         (@has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α))
                            (@set.has_mem.{u} (prod.{u u} α α))
                            (@prod.mk.{u u} α α a_1 z)
                            s)
                         (@Exists.{u+1} α
                            (λ (z_1 : α),
                               and
                                 (@has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α))
                                    (@set.has_mem.{u} (prod.{u u} α α))
                                    (@prod.mk.{u u} α α z z_1)
                                    s)
                                 (@has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α))
                                    (@set.has_mem.{u} (prod.{u u} α α))
                                    (@prod.mk.{u u} α α z_1 x)
                                    s))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125          exact ⟨a₁, a_eq.left, b₂, b_eq.right, a₂, ha, b₁, h s hs, hb⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₁) a) (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₂) c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₁) c) (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₂) b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α a₁ a₂) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α a₂ b₁) (@separation_rel.{u} α u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) s (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α b₁ b₂) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
u : uniform_space.{u} α,
s : set.{u} (prod.{u u} α α),
hs :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    s
    (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u)),
_x :
  prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
    (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)),
_fun_match :
  ∀
  (_a :
    prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
      (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))),
    @has_mem.mem.{u u}
      (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (set.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      (@set.has_mem.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      _a
      (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (λ
          (s :
            set.{u}
              (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
            @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
         (@set.image.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
         s) →
    @has_mem.mem.{u u}
      (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (set.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      (@set.has_mem.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      _a
      (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
         (set.{u} (prod.{u u} α α))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (@set.image.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
         (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
         s),
a b : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u),
_x :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (λ
        (s :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       s),
_fun_match :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (λ
        (s :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       s) →
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
       s),
c : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u),
a₁ a₂ : α,
ha :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α a₁ a₂)
    s,
b₁ b₂ : α,
hb :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α b₁ b₂)
    s,
a_eq :
  and
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₁)
       a)
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₂)
       c),
b_eq :
  and
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₁)
       c)
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₂)
       b),
h :
  @eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
    (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₂)
    (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₁),
h :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α a₂ b₁)
    (@separation_rel.{u} α u)
⊢ @Exists.{u+1} α
    (λ (a_1 : α),
       and
         (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a_1)
            a)
         (@Exists.{u+1} α
            (λ (x : α),
               and
                 (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                    (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) x)
                    b)
                 (@Exists.{u+1} α
                    (λ (z : α),
                       and
                         (@has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α))
                            (@set.has_mem.{u} (prod.{u u} α α))
                            (@prod.mk.{u u} α α a_1 z)
                            s)
                         (@Exists.{u+1} α
                            (λ (z_1 : α),
                               and
                                 (@has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α))
                                    (@set.has_mem.{u} (prod.{u u} α α))
                                    (@prod.mk.{u u} α α z z_1)
                                    s)
                                 (@has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α))
                                    (@set.has_mem.{u} (prod.{u u} α α))
                                    (@prod.mk.{u u} α α z_1 x)
                                    s))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126        end</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
u : uniform_space.{u} α,
s : set.{u} (prod.{u u} α α),
hs :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    s
    (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u)),
_x :
  prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
    (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)),
_fun_match :
  ∀
  (_a :
    prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
      (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))),
    @has_mem.mem.{u u}
      (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (set.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      (@set.has_mem.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      _a
      (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (λ
          (s :
            set.{u}
              (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
            @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
         (@set.image.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
         s) →
    @has_mem.mem.{u u}
      (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (set.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      (@set.has_mem.{u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
      _a
      (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
         (set.{u} (prod.{u u} α α))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
         (@set.image.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
         (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
         s),
a b : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u),
_x :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (λ
        (s :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       s),
_fun_match :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (λ
        (s :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @comp_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) s s)
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       s) →
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       a
       b)
    (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
       (set.{u} (prod.{u u} α α))
       (set.{u}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
       (@set.image.{u u} (prod.{u u} α α)
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
          (λ (p : prod.{u u} α α),
             @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
       (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))
       s),
c : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u),
a₁ a₂ : α,
ha :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α a₁ a₂)
    s,
b₁ b₂ : α,
hb :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α b₁ b₂)
    s,
a_eq :
  and
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₁)
       a)
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₂)
       c),
b_eq :
  and
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₁)
       c)
    (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₂)
       b),
h :
  @eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
    (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₂)
    (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) b₁),
h :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α a₂ b₁)
    (@separation_rel.{u} α u)
⊢ @Exists.{u+1} α
    (λ (a_1 : α),
       and
         (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a_1)
            a)
         (@Exists.{u+1} α
            (λ (x : α),
               and
                 (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                    (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) x)
                    b)
                 (@Exists.{u+1} α
                    (λ (z : α),
                       and
                         (@has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α))
                            (@set.has_mem.{u} (prod.{u u} α α))
                            (@prod.mk.{u u} α α a_1 z)
                            s)
                         (@Exists.{u+1} α
                            (λ (z_1 : α),
                               and
                                 (@has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α))
                                    (@set.has_mem.{u} (prod.{u u} α α))
                                    (@prod.mk.{u u} α α z z_1)
                                    s)
                                 (@has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α))
                                    (@set.has_mem.{u} (prod.{u u} α α))
                                    (@prod.mk.{u u} α α z_1 x)
                                    s))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127      ... = map (λp:(α×α), (⟦p.1⟧, ⟦p.2⟧)) (u.uniformity.lift&#x27; (λs:set (α×α), comp_rel s (comp_rel s s))) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='filter.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_space.core.uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='filter.lift&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='comp_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='comp_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 764, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/lift.lean&#x27;, &#x27;line&#x27;: 175, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → filter.{u} α → filter.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='prod.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='prod.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='uniform_space.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, uniform_space.core.{u} α → filter.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, filter.{u} α → (set.{u} α → set.{u} β) → filter.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, set.{u} (prod.{u u} α α) → set.{u} (prod.{u u} α α) → set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, set.{u} (prod.{u u} α α) → set.{u} (prod.{u u} α α) → set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The forward map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='orange'><a title=' Specialize `lift` to functions `set α → set β`. This can be viewed as a generalization of `map`.
This is essentially a push-forward along a function mapping each set to a set.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The composition of relations'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The composition of relations'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128        by rw [map_lift&#x27;_eq];</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='filter.map_lift&#x27;_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/lift.lean&#x27;, &#x27;line&#x27;: 200, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β γ : Type u} {f : filter.{u} α} {h : set.{u} α → set.{u} β} {m : β → γ}, @monotone.{u u} (set.{u} α) (set.{u} β) (@partial_order.to_preorder.{u} (set.{u} α) (@lattice.order_bot.to_partial_order.{u} (set.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α))))) (@partial_order.to_preorder.{u} (set.{u} β) (@lattice.order_bot.to_partial_order.{u} (set.{u} β) (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} β) (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} β) (@set.lattice_set.{u} β))))) h → @eq.{u+1} (filter.{u} γ) (@filter.map.{u u} β γ m (@filter.lift&#x27;.{u u} α β f h)) (@filter.lift&#x27;.{u u} α γ f (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} α) (set.{u} β) (set.{u} γ) (@set.image.{u u} β γ m) h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='lime'><a title='α : Type u,
u : uniform_space.{u} α
⊢ @eq.{u+1}
    (filter.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@filter.lift&#x27;.{u u} (prod.{u u} α α)
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
       (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u))
       (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
          (set.{u} (prod.{u u} α α))
          (set.{u}
             (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
          (@set.image.{u u} (prod.{u u} α α)
             (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
             (λ (p : prod.{u u} α α),
                @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                  (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                  (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                  (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
          (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))))
    (@filter.map.{u u} (prod.{u u} α α)
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
       (λ (p : prod.{u u} α α),
          @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
            (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p)))
       (@filter.lift&#x27;.{u u} (prod.{u u} α α) (prod.{u u} α α)
          (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u))
          (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
u : uniform_space.{u} α
⊢ @monotone.{u u} (set.{u} (prod.{u u} α α)) (set.{u} (prod.{u u} α α))
    (@partial_order.to_preorder.{u} (set.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_partial_order.{u} (set.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} (prod.{u u} α α))
                (@set.lattice_set.{u} (prod.{u u} α α))))))
    (@partial_order.to_preorder.{u} (set.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_partial_order.{u} (set.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} (prod.{u u} α α))
                (@set.lattice_set.{u} (prod.{u u} α α))))))
    (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
u : uniform_space.{u} α
⊢ @eq.{u+1}
    (filter.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@filter.lift&#x27;.{u u} (prod.{u u} α α)
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
       (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u))
       (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
          (set.{u} (prod.{u u} α α))
          (set.{u}
             (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
          (@set.image.{u u} (prod.{u u} α α)
             (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
             (λ (p : prod.{u u} α α),
                @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                  (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                  (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                  (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
          (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))))
    (@filter.map.{u u} (prod.{u u} α α)
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
       (λ (p : prod.{u u} α α),
          @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
            (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p)))
       (@filter.lift&#x27;.{u u} (prod.{u u} α α) (prod.{u u} α α)
          (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u))
          (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129          exact monotone_comp_rel monotone_id (monotone_comp_rel monotone_id monotone_id)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='blue'><a title='monotone_comp_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='monotone_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 55, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : preorder.{u} β] {f g : β → set.{u} (prod.{u u} α α)}, @monotone.{u u} β (set.{u} (prod.{u u} α α)) _inst_1 (@partial_order.to_preorder.{u} (set.{u} (prod.{u u} α α)) (@lattice.order_bot.to_partial_order.{u} (set.{u} (prod.{u u} α α)) (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} (prod.{u u} α α)) (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} (prod.{u u} α α)) (@set.lattice_set.{u} (prod.{u u} α α)))))) f → @monotone.{u u} β (set.{u} (prod.{u u} α α)) _inst_1 (@partial_order.to_preorder.{u} (set.{u} (prod.{u u} α α)) (@lattice.order_bot.to_partial_order.{u} (set.{u} (prod.{u u} α α)) (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} (prod.{u u} α α)) (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} (prod.{u u} α α)) (@set.lattice_set.{u} (prod.{u u} α α)))))) g → @monotone.{u u} β (set.{u} (prod.{u u} α α)) _inst_1 (@partial_order.to_preorder.{u} (set.{u} (prod.{u u} α α)) (@lattice.order_bot.to_partial_order.{u} (set.{u} (prod.{u u} α α)) (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} (prod.{u u} α α)) (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} (prod.{u u} α α)) (@set.lattice_set.{u} (prod.{u u} α α)))))) (λ (x : β), @comp_rel.{u} α (f x) (g x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α], @monotone.{u u} α α _inst_1 _inst_1 (@id.{u+1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
u : uniform_space.{u} α
⊢ @eq.{u+1}
    (filter.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@filter.lift&#x27;.{u u} (prod.{u u} α α)
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
       (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u))
       (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
          (set.{u} (prod.{u u} α α))
          (set.{u}
             (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
          (@set.image.{u u} (prod.{u u} α α)
             (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
             (λ (p : prod.{u u} α α),
                @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                  (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                  (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                  (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
          (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))))
    (@filter.map.{u u} (prod.{u u} α α)
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
       (λ (p : prod.{u u} α α),
          @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
            (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p)))
       (@filter.lift&#x27;.{u u} (prod.{u u} α α) (prod.{u u} α α)
          (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u))
          (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130      ... ≤ map (λp:(α×α), (⟦p.1⟧, ⟦p.2⟧)) u.uniformity :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='filter.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_space.core.uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 764, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → filter.{u} α → filter.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='prod.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='prod.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='uniform_space.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, uniform_space.core.{u} α → filter.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The forward map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
u : uniform_space.{u} α
⊢ @eq.{u+1}
    (filter.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
    (@filter.lift&#x27;.{u u} (prod.{u u} α α)
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
       (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u))
       (@function.comp.{(max (u+1) 1) (max (u+1) 1) (max (u+1) 1)} (set.{u} (prod.{u u} α α))
          (set.{u} (prod.{u u} α α))
          (set.{u}
             (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
          (@set.image.{u u} (prod.{u u} α α)
             (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
             (λ (p : prod.{u u} α α),
                @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                  (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                  (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                  (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))))
          (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))))
    (@filter.map.{u u} (prod.{u u} α α)
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
       (λ (p : prod.{u u} α α),
          @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
            (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p)))
       (@filter.lift&#x27;.{u u} (prod.{u u} α α) (prod.{u u} α α)
          (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u))
          (λ (s : set.{u} (prod.{u u} α α)), @comp_rel.{u} α s (@comp_rel.{u} α s s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131        map_mono comp_le_uniformity3,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='filter.map_mono'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='comp_le_uniformity3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 931, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α : Type u} {β : Type v} {m : α → β}, @monotone.{u v} (filter.{u} α) (filter.{v} β) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)) (@partial_order.to_preorder.{v} (filter.{v} β) (@filter.partial_order.{v} β)) (@filter.map.{u v} α β m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : uniform_space.{u_1} α], @has_le.le.{u_1} (filter.{u_1} (prod.{u_1 u_1} α α)) (@preorder.to_has_le.{u_1} (filter.{u_1} (prod.{u_1 u_1} α α)) (@partial_order.to_preorder.{u_1} (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.partial_order.{u_1} (prod.{u_1 u_1} α α)))) (@filter.lift&#x27;.{u_1 u_1} (prod.{u_1 u_1} α α) (prod.{u_1 u_1} α α) (@uniformity.{u_1} α _inst_1) (λ (s : set.{u_1} (prod.{u_1 u_1} α α)), @comp_rel.{u_1} α s (@comp_rel.{u_1} α s s))) (@uniformity.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132    is_open_uniformity := assume s,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133      have ∀a, ⟦a⟧ ∈ s →</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134          ({p:α×α | p.1 = a → ⟦p.2⟧ ∈ s} ∈ 𝓤 α ↔</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='prod.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='prod.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [_inst_2 : uniform_space.{u} α], filter.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135            {p:α×α | p.1 ≈ a → ⟦p.2⟧ ∈ s} ∈ 𝓤 α),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_equiv.equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 326, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='prod.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [c : has_equiv.{u+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='prod.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [_inst_2 : uniform_space.{u} α], filter.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136        from assume a ha,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))) (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137        ⟨assume h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) (@set_of.{u} (prod.{u u} α α) (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) a → @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))) (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p)) s)) (@uniformity.{u} α u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138          let ⟨t, ht, hts⟩ := comp_mem_uniformity_sets h in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ht'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hts'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='comp_mem_uniformity_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@Exists.{u+1} (set.{u} (prod.{u u} α α)) (λ (t : set.{u} (prod.{u u} α α)), @Exists.{0} (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) t (@uniformity.{u} α u)) (λ (H : @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) t (@uniformity.{u} α u)), @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α)) (@comp_rel.{u} α t t) (@set_of.{u} (prod.{u u} α α) (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) a → @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))) (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p)) s)))) → @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) (@set_of.{u} (prod.{u u} α α) (λ (p : prod.{u u} α α), @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (@prod.fst.{u u} α α p) a → @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))) (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p)) s)) (@uniformity.{u} α u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) t (@uniformity.{u} α u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α)) (@comp_rel.{u} α t t) (@set_of.{u} (prod.{u u} α α) (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) a → @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))) (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p)) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : uniform_space.{u_1} α] {s : set.{u_1} (prod.{u_1 u_1} α α)}, @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) s (@uniformity.{u_1} α _inst_1) → @Exists.{u_1+1} (set.{u_1} (prod.{u_1 u_1} α α)) (λ (t : set.{u_1} (prod.{u_1 u_1} α α)), @Exists.{0} (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) t (@uniformity.{u_1} α _inst_1)) (λ (H : @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) t (@uniformity.{u_1} α _inst_1)), @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α)) (@comp_rel.{u_1} α t t) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) (@set_of.{u} (prod.{u u} α α) (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) a → @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))) (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p)) s)) (@uniformity.{u} α u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139          have hts : ∀{a₁ a₂}, (a, a₁) ∈ t → (a₁, a₂) ∈ t → ⟦a₂⟧ ∈ s,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140            from assume a₁ a₂ ha₁ ha₂, @hts (a, a₂) ⟨a₁, ha₁, ha₂⟩ rfl,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ha₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ha₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ha₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ha₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α a a₁) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α a₁ a₂) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α a a₁) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α a₁ a₂) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Sort u} {a : α}, @eq.{u} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141          have ht&#x27; : ∀{a₁ a₂}, a₁ ≈ a₂ → (a₁, a₂) ∈ t,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_equiv.equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 326, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_equiv.{u+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142            from assume a₁ a₂ h, sInter_subset_of_mem ht h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.sInter_subset_of_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 344, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α u)) a₁ a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {S : set.{u} (set.{u} α)} {t : set.{u} α}, @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t S → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@set.sInter.{u} α S) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α u)) a₁ a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143          u.uniformity.sets_of_superset ht $ assume ⟨a₁, a₂⟩ h₁ h₂, hts (ht&#x27; $ setoid.symm h₂) h₁,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_space.core.uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='filter.sets_of_superset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='h₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hts'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ht&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='setoid.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/setoid.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='uniform_space.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, uniform_space.core.{u} α → filter.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} (c : filter.{u} α) {x y : set.{u} α}, @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x (@filter.sets.{u} α c) → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) x y → @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) y (@filter.sets.{u} α c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='prod.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α a₁ a₂) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (@prod.fst.{u u} α α (@prod.mk.{u u} α α a₁ a₂)) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {a₁ a₂ : α}, @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α a a₁) t → @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α a₁ a₂) t → @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))) (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a₂) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {a₁ a₂ : α}, @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α u)) a₁ a₂ → @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α a₁ a₂) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Sort u} [_inst_1 : setoid.{u} α] {a b : α}, @has_equiv.equiv.{u} α (@setoid_has_equiv.{u} α _inst_1) a b → @has_equiv.equiv.{u} α (@setoid_has_equiv.{u} α _inst_1) b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (@prod.fst.{u u} α α (@prod.mk.{u u} α α a₁ a₂)) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α a₁ a₂) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144          assume h, u.uniformity.sets_of_superset h $ by simp {contextual := tt}⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_space.core.uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='filter.sets_of_superset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='bool.tt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) (@set_of.{u} (prod.{u u} α α) (λ (p : prod.{u u} α α), @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (@prod.fst.{u u} α α p) a → @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))) (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p)) s)) (@uniformity.{u} α u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='uniform_space.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, uniform_space.core.{u} α → filter.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} (c : filter.{u} α) {x y : set.{u} α}, @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x (@filter.sets.{u} α c) → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) x y → @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) y (@filter.sets.{u} α c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) (@set_of.{u} (prod.{u u} α α) (λ (p : prod.{u u} α α), @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (@prod.fst.{u u} α α p) a → @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))) (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p)) s)) (@uniformity.{u} α u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                      </code><font color='lime'><a title='α : Type u,
u : uniform_space.{u} α,
s : set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)),
a : α,
ha :
  @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
    (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
    (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a)
    s,
h :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (p : prod.{u u} α α),
          @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@prod.fst.{u u} α α p)
            a →
          @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))
            s))
    (@uniformity.{u} α u)
⊢ @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (p : prod.{u u} α α),
          @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (@prod.fst.{u u} α α p)
            a →
          @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))
            s))
    (@set_of.{u} (prod.{u u} α α)
       (λ (p : prod.{u u} α α),
          @eq.{u+1} α (@prod.fst.{u u} α α p) a →
          @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
            (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))
            s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145      begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='α : Type u,
u : uniform_space.{u} α,
s : set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)),
this :
  ∀ (a : α),
    @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
      (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a)
      s →
    iff
      (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
         (@filter.has_mem.{u} (prod.{u u} α α))
         (@set_of.{u} (prod.{u u} α α)
            (λ (p : prod.{u u} α α),
               @eq.{u+1} α (@prod.fst.{u u} α α p) a →
               @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
                 (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))
                 s))
         (@uniformity.{u} α u))
      (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
         (@filter.has_mem.{u} (prod.{u u} α α))
         (@set_of.{u} (prod.{u u} α α)
            (λ (p : prod.{u u} α α),
               @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@prod.fst.{u u} α α p)
                 a →
               @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
                 (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))
                 s))
         (@uniformity.{u} α u))
⊢ iff
    (@topological_space.is_open.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@topological_space.coinduced.{u u} α (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (λ (x : α), @quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) x)
          (@uniform_space.to_topological_space.{u} α u))
       s)
    (∀ (x : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)),
       @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
         (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
         x
         s →
       (λ
        (U :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
        (F :
          filter.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @has_mem.mem.{u u}
            (set.{u}
               (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                  (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
            (set.{u}
               (set.{u}
                  (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                     (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))))
            (@set.has_mem.{u}
               (set.{u}
                  (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                     (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))))
            U
            (@filter.sets.{u}
               (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                  (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
               F))
         (@set_of.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ
             (p :
               prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))),
               @eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@prod.fst.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                    (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                    p)
                 x →
               @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
                 (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
                 (@prod.snd.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                    (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                    p)
                 s))
         (@filter.map.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p)))
            (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146        simp [topological_space.coinduced, u.is_open_uniformity, uniformity, forall_quotient_iff],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='topological_space.coinduced'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='forall_quotient_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 265, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/quot.lean&#x27;, &#x27;line&#x27;: 88, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2}, (α → β) → topological_space.{?l_1} α → topological_space.{?l_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (s : set.{u} α), iff (@topological_space.is_open.{u} α (@uniform_space.to_topological_space.{u} α u) s) (∀ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s → @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (@(λ {α : Type u} (c : uniform_space.core.{u} α), filter.{u} (prod.{u u} α α)) α (@uniform_space.to_core.{u} α u)) (@filter.has_mem.{u} (prod.{u u} α α)) (@set_of.{u} (prod.{u u} α α) (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) x → @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α p) s)) (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type ?l_1) [_inst_2 : uniform_space.{?l_1} α], filter.{?l_1} (prod.{?l_1 ?l_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [r : setoid.{?l_1+1} α] {p : @quotient.{?l_1+1} α r → Prop}, iff (∀ (a : @quotient.{?l_1+1} α r), p a) (∀ (a : α), p (@quotient.mk.{?l_1+1} α r a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Given `f : α → β` and a topology on `α`, the coinduced topology on `β` is defined
 such that `s:set β` is open if the preimage of `s` is open. This is the finest topology that
 makes `f` continuous.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
u : uniform_space.{u} α,
s : set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)),
this :
  ∀ (a : α),
    @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
      (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a)
      s →
    iff
      (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
         (@filter.has_mem.{u} (prod.{u u} α α))
         (@set_of.{u} (prod.{u u} α α)
            (λ (p : prod.{u u} α α),
               @eq.{u+1} α (@prod.fst.{u u} α α p) a →
               @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
                 (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))
                 s))
         (@uniformity.{u} α u))
      (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
         (@filter.has_mem.{u} (prod.{u u} α α))
         (@set_of.{u} (prod.{u u} α α)
            (λ (p : prod.{u u} α α),
               @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@prod.fst.{u u} α α p)
                 a →
               @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
                 (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))
                 s))
         (@uniformity.{u} α u))
⊢ iff
    (@topological_space.is_open.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
       (@topological_space.coinduced.{u u} α (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
          (λ (x : α), @quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) x)
          (@uniform_space.to_topological_space.{u} α u))
       s)
    (∀ (x : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)),
       @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
         (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
         x
         s →
       (λ
        (U :
          set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
        (F :
          filter.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))),
          @has_mem.mem.{u u}
            (set.{u}
               (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                  (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))))
            (set.{u}
               (set.{u}
                  (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                     (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))))
            (@set.has_mem.{u}
               (set.{u}
                  (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                     (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))))
            U
            (@filter.sets.{u}
               (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                  (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
               F))
         (@set_of.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ
             (p :
               prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))),
               @eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@prod.fst.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                    (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                    p)
                 x →
               @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
                 (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
                 (@prod.snd.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                    (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                    p)
                 s))
         (@filter.map.{u u} (prod.{u u} α α)
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
            (λ (p : prod.{u u} α α),
               @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.fst.{u u} α α p))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p)))
            (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
u : uniform_space.{u} α,
s : set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)),
this :
  ∀ (a : α),
    @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
      (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a)
      s →
    iff
      (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
         (@filter.has_mem.{u} (prod.{u u} α α))
         (@set_of.{u} (prod.{u u} α α)
            (λ (p : prod.{u u} α α),
               @eq.{u+1} α (@prod.fst.{u u} α α p) a →
               @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
                 (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))
                 s))
         (@uniformity.{u} α u))
      (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
         (@filter.has_mem.{u} (prod.{u u} α α))
         (@set_of.{u} (prod.{u u} α α)
            (λ (p : prod.{u u} α α),
               @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@prod.fst.{u u} α α p)
                 a →
               @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
                 (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))
                 s))
         (@uniformity.{u} α u))
⊢ iff
    (∀ (x : α),
       @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
         (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
         (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) x)
         s →
       @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (set.{u} (set.{u} (prod.{u u} α α)))
         (@set.has_mem.{u} (set.{u} (prod.{u u} α α)))
         (@set_of.{u} (prod.{u u} α α)
            (λ (p : prod.{u u} α α),
               @eq.{u+1} α (@prod.fst.{u u} α α p) x →
               @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
                 (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))
                 s))
         (@filter.sets.{u} (prod.{u u} α α)
            (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u))))
    (∀ (a : α),
       @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
         (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
         (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a)
         s →
       @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (set.{u} (set.{u} (prod.{u u} α α)))
         (@set.has_mem.{u} (set.{u} (prod.{u u} α α)))
         (@set_of.{u} (prod.{u u} α α)
            (λ (x : prod.{u u} α α),
               @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@prod.fst.{u u} α α x)
                 a →
               @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
                 (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α x))
                 s))
         (@filter.sets.{u} (prod.{u u} α α)
            (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147        exact ⟨λh a ha, (this a ha).mp $ h a ha, λh a ha, (this a ha).mpr $ h a ha⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                         </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (a : α), @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))) (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a) s → iff (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) (@set_of.{u} (prod.{u u} α α) (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) a → @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))) (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p)) s)) (@uniformity.{u} α u)) (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) (@set_of.{u} (prod.{u u} α α) (λ (p : prod.{u u} α α), @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (@prod.fst.{u u} α α p) a → @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)) (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))) (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p)) s)) (@uniformity.{u} α u))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
u : uniform_space.{u} α,
s : set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)),
this :
  ∀ (a : α),
    @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
      (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a)
      s →
    iff
      (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
         (@filter.has_mem.{u} (prod.{u u} α α))
         (@set_of.{u} (prod.{u u} α α)
            (λ (p : prod.{u u} α α),
               @eq.{u+1} α (@prod.fst.{u u} α α p) a →
               @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
                 (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))
                 s))
         (@uniformity.{u} α u))
      (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
         (@filter.has_mem.{u} (prod.{u u} α α))
         (@set_of.{u} (prod.{u u} α α)
            (λ (p : prod.{u u} α α),
               @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@prod.fst.{u u} α α p)
                 a →
               @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
                 (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))
                 s))
         (@uniformity.{u} α u))
⊢ iff
    (∀ (x : α),
       @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
         (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
         (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) x)
         s →
       @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (set.{u} (set.{u} (prod.{u u} α α)))
         (@set.has_mem.{u} (set.{u} (prod.{u u} α α)))
         (@set_of.{u} (prod.{u u} α α)
            (λ (p : prod.{u u} α α),
               @eq.{u+1} α (@prod.fst.{u u} α α p) x →
               @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
                 (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))
                 s))
         (@filter.sets.{u} (prod.{u u} α α)
            (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u))))
    (∀ (a : α),
       @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
         (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
         (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a)
         s →
       @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (set.{u} (set.{u} (prod.{u u} α α)))
         (@set.has_mem.{u} (set.{u} (prod.{u u} α α)))
         (@set_of.{u} (prod.{u u} α α)
            (λ (x : prod.{u u} α α),
               @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@prod.fst.{u u} α α x)
                 a →
               @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
                 (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α x))
                 s))
         (@filter.sets.{u} (prod.{u u} α α)
            (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148      end }</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
u : uniform_space.{u} α,
s : set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)),
this :
  ∀ (a : α),
    @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
      (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
      (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a)
      s →
    iff
      (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
         (@filter.has_mem.{u} (prod.{u u} α α))
         (@set_of.{u} (prod.{u u} α α)
            (λ (p : prod.{u u} α α),
               @eq.{u+1} α (@prod.fst.{u u} α α p) a →
               @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
                 (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))
                 s))
         (@uniformity.{u} α u))
      (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
         (@filter.has_mem.{u} (prod.{u u} α α))
         (@set_of.{u} (prod.{u u} α α)
            (λ (p : prod.{u u} α α),
               @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@prod.fst.{u u} α α p)
                 a →
               @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
                 (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))
                 s))
         (@uniformity.{u} α u))
⊢ iff
    (∀ (x : α),
       @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
         (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
         (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) x)
         s →
       @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (set.{u} (set.{u} (prod.{u u} α α)))
         (@set.has_mem.{u} (set.{u} (prod.{u u} α α)))
         (@set_of.{u} (prod.{u u} α α)
            (λ (p : prod.{u u} α α),
               @eq.{u+1} α (@prod.fst.{u u} α α p) x →
               @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
                 (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α p))
                 s))
         (@filter.sets.{u} (prod.{u u} α α)
            (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u))))
    (∀ (a : α),
       @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
         (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
         (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
         (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) a)
         s →
       @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (set.{u} (set.{u} (prod.{u u} α α)))
         (@set.has_mem.{u} (set.{u} (prod.{u u} α α)))
         (@set_of.{u} (prod.{u u} α α)
            (λ (x : prod.{u u} α α),
               @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (@prod.fst.{u u} α α x)
                 a →
               @has_mem.mem.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u))
                 (set.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
                 (@set.has_mem.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α u)))
                 (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α u) (@prod.snd.{u u} α α x))
                 s))
         (@filter.sets.{u} (prod.{u u} α α)
            (@uniform_space.core.uniformity.{u} α (@uniform_space.to_core.{u} α u))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150  lemma uniformity_quotient :</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151    𝓤 (quotient (separation_setoid α)) = (𝓤 α).map (λp:(α×α), (⟦p.1⟧, ⟦p.2⟧)) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='quotient'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_space.separation_setoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 88, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 102, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 764, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u) [_inst_2 : uniform_space.{u} α], filter.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u}, setoid.{u} α → Sort u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u) [_inst_4 : uniform_space.{u} α], setoid.{u+1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u) [_inst_2 : uniform_space.{u} α], filter.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u}, (α → β) → filter.{u} α → filter.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='prod.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='prod.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The forward map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152  rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154  lemma uniform_continuous_quotient_mk :</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155    uniform_continuous (quotient.mk : α → quotient (separation_setoid α)) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='quotient'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_space.separation_setoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 427, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 88, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 102, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u} [s : setoid.{u} α], α → @quotient.{u} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Sort u}, setoid.{u} α → Sort u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u) [_inst_4 : uniform_space.{u} α], setoid.{u+1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156  le_refl _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='le_refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] (a : α), @has_le.le.{u} α (@preorder.to_has_le.{u} α _inst_1) a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158  lemma uniform_continuous_quotient {f : quotient (separation_setoid α) → β}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='quotient'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_space.separation_setoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 88, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 102, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='green'><a title='Π {α : Sort u}, setoid.{u} α → Sort u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u) [_inst_4 : uniform_space.{u} α], setoid.{u+1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159    (hf : uniform_continuous (λx, f ⟦x⟧)) : uniform_continuous f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 427, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 427, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160  hf</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_continuous.{u v} α β _inst_1 _inst_2 (λ (x : α), f (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162  lemma uniform_continuous_quotient_lift</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163    {f : α → β} {h : ∀a b, (a, b) ∈ separation_rel α → f a = f b}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='separation_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 26, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [u : uniform_space.{u} α], set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='The separation relation is the intersection of all entourages.
 Two points which are related by the separation relation are &quot;indistinguishable&quot;
 according to the uniform structure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>164    (hf : uniform_continuous f) : uniform_continuous (λa, quotient.lift f h a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='quotient.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 427, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 427, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 102, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u} {β : Sort v} [s : setoid.{u} α] (f : α → β), (∀ (a b : α), @has_equiv.equiv.{u} α (@setoid_has_equiv.{u} α s) a b → @eq.{v} β (f a) (f b)) → @quotient.{u} α s → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (a b : α), @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α a b) (@separation_rel.{u} α _inst_1) → @eq.{v+1} β (f a) (f b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>165  uniform_continuous_quotient hf</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_space.uniform_continuous_quotient'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 158, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : uniform_space.{u} α] [_inst_2 : uniform_space.{v} β] {f : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) → β}, @uniform_continuous.{u v} α β _inst_1 _inst_2 (λ (x : α), f (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) x)) → @uniform_continuous.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) β (@uniform_space.separation_setoid.uniform_space.{u} α _inst_1) _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_continuous.{u v} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>166  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>167  lemma uniform_continuous_quotient_lift₂</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>168    {f : α → β → γ} {h : ∀a c b d, (a, b) ∈ separation_rel α → (c, d) ∈ separation_rel β → f a c = f b d}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='separation_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='separation_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 26, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 26, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [u : uniform_space.{u} α], set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type v}, α → β → prod.{v v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type v} [c : has_mem.{v v} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [u : uniform_space.{u} α], set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α → β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type w}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='orange'><a title='The separation relation is the intersection of all entourages.
 Two points which are related by the separation relation are &quot;indistinguishable&quot;
 according to the uniform structure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The separation relation is the intersection of all entourages.
 Two points which are related by the separation relation are &quot;indistinguishable&quot;
 according to the uniform structure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>169    (hf : uniform_continuous (λp:α×β, f p.1 p.2)) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 427, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v}, prod.{u v} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='prod.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v}, prod.{u v} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>170    uniform_continuous (λp:_×_, quotient.lift₂ f h p.1 p.2) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='quotient.lift₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 427, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 153, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Sort u_a} {β : Sort u_b} {φ : Sort u_c} [s₁ : setoid.{u_a} α] [s₂ : setoid.{u_b} β] (f : α → β → φ), (∀ (a₁ : α) (a₂ : β) (b₁ : α) (b₂ : β), @has_equiv.equiv.{u_a} α (@setoid_has_equiv.{u_a} α s₁) a₁ b₁ → @has_equiv.equiv.{u_b} β (@setoid_has_equiv.{u_b} β s₂) a₂ b₂ → @eq.{u_c} φ (f a₁ a₂) (f b₁ b₂)) → @quotient.{u_a} α s₁ → @quotient.{u_b} β s₂ → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (a : α) (c : β) (b : α) (d : β), @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α a b) (@separation_rel.{u} α _inst_1) → @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β)) (@prod.mk.{v v} β β c d) (@separation_rel.{v} β _inst_2) → @eq.{w+1} γ (f a c) (f b d)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v}, prod.{u v} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v}, prod.{u v} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>171  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
_inst_3 : uniform_space.{w} γ,
f : α → β → γ,
h :
  ∀ (a : α) (c : β) (b : α) (d : β),
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@separation_rel.{u} α _inst_1) →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β c d)
      (@separation_rel.{v} β _inst_2) →
    @eq.{w+1} γ (f a c) (f b d),
hf :
  @uniform_continuous.{(max u v) w} (prod.{u v} α β) γ (@prod.uniform_space.{u v} α β _inst_1 _inst_2) _inst_3
    (λ (p : prod.{u v} α β), f (@prod.fst.{u v} α β p) (@prod.snd.{u v} α β p))
⊢ @uniform_continuous.{(max u v) w}
    (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
       (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
    γ
    (@prod.uniform_space.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
       (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
       (@uniform_space.separation_setoid.uniform_space.{u} α _inst_1)
       (@uniform_space.separation_setoid.uniform_space.{v} β _inst_2))
    _inst_3
    (λ
     (p :
       prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
         (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))),
       @quotient.lift₂.{u+1 v+1 w+1} α β γ (@uniform_space.separation_setoid.{u} α _inst_1)
         (@uniform_space.separation_setoid.{v} β _inst_2)
         f
         h
         (@prod.fst.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
            (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
            p)
         (@prod.snd.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
            (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
            p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>172    rw [uniform_continuous, uniformity_prod_eq_prod, uniformity_quotient, uniformity_quotient,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniformity_prod_eq_prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_space.uniformity_quotient'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_space.uniformity_quotient'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 427, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 687, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 150, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 150, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : uniform_space.{?l_1} α] [_inst_2 : uniform_space.{?l_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : uniform_space.{u} α] [_inst_2 : uniform_space.{v} β], @eq.{(max u v)+1} (filter.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))) (@uniformity.{(max u v)} (prod.{u v} α β) (@prod.uniform_space.{u v} α β _inst_1 _inst_2)) (@filter.map.{(max u v) (max u v)} (prod.{u v} (prod.{u u} α α) (prod.{v v} β β)) (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (λ (p : prod.{u v} (prod.{u u} α α) (prod.{v v} β β)), @prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) (@prod.mk.{u v} α β (@prod.fst.{u u} α α (@prod.fst.{u v} (prod.{u u} α α) (prod.{v v} β β) p)) (@prod.fst.{v v} β β (@prod.snd.{u v} (prod.{u u} α α) (prod.{v v} β β) p))) (@prod.mk.{u v} α β (@prod.snd.{u u} α α (@prod.fst.{u v} (prod.{u u} α α) (prod.{v v} β β) p)) (@prod.snd.{v v} β β (@prod.snd.{u v} (prod.{u u} α α) (prod.{v v} β β) p)))) (@filter.prod.{u v} (prod.{u u} α α) (prod.{v v} β β) (@uniformity.{u} α _inst_1) (@uniformity.{v} β _inst_2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : uniform_space.{u} α], @eq.{u+1} (filter.{u} (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))) (@uniformity.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@uniform_space.separation_setoid.uniform_space.{u} α _inst_1)) (@filter.map.{u u} (prod.{u u} α α) (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))) (λ (p : prod.{u u} α α), @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.fst.{u u} α α p)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.snd.{u u} α α p))) (@uniformity.{u} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : uniform_space.{v} α], @eq.{v+1} (filter.{v} (prod.{v v} (@quotient.{v+1} α (@uniform_space.separation_setoid.{v} α _inst_1)) (@quotient.{v+1} α (@uniform_space.separation_setoid.{v} α _inst_1)))) (@uniformity.{v} (@quotient.{v+1} α (@uniform_space.separation_setoid.{v} α _inst_1)) (@uniform_space.separation_setoid.uniform_space.{v} α _inst_1)) (@filter.map.{v v} (prod.{v v} α α) (prod.{v v} (@quotient.{v+1} α (@uniform_space.separation_setoid.{v} α _inst_1)) (@quotient.{v+1} α (@uniform_space.separation_setoid.{v} α _inst_1))) (λ (p : prod.{v v} α α), @prod.mk.{v v} (@quotient.{v+1} α (@uniform_space.separation_setoid.{v} α _inst_1)) (@quotient.{v+1} α (@uniform_space.separation_setoid.{v} α _inst_1)) (@quotient.mk.{v+1} α (@uniform_space.separation_setoid.{v} α _inst_1) (@prod.fst.{v v} α α p)) (@quotient.mk.{v+1} α (@uniform_space.separation_setoid.{v} α _inst_1) (@prod.snd.{v v} α α p))) (@uniformity.{v} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
_inst_3 : uniform_space.{w} γ,
f : α → β → γ,
h :
  ∀ (a : α) (c : β) (b : α) (d : β),
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@separation_rel.{u} α _inst_1) →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β c d)
      (@separation_rel.{v} β _inst_2) →
    @eq.{w+1} γ (f a c) (f b d),
hf :
  @uniform_continuous.{(max u v) w} (prod.{u v} α β) γ (@prod.uniform_space.{u v} α β _inst_1 _inst_2) _inst_3
    (λ (p : prod.{u v} α β), f (@prod.fst.{u v} α β p) (@prod.snd.{u v} α β p))
⊢ @uniform_continuous.{(max u v) w}
    (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
       (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
    γ
    (@prod.uniform_space.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
       (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
       (@uniform_space.separation_setoid.uniform_space.{u} α _inst_1)
       (@uniform_space.separation_setoid.uniform_space.{v} β _inst_2))
    _inst_3
    (λ
     (p :
       prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
         (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))),
       @quotient.lift₂.{u+1 v+1 w+1} α β γ (@uniform_space.separation_setoid.{u} α _inst_1)
         (@uniform_space.separation_setoid.{v} β _inst_2)
         f
         h
         (@prod.fst.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
            (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
            p)
         (@prod.snd.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
            (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
            p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
_inst_3 : uniform_space.{w} γ,
f : α → β → γ,
h :
  ∀ (a : α) (c : β) (b : α) (d : β),
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@separation_rel.{u} α _inst_1) →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β c d)
      (@separation_rel.{v} β _inst_2) →
    @eq.{w+1} γ (f a c) (f b d),
hf :
  @uniform_continuous.{(max u v) w} (prod.{u v} α β) γ (@prod.uniform_space.{u v} α β _inst_1 _inst_2) _inst_3
    (λ (p : prod.{u v} α β), f (@prod.fst.{u v} α β p) (@prod.snd.{u v} α β p))
⊢ @filter.tendsto.{(max u v) w}
    (prod.{(max u v) (max u v)}
       (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
       (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
    (prod.{w w} γ γ)
    (λ
     (x :
       prod.{(max u v) (max u v)}
         (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
            (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
         (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
            (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))),
       @prod.mk.{w w} γ γ
         (@quotient.lift₂.{u+1 v+1 w+1} α β γ (@uniform_space.separation_setoid.{u} α _inst_1)
            (@uniform_space.separation_setoid.{v} β _inst_2)
            f
            h
            (@prod.fst.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@prod.fst.{(max u v) (max u v)}
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  x))
            (@prod.snd.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@prod.fst.{(max u v) (max u v)}
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  x)))
         (@quotient.lift₂.{u+1 v+1 w+1} α β γ (@uniform_space.separation_setoid.{u} α _inst_1)
            (@uniform_space.separation_setoid.{v} β _inst_2)
            f
            h
            (@prod.fst.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@prod.snd.{(max u v) (max u v)}
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  x))
            (@prod.snd.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@prod.snd.{(max u v) (max u v)}
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  x))))
    (@uniformity.{(max u v)}
       (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
       (@prod.uniform_space.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
          (@uniform_space.separation_setoid.uniform_space.{u} α _inst_1)
          (@uniform_space.separation_setoid.uniform_space.{v} β _inst_2)))
    (@uniformity.{w} γ _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
_inst_3 : uniform_space.{w} γ,
f : α → β → γ,
h :
  ∀ (a : α) (c : β) (b : α) (d : β),
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@separation_rel.{u} α _inst_1) →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β c d)
      (@separation_rel.{v} β _inst_2) →
    @eq.{w+1} γ (f a c) (f b d),
hf :
  @uniform_continuous.{(max u v) w} (prod.{u v} α β) γ (@prod.uniform_space.{u v} α β _inst_1 _inst_2) _inst_3
    (λ (p : prod.{u v} α β), f (@prod.fst.{u v} α β p) (@prod.snd.{u v} α β p))
⊢ @filter.tendsto.{(max u v) w}
    (prod.{(max u v) (max u v)}
       (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
       (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
    (prod.{w w} γ γ)
    (λ
     (x :
       prod.{(max u v) (max u v)}
         (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
            (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
         (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
            (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))),
       @prod.mk.{w w} γ γ
         (@quotient.lift₂.{u+1 v+1 w+1} α β γ (@uniform_space.separation_setoid.{u} α _inst_1)
            (@uniform_space.separation_setoid.{v} β _inst_2)
            f
            h
            (@prod.fst.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@prod.fst.{(max u v) (max u v)}
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  x))
            (@prod.snd.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@prod.fst.{(max u v) (max u v)}
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  x)))
         (@quotient.lift₂.{u+1 v+1 w+1} α β γ (@uniform_space.separation_setoid.{u} α _inst_1)
            (@uniform_space.separation_setoid.{v} β _inst_2)
            f
            h
            (@prod.fst.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@prod.snd.{(max u v) (max u v)}
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  x))
            (@prod.snd.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@prod.snd.{(max u v) (max u v)}
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  x))))
    (@filter.map.{(max u v) (max u v)}
       (prod.{u v}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
          (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
             (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
       (prod.{(max u v) (max u v)}
          (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
             (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
          (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
             (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
       (λ
        (p :
          prod.{u v}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
            (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))),
          @prod.mk.{(max u v) (max u v)}
            (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
            (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
            (@prod.mk.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@prod.fst.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@prod.fst.{u v}
                     (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                        (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                     (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                        (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                     p))
               (@prod.fst.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@prod.snd.{u v}
                     (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                        (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                     (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                        (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                     p)))
            (@prod.mk.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@prod.snd.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@prod.fst.{u v}
                     (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                        (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                     (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                        (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                     p))
               (@prod.snd.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@prod.snd.{u v}
                     (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                        (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                     (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                        (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                     p))))
       (@filter.prod.{u v}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
          (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
             (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
          (@uniformity.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
             (@uniform_space.separation_setoid.uniform_space.{u} α _inst_1))
          (@uniformity.{v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
             (@uniform_space.separation_setoid.uniform_space.{v} β _inst_2))))
    (@uniformity.{w} γ _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
_inst_3 : uniform_space.{w} γ,
f : α → β → γ,
h :
  ∀ (a : α) (c : β) (b : α) (d : β),
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@separation_rel.{u} α _inst_1) →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β c d)
      (@separation_rel.{v} β _inst_2) →
    @eq.{w+1} γ (f a c) (f b d),
hf :
  @uniform_continuous.{(max u v) w} (prod.{u v} α β) γ (@prod.uniform_space.{u v} α β _inst_1 _inst_2) _inst_3
    (λ (p : prod.{u v} α β), f (@prod.fst.{u v} α β p) (@prod.snd.{u v} α β p))
⊢ @filter.tendsto.{(max u v) w}
    (prod.{(max u v) (max u v)}
       (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
       (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
    (prod.{w w} γ γ)
    (λ
     (x :
       prod.{(max u v) (max u v)}
         (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
            (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
         (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
            (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))),
       @prod.mk.{w w} γ γ
         (@quotient.lift₂.{u+1 v+1 w+1} α β γ (@uniform_space.separation_setoid.{u} α _inst_1)
            (@uniform_space.separation_setoid.{v} β _inst_2)
            f
            h
            (@prod.fst.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@prod.fst.{(max u v) (max u v)}
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  x))
            (@prod.snd.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@prod.fst.{(max u v) (max u v)}
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  x)))
         (@quotient.lift₂.{u+1 v+1 w+1} α β γ (@uniform_space.separation_setoid.{u} α _inst_1)
            (@uniform_space.separation_setoid.{v} β _inst_2)
            f
            h
            (@prod.fst.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@prod.snd.{(max u v) (max u v)}
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  x))
            (@prod.snd.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@prod.snd.{(max u v) (max u v)}
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  x))))
    (@filter.map.{(max u v) (max u v)}
       (prod.{u v}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
          (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
             (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
       (prod.{(max u v) (max u v)}
          (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
             (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
          (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
             (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
       (λ
        (p :
          prod.{u v}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
            (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))),
          @prod.mk.{(max u v) (max u v)}
            (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
            (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
            (@prod.mk.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@prod.fst.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@prod.fst.{u v}
                     (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                        (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                     (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                        (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                     p))
               (@prod.fst.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@prod.snd.{u v}
                     (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                        (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                     (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                        (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                     p)))
            (@prod.mk.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@prod.snd.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@prod.fst.{u v}
                     (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                        (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                     (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                        (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                     p))
               (@prod.snd.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@prod.snd.{u v}
                     (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                        (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                     (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                        (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                     p))))
       (@filter.prod.{u v}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
          (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
             (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
          (@filter.map.{u u} (prod.{u u} α α)
             (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
             (λ (p : prod.{u u} α α),
                @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.fst.{u u} α α p))
                  (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.snd.{u u} α α p)))
             (@uniformity.{u} α _inst_1))
          (@uniformity.{v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
             (@uniform_space.separation_setoid.uniform_space.{v} β _inst_2))))
    (@uniformity.{w} γ _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
_inst_3 : uniform_space.{w} γ,
f : α → β → γ,
h :
  ∀ (a : α) (c : β) (b : α) (d : β),
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@separation_rel.{u} α _inst_1) →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β c d)
      (@separation_rel.{v} β _inst_2) →
    @eq.{w+1} γ (f a c) (f b d),
hf :
  @uniform_continuous.{(max u v) w} (prod.{u v} α β) γ (@prod.uniform_space.{u v} α β _inst_1 _inst_2) _inst_3
    (λ (p : prod.{u v} α β), f (@prod.fst.{u v} α β p) (@prod.snd.{u v} α β p))
⊢ @filter.tendsto.{(max u v) w}
    (prod.{(max u v) (max u v)}
       (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
       (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
    (prod.{w w} γ γ)
    (λ
     (x :
       prod.{(max u v) (max u v)}
         (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
            (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
         (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
            (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))),
       @prod.mk.{w w} γ γ
         (@quotient.lift₂.{u+1 v+1 w+1} α β γ (@uniform_space.separation_setoid.{u} α _inst_1)
            (@uniform_space.separation_setoid.{v} β _inst_2)
            f
            h
            (@prod.fst.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@prod.fst.{(max u v) (max u v)}
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  x))
            (@prod.snd.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@prod.fst.{(max u v) (max u v)}
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  x)))
         (@quotient.lift₂.{u+1 v+1 w+1} α β γ (@uniform_space.separation_setoid.{u} α _inst_1)
            (@uniform_space.separation_setoid.{v} β _inst_2)
            f
            h
            (@prod.fst.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@prod.snd.{(max u v) (max u v)}
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  x))
            (@prod.snd.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@prod.snd.{(max u v) (max u v)}
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  x))))
    (@filter.map.{(max u v) (max u v)}
       (prod.{u v}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
          (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
             (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
       (prod.{(max u v) (max u v)}
          (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
             (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
          (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
             (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
       (λ
        (p :
          prod.{u v}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
            (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))),
          @prod.mk.{(max u v) (max u v)}
            (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
            (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
            (@prod.mk.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@prod.fst.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@prod.fst.{u v}
                     (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                        (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                     (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                        (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                     p))
               (@prod.fst.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@prod.snd.{u v}
                     (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                        (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                     (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                        (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                     p)))
            (@prod.mk.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@prod.snd.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@prod.fst.{u v}
                     (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                        (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                     (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                        (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                     p))
               (@prod.snd.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@prod.snd.{u v}
                     (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                        (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                     (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                        (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                     p))))
       (@filter.prod.{u v}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
          (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
             (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
          (@filter.map.{u u} (prod.{u u} α α)
             (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
             (λ (p : prod.{u u} α α),
                @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.fst.{u u} α α p))
                  (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.snd.{u u} α α p)))
             (@uniformity.{u} α _inst_1))
          (@filter.map.{v v} (prod.{v v} β β)
             (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
             (λ (p : prod.{v v} β β),
                @prod.mk.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@quotient.mk.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2) (@prod.fst.{v v} β β p))
                  (@quotient.mk.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2) (@prod.snd.{v v} β β p)))
             (@uniformity.{v} β _inst_2))))
    (@uniformity.{w} γ _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>173      filter.prod_map_map_eq, filter.tendsto_map&#x27;_iff, filter.tendsto_map&#x27;_iff],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='filter.prod_map_map_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.tendsto_map&#x27;_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.tendsto_map&#x27;_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1576, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1415, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1415, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α₁ : Type u} {α₂ : Type v} {β₁ : Type u} {β₂ : Type v} {f₁ : filter.{u} α₁} {f₂ : filter.{v} α₂} {m₁ : α₁ → β₁} {m₂ : α₂ → β₂}, @eq.{(max u v)+1} (filter.{(max u v)} (prod.{u v} β₁ β₂)) (@filter.prod.{u v} β₁ β₂ (@filter.map.{u u} α₁ β₁ m₁ f₁) (@filter.map.{v v} α₂ β₂ m₂ f₂)) (@filter.map.{(max u v) (max u v)} (prod.{u v} α₁ α₂) (prod.{u v} β₁ β₂) (λ (p : prod.{u v} α₁ α₂), @prod.mk.{u v} β₁ β₂ (m₁ (@prod.fst.{u v} α₁ α₂ p)) (m₂ (@prod.snd.{u v} α₁ α₂ p))) (@filter.prod.{u v} α₁ α₂ f₁ f₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type (max u v)} {γ : Type w} {f : β → γ} {g : α → β} {x : filter.{(max u v)} α} {y : filter.{w} γ}, iff (@filter.tendsto.{(max u v) w} β γ f (@filter.map.{(max u v) (max u v)} α β g x) y) (@filter.tendsto.{(max u v) w} α γ (@function.comp.{(max u v)+1 (max u v)+1 w+1} α β γ f g) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type (max u v)} {γ : Type w} {f : β → γ} {g : α → β} {x : filter.{(max u v)} α} {y : filter.{w} γ}, iff (@filter.tendsto.{(max u v) w} β γ f (@filter.map.{(max u v) (max u v)} α β g x) y) (@filter.tendsto.{(max u v) w} α γ (@function.comp.{(max u v)+1 (max u v)+1 w+1} α β γ f g) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
_inst_3 : uniform_space.{w} γ,
f : α → β → γ,
h :
  ∀ (a : α) (c : β) (b : α) (d : β),
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@separation_rel.{u} α _inst_1) →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β c d)
      (@separation_rel.{v} β _inst_2) →
    @eq.{w+1} γ (f a c) (f b d),
hf :
  @uniform_continuous.{(max u v) w} (prod.{u v} α β) γ (@prod.uniform_space.{u v} α β _inst_1 _inst_2) _inst_3
    (λ (p : prod.{u v} α β), f (@prod.fst.{u v} α β p) (@prod.snd.{u v} α β p))
⊢ @filter.tendsto.{(max u v) w}
    (prod.{(max u v) (max u v)}
       (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
       (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
    (prod.{w w} γ γ)
    (λ
     (x :
       prod.{(max u v) (max u v)}
         (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
            (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
         (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
            (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))),
       @prod.mk.{w w} γ γ
         (@quotient.lift₂.{u+1 v+1 w+1} α β γ (@uniform_space.separation_setoid.{u} α _inst_1)
            (@uniform_space.separation_setoid.{v} β _inst_2)
            f
            h
            (@prod.fst.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@prod.fst.{(max u v) (max u v)}
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  x))
            (@prod.snd.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@prod.fst.{(max u v) (max u v)}
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  x)))
         (@quotient.lift₂.{u+1 v+1 w+1} α β γ (@uniform_space.separation_setoid.{u} α _inst_1)
            (@uniform_space.separation_setoid.{v} β _inst_2)
            f
            h
            (@prod.fst.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@prod.snd.{(max u v) (max u v)}
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  x))
            (@prod.snd.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@prod.snd.{(max u v) (max u v)}
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  x))))
    (@filter.map.{(max u v) (max u v)}
       (prod.{u v}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
          (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
             (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
       (prod.{(max u v) (max u v)}
          (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
             (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
          (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
             (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
       (λ
        (p :
          prod.{u v}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
            (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))),
          @prod.mk.{(max u v) (max u v)}
            (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
            (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
            (@prod.mk.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@prod.fst.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@prod.fst.{u v}
                     (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                        (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                     (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                        (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                     p))
               (@prod.fst.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@prod.snd.{u v}
                     (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                        (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                     (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                        (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                     p)))
            (@prod.mk.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@prod.snd.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@prod.fst.{u v}
                     (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                        (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                     (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                        (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                     p))
               (@prod.snd.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@prod.snd.{u v}
                     (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                        (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                     (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                        (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                     p))))
       (@filter.prod.{u v}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
          (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
             (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
          (@filter.map.{u u} (prod.{u u} α α)
             (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
             (λ (p : prod.{u u} α α),
                @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.fst.{u u} α α p))
                  (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.snd.{u u} α α p)))
             (@uniformity.{u} α _inst_1))
          (@filter.map.{v v} (prod.{v v} β β)
             (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
             (λ (p : prod.{v v} β β),
                @prod.mk.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@quotient.mk.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2) (@prod.fst.{v v} β β p))
                  (@quotient.mk.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2) (@prod.snd.{v v} β β p)))
             (@uniformity.{v} β _inst_2))))
    (@uniformity.{w} γ _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
_inst_3 : uniform_space.{w} γ,
f : α → β → γ,
h :
  ∀ (a : α) (c : β) (b : α) (d : β),
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@separation_rel.{u} α _inst_1) →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β c d)
      (@separation_rel.{v} β _inst_2) →
    @eq.{w+1} γ (f a c) (f b d),
hf :
  @uniform_continuous.{(max u v) w} (prod.{u v} α β) γ (@prod.uniform_space.{u v} α β _inst_1 _inst_2) _inst_3
    (λ (p : prod.{u v} α β), f (@prod.fst.{u v} α β p) (@prod.snd.{u v} α β p))
⊢ @filter.tendsto.{(max u v) w}
    (prod.{(max u v) (max u v)}
       (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
       (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
    (prod.{w w} γ γ)
    (λ
     (x :
       prod.{(max u v) (max u v)}
         (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
            (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
         (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
            (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))),
       @prod.mk.{w w} γ γ
         (@quotient.lift₂.{u+1 v+1 w+1} α β γ (@uniform_space.separation_setoid.{u} α _inst_1)
            (@uniform_space.separation_setoid.{v} β _inst_2)
            f
            h
            (@prod.fst.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@prod.fst.{(max u v) (max u v)}
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  x))
            (@prod.snd.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@prod.fst.{(max u v) (max u v)}
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  x)))
         (@quotient.lift₂.{u+1 v+1 w+1} α β γ (@uniform_space.separation_setoid.{u} α _inst_1)
            (@uniform_space.separation_setoid.{v} β _inst_2)
            f
            h
            (@prod.fst.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@prod.snd.{(max u v) (max u v)}
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  x))
            (@prod.snd.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@prod.snd.{(max u v) (max u v)}
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                  x))))
    (@filter.map.{(max u v) (max u v)}
       (prod.{u v}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
          (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
             (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
       (prod.{(max u v) (max u v)}
          (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
             (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
          (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
             (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
       (λ
        (p :
          prod.{u v}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
            (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))),
          @prod.mk.{(max u v) (max u v)}
            (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
            (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
            (@prod.mk.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@prod.fst.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@prod.fst.{u v}
                     (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                        (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                     (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                        (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                     p))
               (@prod.fst.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@prod.snd.{u v}
                     (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                        (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                     (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                        (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                     p)))
            (@prod.mk.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@prod.snd.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@prod.fst.{u v}
                     (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                        (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                     (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                        (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                     p))
               (@prod.snd.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@prod.snd.{u v}
                     (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                        (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                     (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                        (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                     p))))
       (@filter.map.{(max u v) (max u v)} (prod.{u v} (prod.{u u} α α) (prod.{v v} β β))
          (prod.{u v}
             (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
             (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
          (λ (p : prod.{u v} (prod.{u u} α α) (prod.{v v} β β)),
             @prod.mk.{u v}
               (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
               (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
               (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)
                     (@prod.fst.{u u} α α (@prod.fst.{u v} (prod.{u u} α α) (prod.{v v} β β) p)))
                  (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)
                     (@prod.snd.{u u} α α (@prod.fst.{u v} (prod.{u u} α α) (prod.{v v} β β) p))))
               (@prod.mk.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@quotient.mk.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)
                     (@prod.fst.{v v} β β (@prod.snd.{u v} (prod.{u u} α α) (prod.{v v} β β) p)))
                  (@quotient.mk.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)
                     (@prod.snd.{v v} β β (@prod.snd.{u v} (prod.{u u} α α) (prod.{v v} β β) p)))))
          (@filter.prod.{u v} (prod.{u u} α α) (prod.{v v} β β) (@uniformity.{u} α _inst_1)
             (@uniformity.{v} β _inst_2))))
    (@uniformity.{w} γ _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
_inst_3 : uniform_space.{w} γ,
f : α → β → γ,
h :
  ∀ (a : α) (c : β) (b : α) (d : β),
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@separation_rel.{u} α _inst_1) →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β c d)
      (@separation_rel.{v} β _inst_2) →
    @eq.{w+1} γ (f a c) (f b d),
hf :
  @uniform_continuous.{(max u v) w} (prod.{u v} α β) γ (@prod.uniform_space.{u v} α β _inst_1 _inst_2) _inst_3
    (λ (p : prod.{u v} α β), f (@prod.fst.{u v} α β p) (@prod.snd.{u v} α β p))
⊢ @filter.tendsto.{(max u v) w}
    (prod.{u v}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
       (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
          (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
    (prod.{w w} γ γ)
    (@function.comp.{(max u v)+1 (max u v)+1 w+1}
       (prod.{u v}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
          (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
             (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
       (prod.{(max u v) (max u v)}
          (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
             (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
          (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
             (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
       (prod.{w w} γ γ)
       (λ
        (x :
          prod.{(max u v) (max u v)}
            (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
            (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))),
          @prod.mk.{w w} γ γ
            (@quotient.lift₂.{u+1 v+1 w+1} α β γ (@uniform_space.separation_setoid.{u} α _inst_1)
               (@uniform_space.separation_setoid.{v} β _inst_2)
               f
               h
               (@prod.fst.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@prod.fst.{(max u v) (max u v)}
                     (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                        (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                     (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                        (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                     x))
               (@prod.snd.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@prod.fst.{(max u v) (max u v)}
                     (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                        (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                     (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                        (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                     x)))
            (@quotient.lift₂.{u+1 v+1 w+1} α β γ (@uniform_space.separation_setoid.{u} α _inst_1)
               (@uniform_space.separation_setoid.{v} β _inst_2)
               f
               h
               (@prod.fst.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@prod.snd.{(max u v) (max u v)}
                     (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                        (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                     (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                        (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                     x))
               (@prod.snd.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@prod.snd.{(max u v) (max u v)}
                     (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                        (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                     (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                        (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                     x))))
       (λ
        (p :
          prod.{u v}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
            (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))),
          @prod.mk.{(max u v) (max u v)}
            (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
            (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
            (@prod.mk.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@prod.fst.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@prod.fst.{u v}
                     (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                        (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                     (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                        (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                     p))
               (@prod.fst.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@prod.snd.{u v}
                     (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                        (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                     (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                        (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                     p)))
            (@prod.mk.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@prod.snd.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@prod.fst.{u v}
                     (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                        (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                     (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                        (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                     p))
               (@prod.snd.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@prod.snd.{u v}
                     (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                        (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                     (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                        (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                     p)))))
    (@filter.map.{(max u v) (max u v)} (prod.{u v} (prod.{u u} α α) (prod.{v v} β β))
       (prod.{u v}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
          (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
             (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
       (λ (p : prod.{u v} (prod.{u u} α α) (prod.{v v} β β)),
          @prod.mk.{u v}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
            (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
            (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)
                  (@prod.fst.{u u} α α (@prod.fst.{u v} (prod.{u u} α α) (prod.{v v} β β) p)))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)
                  (@prod.snd.{u u} α α (@prod.fst.{u v} (prod.{u u} α α) (prod.{v v} β β) p))))
            (@prod.mk.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@quotient.mk.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)
                  (@prod.fst.{v v} β β (@prod.snd.{u v} (prod.{u u} α α) (prod.{v v} β β) p)))
               (@quotient.mk.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)
                  (@prod.snd.{v v} β β (@prod.snd.{u v} (prod.{u u} α α) (prod.{v v} β β) p)))))
       (@filter.prod.{u v} (prod.{u u} α α) (prod.{v v} β β) (@uniformity.{u} α _inst_1)
          (@uniformity.{v} β _inst_2)))
    (@uniformity.{w} γ _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
_inst_3 : uniform_space.{w} γ,
f : α → β → γ,
h :
  ∀ (a : α) (c : β) (b : α) (d : β),
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@separation_rel.{u} α _inst_1) →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β c d)
      (@separation_rel.{v} β _inst_2) →
    @eq.{w+1} γ (f a c) (f b d),
hf :
  @uniform_continuous.{(max u v) w} (prod.{u v} α β) γ (@prod.uniform_space.{u v} α β _inst_1 _inst_2) _inst_3
    (λ (p : prod.{u v} α β), f (@prod.fst.{u v} α β p) (@prod.snd.{u v} α β p))
⊢ @filter.tendsto.{(max u v) w} (prod.{u v} (prod.{u u} α α) (prod.{v v} β β)) (prod.{w w} γ γ)
    (@function.comp.{(max u v)+1 (max u v)+1 w+1} (prod.{u v} (prod.{u u} α α) (prod.{v v} β β))
       (prod.{u v}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
          (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
             (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
       (prod.{w w} γ γ)
       (@function.comp.{(max u v)+1 (max u v)+1 w+1}
          (prod.{u v}
             (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
             (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
          (prod.{(max u v) (max u v)}
             (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
             (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
          (prod.{w w} γ γ)
          (λ
           (x :
             prod.{(max u v) (max u v)}
               (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
               (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))),
             @prod.mk.{w w} γ γ
               (@quotient.lift₂.{u+1 v+1 w+1} α β γ (@uniform_space.separation_setoid.{u} α _inst_1)
                  (@uniform_space.separation_setoid.{v} β _inst_2)
                  f
                  h
                  (@prod.fst.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@prod.fst.{(max u v) (max u v)}
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        x))
                  (@prod.snd.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@prod.fst.{(max u v) (max u v)}
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        x)))
               (@quotient.lift₂.{u+1 v+1 w+1} α β γ (@uniform_space.separation_setoid.{u} α _inst_1)
                  (@uniform_space.separation_setoid.{v} β _inst_2)
                  f
                  h
                  (@prod.fst.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@prod.snd.{(max u v) (max u v)}
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        x))
                  (@prod.snd.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@prod.snd.{(max u v) (max u v)}
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        x))))
          (λ
           (p :
             prod.{u v}
               (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
               (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))),
             @prod.mk.{(max u v) (max u v)}
               (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
               (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
               (@prod.mk.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@prod.fst.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@prod.fst.{u v}
                        (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                        (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        p))
                  (@prod.fst.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@prod.snd.{u v}
                        (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                        (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        p)))
               (@prod.mk.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@prod.snd.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@prod.fst.{u v}
                        (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                        (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        p))
                  (@prod.snd.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@prod.snd.{u v}
                        (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                        (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        p)))))
       (λ (p : prod.{u v} (prod.{u u} α α) (prod.{v v} β β)),
          @prod.mk.{u v}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
            (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
            (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)
                  (@prod.fst.{u u} α α (@prod.fst.{u v} (prod.{u u} α α) (prod.{v v} β β) p)))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)
                  (@prod.snd.{u u} α α (@prod.fst.{u v} (prod.{u u} α α) (prod.{v v} β β) p))))
            (@prod.mk.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@quotient.mk.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)
                  (@prod.fst.{v v} β β (@prod.snd.{u v} (prod.{u u} α α) (prod.{v v} β β) p)))
               (@quotient.mk.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)
                  (@prod.snd.{v v} β β (@prod.snd.{u v} (prod.{u u} α α) (prod.{v v} β β) p))))))
    (@filter.prod.{u v} (prod.{u u} α α) (prod.{v v} β β) (@uniformity.{u} α _inst_1) (@uniformity.{v} β _inst_2))
    (@uniformity.{w} γ _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>174    rwa [uniform_continuous, uniformity_prod_eq_prod, filter.tendsto_map&#x27;_iff] at hf</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniformity_prod_eq_prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.tendsto_map&#x27;_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 427, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 687, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1415, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : uniform_space.{?l_1} α] [_inst_2 : uniform_space.{?l_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : uniform_space.{u} α] [_inst_2 : uniform_space.{v} β], @eq.{(max u v)+1} (filter.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))) (@uniformity.{(max u v)} (prod.{u v} α β) (@prod.uniform_space.{u v} α β _inst_1 _inst_2)) (@filter.map.{(max u v) (max u v)} (prod.{u v} (prod.{u u} α α) (prod.{v v} β β)) (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (λ (p : prod.{u v} (prod.{u u} α α) (prod.{v v} β β)), @prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) (@prod.mk.{u v} α β (@prod.fst.{u u} α α (@prod.fst.{u v} (prod.{u u} α α) (prod.{v v} β β) p)) (@prod.fst.{v v} β β (@prod.snd.{u v} (prod.{u u} α α) (prod.{v v} β β) p))) (@prod.mk.{u v} α β (@prod.snd.{u u} α α (@prod.fst.{u v} (prod.{u u} α α) (prod.{v v} β β) p)) (@prod.snd.{v v} β β (@prod.snd.{u v} (prod.{u u} α α) (prod.{v v} β β) p)))) (@filter.prod.{u v} (prod.{u u} α α) (prod.{v v} β β) (@uniformity.{u} α _inst_1) (@uniformity.{v} β _inst_2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type (max u v)} {γ : Type w} {f : β → γ} {g : α → β} {x : filter.{(max u v)} α} {y : filter.{w} γ}, iff (@filter.tendsto.{(max u v) w} β γ f (@filter.map.{(max u v) (max u v)} α β g x) y) (@filter.tendsto.{(max u v) w} α γ (@function.comp.{(max u v)+1 (max u v)+1 w+1} α β γ f g) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
_inst_3 : uniform_space.{w} γ,
f : α → β → γ,
h :
  ∀ (a : α) (c : β) (b : α) (d : β),
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@separation_rel.{u} α _inst_1) →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β c d)
      (@separation_rel.{v} β _inst_2) →
    @eq.{w+1} γ (f a c) (f b d),
hf :
  @uniform_continuous.{(max u v) w} (prod.{u v} α β) γ (@prod.uniform_space.{u v} α β _inst_1 _inst_2) _inst_3
    (λ (p : prod.{u v} α β), f (@prod.fst.{u v} α β p) (@prod.snd.{u v} α β p))
⊢ @filter.tendsto.{(max u v) w} (prod.{u v} (prod.{u u} α α) (prod.{v v} β β)) (prod.{w w} γ γ)
    (@function.comp.{(max u v)+1 (max u v)+1 w+1} (prod.{u v} (prod.{u u} α α) (prod.{v v} β β))
       (prod.{u v}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
          (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
             (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
       (prod.{w w} γ γ)
       (@function.comp.{(max u v)+1 (max u v)+1 w+1}
          (prod.{u v}
             (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
             (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
          (prod.{(max u v) (max u v)}
             (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
             (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
          (prod.{w w} γ γ)
          (λ
           (x :
             prod.{(max u v) (max u v)}
               (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
               (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))),
             @prod.mk.{w w} γ γ
               (@quotient.lift₂.{u+1 v+1 w+1} α β γ (@uniform_space.separation_setoid.{u} α _inst_1)
                  (@uniform_space.separation_setoid.{v} β _inst_2)
                  f
                  h
                  (@prod.fst.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@prod.fst.{(max u v) (max u v)}
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        x))
                  (@prod.snd.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@prod.fst.{(max u v) (max u v)}
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        x)))
               (@quotient.lift₂.{u+1 v+1 w+1} α β γ (@uniform_space.separation_setoid.{u} α _inst_1)
                  (@uniform_space.separation_setoid.{v} β _inst_2)
                  f
                  h
                  (@prod.fst.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@prod.snd.{(max u v) (max u v)}
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        x))
                  (@prod.snd.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@prod.snd.{(max u v) (max u v)}
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        x))))
          (λ
           (p :
             prod.{u v}
               (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
               (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))),
             @prod.mk.{(max u v) (max u v)}
               (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
               (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
               (@prod.mk.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@prod.fst.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@prod.fst.{u v}
                        (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                        (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        p))
                  (@prod.fst.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@prod.snd.{u v}
                        (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                        (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        p)))
               (@prod.mk.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@prod.snd.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@prod.fst.{u v}
                        (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                        (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        p))
                  (@prod.snd.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@prod.snd.{u v}
                        (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                        (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        p)))))
       (λ (p : prod.{u v} (prod.{u u} α α) (prod.{v v} β β)),
          @prod.mk.{u v}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
            (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
            (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)
                  (@prod.fst.{u u} α α (@prod.fst.{u v} (prod.{u u} α α) (prod.{v v} β β) p)))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)
                  (@prod.snd.{u u} α α (@prod.fst.{u v} (prod.{u u} α α) (prod.{v v} β β) p))))
            (@prod.mk.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@quotient.mk.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)
                  (@prod.fst.{v v} β β (@prod.snd.{u v} (prod.{u u} α α) (prod.{v v} β β) p)))
               (@quotient.mk.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)
                  (@prod.snd.{v v} β β (@prod.snd.{u v} (prod.{u u} α α) (prod.{v v} β β) p))))))
    (@filter.prod.{u v} (prod.{u u} α α) (prod.{v v} β β) (@uniformity.{u} α _inst_1) (@uniformity.{v} β _inst_2))
    (@uniformity.{w} γ _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
_inst_3 : uniform_space.{w} γ,
f : α → β → γ,
h :
  ∀ (a : α) (c : β) (b : α) (d : β),
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@separation_rel.{u} α _inst_1) →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β c d)
      (@separation_rel.{v} β _inst_2) →
    @eq.{w+1} γ (f a c) (f b d),
hf :
  @filter.tendsto.{(max u v) w} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{w w} γ γ)
    (λ (x : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
       @prod.mk.{w w} γ γ
         (f (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) x))
            (@prod.snd.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) x)))
         (f (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) x))
            (@prod.snd.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) x))))
    (@uniformity.{(max u v)} (prod.{u v} α β) (@prod.uniform_space.{u v} α β _inst_1 _inst_2))
    (@uniformity.{w} γ _inst_3)
⊢ @filter.tendsto.{(max u v) w} (prod.{u v} (prod.{u u} α α) (prod.{v v} β β)) (prod.{w w} γ γ)
    (@function.comp.{(max u v)+1 (max u v)+1 w+1} (prod.{u v} (prod.{u u} α α) (prod.{v v} β β))
       (prod.{u v}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
          (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
             (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
       (prod.{w w} γ γ)
       (@function.comp.{(max u v)+1 (max u v)+1 w+1}
          (prod.{u v}
             (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
             (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
          (prod.{(max u v) (max u v)}
             (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
             (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
          (prod.{w w} γ γ)
          (λ
           (x :
             prod.{(max u v) (max u v)}
               (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
               (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))),
             @prod.mk.{w w} γ γ
               (@quotient.lift₂.{u+1 v+1 w+1} α β γ (@uniform_space.separation_setoid.{u} α _inst_1)
                  (@uniform_space.separation_setoid.{v} β _inst_2)
                  f
                  h
                  (@prod.fst.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@prod.fst.{(max u v) (max u v)}
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        x))
                  (@prod.snd.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@prod.fst.{(max u v) (max u v)}
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        x)))
               (@quotient.lift₂.{u+1 v+1 w+1} α β γ (@uniform_space.separation_setoid.{u} α _inst_1)
                  (@uniform_space.separation_setoid.{v} β _inst_2)
                  f
                  h
                  (@prod.fst.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@prod.snd.{(max u v) (max u v)}
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        x))
                  (@prod.snd.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@prod.snd.{(max u v) (max u v)}
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        x))))
          (λ
           (p :
             prod.{u v}
               (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
               (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))),
             @prod.mk.{(max u v) (max u v)}
               (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
               (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
               (@prod.mk.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@prod.fst.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@prod.fst.{u v}
                        (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                        (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        p))
                  (@prod.fst.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@prod.snd.{u v}
                        (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                        (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        p)))
               (@prod.mk.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@prod.snd.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@prod.fst.{u v}
                        (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                        (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        p))
                  (@prod.snd.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@prod.snd.{u v}
                        (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                        (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        p)))))
       (λ (p : prod.{u v} (prod.{u u} α α) (prod.{v v} β β)),
          @prod.mk.{u v}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
            (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
            (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)
                  (@prod.fst.{u u} α α (@prod.fst.{u v} (prod.{u u} α α) (prod.{v v} β β) p)))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)
                  (@prod.snd.{u u} α α (@prod.fst.{u v} (prod.{u u} α α) (prod.{v v} β β) p))))
            (@prod.mk.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@quotient.mk.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)
                  (@prod.fst.{v v} β β (@prod.snd.{u v} (prod.{u u} α α) (prod.{v v} β β) p)))
               (@quotient.mk.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)
                  (@prod.snd.{v v} β β (@prod.snd.{u v} (prod.{u u} α α) (prod.{v v} β β) p))))))
    (@filter.prod.{u v} (prod.{u u} α α) (prod.{v v} β β) (@uniformity.{u} α _inst_1) (@uniformity.{v} β _inst_2))
    (@uniformity.{w} γ _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
_inst_3 : uniform_space.{w} γ,
f : α → β → γ,
h :
  ∀ (a : α) (c : β) (b : α) (d : β),
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@separation_rel.{u} α _inst_1) →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β c d)
      (@separation_rel.{v} β _inst_2) →
    @eq.{w+1} γ (f a c) (f b d),
hf :
  @filter.tendsto.{(max u v) w} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{w w} γ γ)
    (λ (x : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
       @prod.mk.{w w} γ γ
         (f (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) x))
            (@prod.snd.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) x)))
         (f (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) x))
            (@prod.snd.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) x))))
    (@filter.map.{(max u v) (max u v)} (prod.{u v} (prod.{u u} α α) (prod.{v v} β β))
       (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))
       (λ (p : prod.{u v} (prod.{u u} α α) (prod.{v v} β β)),
          @prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)
            (@prod.mk.{u v} α β (@prod.fst.{u u} α α (@prod.fst.{u v} (prod.{u u} α α) (prod.{v v} β β) p))
               (@prod.fst.{v v} β β (@prod.snd.{u v} (prod.{u u} α α) (prod.{v v} β β) p)))
            (@prod.mk.{u v} α β (@prod.snd.{u u} α α (@prod.fst.{u v} (prod.{u u} α α) (prod.{v v} β β) p))
               (@prod.snd.{v v} β β (@prod.snd.{u v} (prod.{u u} α α) (prod.{v v} β β) p))))
       (@filter.prod.{u v} (prod.{u u} α α) (prod.{v v} β β) (@uniformity.{u} α _inst_1)
          (@uniformity.{v} β _inst_2)))
    (@uniformity.{w} γ _inst_3)
⊢ @filter.tendsto.{(max u v) w} (prod.{u v} (prod.{u u} α α) (prod.{v v} β β)) (prod.{w w} γ γ)
    (@function.comp.{(max u v)+1 (max u v)+1 w+1} (prod.{u v} (prod.{u u} α α) (prod.{v v} β β))
       (prod.{u v}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
          (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
             (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
       (prod.{w w} γ γ)
       (@function.comp.{(max u v)+1 (max u v)+1 w+1}
          (prod.{u v}
             (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
             (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
          (prod.{(max u v) (max u v)}
             (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
             (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
          (prod.{w w} γ γ)
          (λ
           (x :
             prod.{(max u v) (max u v)}
               (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
               (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))),
             @prod.mk.{w w} γ γ
               (@quotient.lift₂.{u+1 v+1 w+1} α β γ (@uniform_space.separation_setoid.{u} α _inst_1)
                  (@uniform_space.separation_setoid.{v} β _inst_2)
                  f
                  h
                  (@prod.fst.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@prod.fst.{(max u v) (max u v)}
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        x))
                  (@prod.snd.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@prod.fst.{(max u v) (max u v)}
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        x)))
               (@quotient.lift₂.{u+1 v+1 w+1} α β γ (@uniform_space.separation_setoid.{u} α _inst_1)
                  (@uniform_space.separation_setoid.{v} β _inst_2)
                  f
                  h
                  (@prod.fst.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@prod.snd.{(max u v) (max u v)}
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        x))
                  (@prod.snd.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@prod.snd.{(max u v) (max u v)}
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        x))))
          (λ
           (p :
             prod.{u v}
               (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
               (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))),
             @prod.mk.{(max u v) (max u v)}
               (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
               (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
               (@prod.mk.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@prod.fst.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@prod.fst.{u v}
                        (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                        (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        p))
                  (@prod.fst.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@prod.snd.{u v}
                        (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                        (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        p)))
               (@prod.mk.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@prod.snd.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@prod.fst.{u v}
                        (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                        (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        p))
                  (@prod.snd.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@prod.snd.{u v}
                        (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                        (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        p)))))
       (λ (p : prod.{u v} (prod.{u u} α α) (prod.{v v} β β)),
          @prod.mk.{u v}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
            (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
            (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)
                  (@prod.fst.{u u} α α (@prod.fst.{u v} (prod.{u u} α α) (prod.{v v} β β) p)))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)
                  (@prod.snd.{u u} α α (@prod.fst.{u v} (prod.{u u} α α) (prod.{v v} β β) p))))
            (@prod.mk.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@quotient.mk.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)
                  (@prod.fst.{v v} β β (@prod.snd.{u v} (prod.{u u} α α) (prod.{v v} β β) p)))
               (@quotient.mk.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)
                  (@prod.snd.{v v} β β (@prod.snd.{u v} (prod.{u u} α α) (prod.{v v} β β) p))))))
    (@filter.prod.{u v} (prod.{u u} α α) (prod.{v v} β β) (@uniformity.{u} α _inst_1) (@uniformity.{v} β _inst_2))
    (@uniformity.{w} γ _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
_inst_3 : uniform_space.{w} γ,
f : α → β → γ,
h :
  ∀ (a : α) (c : β) (b : α) (d : β),
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@separation_rel.{u} α _inst_1) →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β c d)
      (@separation_rel.{v} β _inst_2) →
    @eq.{w+1} γ (f a c) (f b d),
hf :
  @filter.tendsto.{(max u v) w} (prod.{u v} (prod.{u u} α α) (prod.{v v} β β)) (prod.{w w} γ γ)
    (@function.comp.{(max u v)+1 (max u v)+1 w+1} (prod.{u v} (prod.{u u} α α) (prod.{v v} β β))
       (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))
       (prod.{w w} γ γ)
       (λ (x : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
          @prod.mk.{w w} γ γ
            (f (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) x))
               (@prod.snd.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) x)))
            (f (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) x))
               (@prod.snd.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) x))))
       (λ (p : prod.{u v} (prod.{u u} α α) (prod.{v v} β β)),
          @prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)
            (@prod.mk.{u v} α β (@prod.fst.{u u} α α (@prod.fst.{u v} (prod.{u u} α α) (prod.{v v} β β) p))
               (@prod.fst.{v v} β β (@prod.snd.{u v} (prod.{u u} α α) (prod.{v v} β β) p)))
            (@prod.mk.{u v} α β (@prod.snd.{u u} α α (@prod.fst.{u v} (prod.{u u} α α) (prod.{v v} β β) p))
               (@prod.snd.{v v} β β (@prod.snd.{u v} (prod.{u u} α α) (prod.{v v} β β) p)))))
    (@filter.prod.{u v} (prod.{u u} α α) (prod.{v v} β β) (@uniformity.{u} α _inst_1) (@uniformity.{v} β _inst_2))
    (@uniformity.{w} γ _inst_3)
⊢ @filter.tendsto.{(max u v) w} (prod.{u v} (prod.{u u} α α) (prod.{v v} β β)) (prod.{w w} γ γ)
    (@function.comp.{(max u v)+1 (max u v)+1 w+1} (prod.{u v} (prod.{u u} α α) (prod.{v v} β β))
       (prod.{u v}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
          (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
             (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
       (prod.{w w} γ γ)
       (@function.comp.{(max u v)+1 (max u v)+1 w+1}
          (prod.{u v}
             (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
             (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
          (prod.{(max u v) (max u v)}
             (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
             (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
          (prod.{w w} γ γ)
          (λ
           (x :
             prod.{(max u v) (max u v)}
               (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
               (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))),
             @prod.mk.{w w} γ γ
               (@quotient.lift₂.{u+1 v+1 w+1} α β γ (@uniform_space.separation_setoid.{u} α _inst_1)
                  (@uniform_space.separation_setoid.{v} β _inst_2)
                  f
                  h
                  (@prod.fst.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@prod.fst.{(max u v) (max u v)}
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        x))
                  (@prod.snd.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@prod.fst.{(max u v) (max u v)}
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        x)))
               (@quotient.lift₂.{u+1 v+1 w+1} α β γ (@uniform_space.separation_setoid.{u} α _inst_1)
                  (@uniform_space.separation_setoid.{v} β _inst_2)
                  f
                  h
                  (@prod.fst.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@prod.snd.{(max u v) (max u v)}
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        x))
                  (@prod.snd.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@prod.snd.{(max u v) (max u v)}
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        x))))
          (λ
           (p :
             prod.{u v}
               (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
               (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))),
             @prod.mk.{(max u v) (max u v)}
               (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
               (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
               (@prod.mk.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@prod.fst.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@prod.fst.{u v}
                        (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                        (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        p))
                  (@prod.fst.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@prod.snd.{u v}
                        (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                        (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        p)))
               (@prod.mk.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@prod.snd.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@prod.fst.{u v}
                        (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                        (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        p))
                  (@prod.snd.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@prod.snd.{u v}
                        (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                        (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        p)))))
       (λ (p : prod.{u v} (prod.{u u} α α) (prod.{v v} β β)),
          @prod.mk.{u v}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
            (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
            (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)
                  (@prod.fst.{u u} α α (@prod.fst.{u v} (prod.{u u} α α) (prod.{v v} β β) p)))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)
                  (@prod.snd.{u u} α α (@prod.fst.{u v} (prod.{u u} α α) (prod.{v v} β β) p))))
            (@prod.mk.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@quotient.mk.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)
                  (@prod.fst.{v v} β β (@prod.snd.{u v} (prod.{u u} α α) (prod.{v v} β β) p)))
               (@quotient.mk.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)
                  (@prod.snd.{v v} β β (@prod.snd.{u v} (prod.{u u} α α) (prod.{v v} β β) p))))))
    (@filter.prod.{u v} (prod.{u u} α α) (prod.{v v} β β) (@uniformity.{u} α _inst_1) (@uniformity.{v} β _inst_2))
    (@uniformity.{w} γ _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
_inst_3 : uniform_space.{w} γ,
f : α → β → γ,
h :
  ∀ (a : α) (c : β) (b : α) (d : β),
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@separation_rel.{u} α _inst_1) →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β c d)
      (@separation_rel.{v} β _inst_2) →
    @eq.{w+1} γ (f a c) (f b d),
hf :
  @uniform_continuous.{(max u v) w} (prod.{u v} α β) γ (@prod.uniform_space.{u v} α β _inst_1 _inst_2) _inst_3
    (λ (p : prod.{u v} α β), f (@prod.fst.{u v} α β p) (@prod.snd.{u v} α β p))
⊢ @filter.tendsto.{(max u v) w} (prod.{u v} (prod.{u u} α α) (prod.{v v} β β)) (prod.{w w} γ γ)
    (@function.comp.{(max u v)+1 (max u v)+1 w+1} (prod.{u v} (prod.{u u} α α) (prod.{v v} β β))
       (prod.{u v}
          (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
             (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
          (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
             (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
       (prod.{w w} γ γ)
       (@function.comp.{(max u v)+1 (max u v)+1 w+1}
          (prod.{u v}
             (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
             (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
          (prod.{(max u v) (max u v)}
             (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
             (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))))
          (prod.{w w} γ γ)
          (λ
           (x :
             prod.{(max u v) (max u v)}
               (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
               (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))),
             @prod.mk.{w w} γ γ
               (@quotient.lift₂.{u+1 v+1 w+1} α β γ (@uniform_space.separation_setoid.{u} α _inst_1)
                  (@uniform_space.separation_setoid.{v} β _inst_2)
                  f
                  h
                  (@prod.fst.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@prod.fst.{(max u v) (max u v)}
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        x))
                  (@prod.snd.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@prod.fst.{(max u v) (max u v)}
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        x)))
               (@quotient.lift₂.{u+1 v+1 w+1} α β γ (@uniform_space.separation_setoid.{u} α _inst_1)
                  (@uniform_space.separation_setoid.{v} β _inst_2)
                  f
                  h
                  (@prod.fst.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@prod.snd.{(max u v) (max u v)}
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        x))
                  (@prod.snd.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@prod.snd.{(max u v) (max u v)}
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        x))))
          (λ
           (p :
             prod.{u v}
               (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
               (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))),
             @prod.mk.{(max u v) (max u v)}
               (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
               (prod.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
               (@prod.mk.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@prod.fst.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@prod.fst.{u v}
                        (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                        (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        p))
                  (@prod.fst.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@prod.snd.{u v}
                        (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                        (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        p)))
               (@prod.mk.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                  (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                  (@prod.snd.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                     (@prod.fst.{u v}
                        (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                        (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        p))
                  (@prod.snd.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                     (@prod.snd.{u v}
                        (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
                           (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
                        (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
                           (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
                        p)))))
       (λ (p : prod.{u v} (prod.{u u} α α) (prod.{v v} β β)),
          @prod.mk.{u v}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
            (prod.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)))
            (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)
                  (@prod.fst.{u u} α α (@prod.fst.{u v} (prod.{u u} α α) (prod.{v v} β β) p)))
               (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)
                  (@prod.snd.{u u} α α (@prod.fst.{u v} (prod.{u u} α α) (prod.{v v} β β) p))))
            (@prod.mk.{v v} (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
               (@quotient.mk.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)
                  (@prod.fst.{v v} β β (@prod.snd.{u v} (prod.{u u} α α) (prod.{v v} β β) p)))
               (@quotient.mk.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)
                  (@prod.snd.{v v} β β (@prod.snd.{u v} (prod.{u u} α α) (prod.{v v} β β) p))))))
    (@filter.prod.{u v} (prod.{u u} α α) (prod.{v v} β β) (@uniformity.{u} α _inst_1) (@uniformity.{v} β _inst_2))
    (@uniformity.{w} γ _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>175  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>176  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>177  lemma comap_quotient_le_uniformity :</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>178    (𝓤 $ quotient $ separation_setoid α).comap (λ (p : α × α), (⟦p.fst⟧, ⟦p.snd⟧)) ≤ (𝓤 α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='quotient'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='uniform_space.separation_setoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 88, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 102, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 803, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u) [_inst_2 : uniform_space.{u} α], filter.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Sort u}, setoid.{u} α → Sort u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u) [_inst_4 : uniform_space.{u} α], setoid.{u+1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u}, (α → β) → filter.{u} β → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='prod.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='prod.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} [c : has_le.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u) [_inst_2 : uniform_space.{u} α], filter.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='The inverse map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>179  assume t&#x27; ht&#x27;,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='t&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ht&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) t&#x27; (@uniformity.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>180  let ⟨t, ht, tt_t&#x27;⟩ := comp_mem_uniformity_sets ht&#x27; in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ht'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='tt_t&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='comp_mem_uniformity_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ht&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{u+1} (set.{u} (prod.{u u} α α)) (λ (t : set.{u} (prod.{u u} α α)), @Exists.{0} (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) t (@uniformity.{u} α _inst_1)) (λ (H : @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) t (@uniformity.{u} α _inst_1)), @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α)) (@comp_rel.{u} α t t) t&#x27;)) → @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) t&#x27; (@filter.comap.{u u} (prod.{u u} α α) (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))) (λ (p : prod.{u u} α α), @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.fst.{u u} α α p)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.snd.{u u} α α p))) (@uniformity.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@uniform_space.separation_setoid.uniform_space.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) t (@uniformity.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α)) (@comp_rel.{u} α t t) t&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : uniform_space.{u} α] {s : set.{u} (prod.{u u} α α)}, @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) s (@uniformity.{u} α _inst_1) → @Exists.{u+1} (set.{u} (prod.{u u} α α)) (λ (t : set.{u} (prod.{u u} α α)), @Exists.{0} (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) t (@uniformity.{u} α _inst_1)) (λ (H : @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) t (@uniformity.{u} α _inst_1)), @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α)) (@comp_rel.{u} α t t) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) t&#x27; (@uniformity.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>181  let ⟨s, hs, ss_t⟩ := comp_mem_uniformity_sets ht in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ss_t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='comp_mem_uniformity_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{u+1} (set.{u} (prod.{u u} α α)) (λ (t_1 : set.{u} (prod.{u u} α α)), @Exists.{0} (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) t_1 (@uniformity.{u} α _inst_1)) (λ (H : @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) t_1 (@uniformity.{u} α _inst_1)), @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α)) (@comp_rel.{u} α t_1 t_1) t)) → @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) t&#x27; (@filter.comap.{u u} (prod.{u u} α α) (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))) (λ (p : prod.{u u} α α), @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.fst.{u u} α α p)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.snd.{u u} α α p))) (@uniformity.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@uniform_space.separation_setoid.uniform_space.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) s (@uniformity.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α)) (@comp_rel.{u} α s s) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : uniform_space.{u} α] {s : set.{u} (prod.{u u} α α)}, @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) s (@uniformity.{u} α _inst_1) → @Exists.{u+1} (set.{u} (prod.{u u} α α)) (λ (t : set.{u} (prod.{u u} α α)), @Exists.{0} (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) t (@uniformity.{u} α _inst_1)) (λ (H : @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) t (@uniformity.{u} α _inst_1)), @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α)) (@comp_rel.{u} α t t) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>182  ⟨(λp:α×α, (⟦p.1⟧, ⟦p.2⟧)) &#x27;&#x27; s,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='prod.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='prod.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u}, (α → β) → set.{u} α → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>183    (𝓤 α).sets_of_superset hs $ assume x hx, ⟨x, hx, rfl⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.sets_of_superset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u) [_inst_2 : uniform_space.{u} α], filter.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} (c : filter.{u} α) {x y : set.{u} α}, @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x (@filter.sets.{u} α c) → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) x y → @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) y (@filter.sets.{u} α c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='prod.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='prod.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>184    assume ⟨a₁, a₂⟩ ⟨⟨b₁, b₂⟩, hb, ab_eq⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ab_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='prod.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α a₁ a₂) (@set.preimage.{u u} (prod.{u u} α α) (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))) (λ (p : prod.{u u} α α), @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.fst.{u u} α α p)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.snd.{u u} α α p))) (@set.image.{u u} (prod.{u u} α α) (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))) (λ (p : prod.{u u} α α), @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.fst.{u u} α α p)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.snd.{u u} α α p))) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α b₁ b₂) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@eq.{u+1} (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))) ((λ (p : prod.{u u} α α), @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.fst.{u u} α α p)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.snd.{u u} α α p))) (@prod.mk.{u u} α α b₁ b₂)) ((λ (p : prod.{u u} α α), @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.fst.{u u} α α p)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.snd.{u u} α α p))) (@prod.mk.{u u} α α a₁ a₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>185    have ⟦b₁⟧ = ⟦a₁⟧ ∧ ⟦b₂⟧ = ⟦a₂⟧, from prod.mk.inj ab_eq,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='prod.mk.inj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {α β : Type u} {x₁ : α} {y₁ : β} {x₂ : α} {y₂ : β}, @eq.{u+1} (prod.{u u} α β) (@prod.mk.{u u} α β x₁ y₁) (@prod.mk.{u u} α β x₂ y₂) → and (@eq.{u+1} α x₁ x₂) (@eq.{u+1} β y₁ y₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>186    have b₁ ≈ a₁ ∧ b₂ ≈ a₂, from and.imp quotient.exact quotient.exact this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='has_equiv.equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_equiv.equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='and.imp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='quotient.exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='quotient.exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 326, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 326, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 367, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 211, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 211, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π {α : Type u} [c : has_equiv.{u+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} [c : has_equiv.{u+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='∀ {a b c d : Prop}, (a → c) → (b → d) → and a b → and c d'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [s : setoid.{u+1} α] {a b : α}, @eq.{u+1} (@quotient.{u+1} α s) (@quotient.mk.{u+1} α s a) (@quotient.mk.{u+1} α s b) → @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α s) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [s : setoid.{u+1} α] {a b : α}, @eq.{u+1} (@quotient.{u+1} α s) (@quotient.mk.{u+1} α s a) (@quotient.mk.{u+1} α s b) → @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α s) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='and (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) b₁) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) a₁)) (@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) b₂) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) a₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>187    have ab₁ : (a₁, b₁) ∈ t, from (setoid.symm this.left) t ht,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='setoid.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='and.left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/setoid.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : setoid.{u+1} α] {a b : α}, @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α _inst_1) a b → @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α _inst_1) b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='and (@has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) b₁ a₁) (@has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) b₂ a₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, and a b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>188    have ba₂ : (b₂, a₂) ∈ s, from this.right s hs,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='and.right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='and (@has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) b₁ a₁) (@has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) b₂ a₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, and a b → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>189    tt_t&#x27; ⟨b₁, show ((a₁, a₂).1, b₁) ∈ t, from ab₁,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='ab₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α a₁ b₁) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>190      ss_t ⟨b₂, show ((b₁, a₂).1, b₂) ∈ s, from hb, ba₂⟩⟩⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='ba₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α b₂ a₂) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>191  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>192  lemma comap_quotient_eq_uniformity :</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>193    (𝓤 $ quotient $ separation_setoid α).comap (λ (p : α × α), (⟦p.fst⟧, ⟦p.snd⟧)) = 𝓤 α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='quotient'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='uniform_space.separation_setoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 88, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 102, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 803, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u) [_inst_2 : uniform_space.{u} α], filter.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Sort u}, setoid.{u} α → Sort u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u) [_inst_4 : uniform_space.{u} α], setoid.{u+1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u}, (α → β) → filter.{u} β → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='prod.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='prod.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [_inst_2 : uniform_space.{u} α], filter.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='The inverse map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>194  le_antisymm comap_quotient_le_uniformity le_comap_map</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='le_antisymm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='uniform_space.comap_quotient_le_uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.le_comap_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 177, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 948, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : partial_order.{u} α] {a b : α}, @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a b → @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α _inst_1)) b a → @eq.{u+1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : uniform_space.{u} α], @has_le.le.{u} (filter.{u} (prod.{u u} α α)) (@preorder.to_has_le.{u} (filter.{u} (prod.{u u} α α)) (@partial_order.to_preorder.{u} (filter.{u} (prod.{u u} α α)) (@filter.partial_order.{u} (prod.{u u} α α)))) (@filter.comap.{u u} (prod.{u u} α α) (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))) (λ (p : prod.{u u} α α), @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.fst.{u u} α α p)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.snd.{u u} α α p))) (@uniformity.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@uniform_space.separation_setoid.uniform_space.{u} α _inst_1))) (@uniformity.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α β : Type u} {f : filter.{u} α} {m : α → β}, @has_le.le.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))) f (@filter.comap.{u u} α β m (@filter.map.{u u} α β m f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>195  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>196  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>197  instance separated_separation : separated (quotient (separation_setoid α)) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='separated'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='quotient'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_space.separation_setoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;line&#x27;: 41, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 88, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 102, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Π (α : Type u) [_inst_4 : uniform_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u}, setoid.{u} α → Sort u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u) [_inst_4 : uniform_space.{u} α], setoid.{u+1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>198  set.ext $ assume ⟨a, b⟩, quotient.induction_on₂ a b $ assume a b,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='set.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='quotient.induction_on₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 55, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 178, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a b : set.{u} α}, (∀ (x : α), iff (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x a) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x b)) → @eq.{(max (u+1) 1)} (set.{u} α) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Sort u_a} {β : Sort u_b} [s₁ : setoid.{u_a} α] [s₂ : setoid.{u_b} β] {φ : @quotient.{u_a} α s₁ → @quotient.{u_b} β s₂ → Prop} (q₁ : @quotient.{u_a} α s₁) (q₂ : @quotient.{u_b} β s₂), (∀ (a : α) (b : β), φ (@quotient.mk.{u_a} α s₁ a) (@quotient.mk.{u_b} β s₂ b)) → φ q₁ q₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>199    ⟨assume h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@has_mem.mem.{u u} (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))) (set.{u} (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))) (@set.has_mem.{u} (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))) (@prod.mk.{u u} . (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) . (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) a) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) b)) (@separation_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@uniform_space.separation_setoid.uniform_space.{u} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>200      have a ≈ b, from assume s hs,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_equiv.equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 326, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_equiv.{u+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (set.{u} (set.{u} (prod.{u u} α α))) (@set.has_mem.{u} (set.{u} (prod.{u u} α α))) s (@filter.sets.{u} (prod.{u u} α α) (@uniformity.{u} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>201        have s ∈ (𝓤 $ quotient $ separation_setoid α).comap (λp:(α×α), (⟦p.1⟧, ⟦p.2⟧)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='quotient'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='uniform_space.separation_setoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 88, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 102, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 803, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u) [_inst_2 : uniform_space.{u} α], filter.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Sort u}, setoid.{u} α → Sort u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u) [_inst_4 : uniform_space.{u} α], setoid.{u+1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u}, (α → β) → filter.{u} β → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='prod.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='prod.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='The inverse map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>202          from comap_quotient_le_uniformity hs,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='uniform_space.comap_quotient_le_uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 177, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : uniform_space.{u} α], @has_le.le.{u} (filter.{u} (prod.{u u} α α)) (@preorder.to_has_le.{u} (filter.{u} (prod.{u u} α α)) (@partial_order.to_preorder.{u} (filter.{u} (prod.{u u} α α)) (@filter.partial_order.{u} (prod.{u u} α α)))) (@filter.comap.{u u} (prod.{u u} α α) (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))) (λ (p : prod.{u u} α α), @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.fst.{u u} α α p)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.snd.{u u} α α p))) (@uniformity.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@uniform_space.separation_setoid.uniform_space.{u} α _inst_1))) (@uniformity.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (set.{u} (set.{u} (prod.{u u} α α))) (@set.has_mem.{u} (set.{u} (prod.{u u} α α))) s (@filter.sets.{u} (prod.{u u} α α) (@uniformity.{u} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>203        let ⟨t, ht, hts⟩ := this in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='hts'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) s (@filter.comap.{u u} (prod.{u u} α α) (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))) (λ (p : prod.{u u} α α), @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.fst.{u u} α α p)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.snd.{u u} α α p))) (@uniformity.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@uniform_space.separation_setoid.uniform_space.{u} α _inst_1))) → @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α a b) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α)) (@set.preimage.{u u} (prod.{u u} α α) (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))) (λ (p : prod.{u u} α α), @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.fst.{u u} α α p)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.snd.{u u} α α p))) t) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) s (@filter.comap.{u u} (prod.{u u} α α) (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))) (λ (p : prod.{u u} α α), @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.fst.{u u} α α p)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.snd.{u u} α α p))) (@uniformity.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@uniform_space.separation_setoid.uniform_space.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>204        hts begin dsimp [preimage], exact h t ht end,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ht'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2}, (α → β) → set.{?l_2} β → set.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))) (set.{u} (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))) (@set.has_mem.{u} (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))) (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) a) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) b)) (@separation_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@uniform_space.separation_setoid.uniform_space.{u} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))) (filter.{u} (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))) (@filter.has_mem.{u} (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))) t (@uniformity.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@uniform_space.separation_setoid.uniform_space.{u} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='lime'><a title='α : Type u,
_inst_1 : uniform_space.{u} α,
_x :
  prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
    (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)),
_fun_match :
  ∀
  (_a :
    prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
      (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))),
    iff
      (@has_mem.mem.{u u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))))
         (@set.has_mem.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))))
         _a
         (@separation_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
            (@uniform_space.separation_setoid.uniform_space.{u} α _inst_1)))
      (@has_mem.mem.{u u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))))
         (@set.has_mem.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))))
         _a
         (@id_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))),
a b : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1),
a b : α,
h :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) a)
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) b))
    (@separation_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
       (@uniform_space.separation_setoid.uniform_space.{u} α _inst_1)),
s : set.{u} (prod.{u u} α α),
hs :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (set.{u} (set.{u} (prod.{u u} α α)))
    (@set.has_mem.{u} (set.{u} (prod.{u u} α α)))
    s
    (@filter.sets.{u} (prod.{u u} α α) (@uniformity.{u} α _inst_1)),
this :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    s
    (@filter.comap.{u u} (prod.{u u} α α)
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
       (λ (p : prod.{u u} α α),
          @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
            (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.fst.{u u} α α p))
            (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.snd.{u u} α α p)))
       (@uniformity.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@uniform_space.separation_setoid.uniform_space.{u} α _inst_1))),
_let_match :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    s
    (@filter.comap.{u u} (prod.{u u} α α)
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
       (λ (p : prod.{u u} α α),
          @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
            (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.fst.{u u} α α p))
            (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.snd.{u u} α α p)))
       (@uniformity.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@uniform_space.separation_setoid.uniform_space.{u} α _inst_1))) →
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α a b)
    s,
t :
  set.{u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))))
    t
    (@uniformity.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
       (@uniform_space.separation_setoid.uniform_space.{u} α _inst_1)),
hts :
  @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α))
    (@set.preimage.{u u} (prod.{u u} α α)
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
       (λ (p : prod.{u u} α α),
          @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
            (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.fst.{u u} α α p))
            (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.snd.{u u} α α p)))
       t)
    s
⊢ @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α a b)
    (@set.preimage.{u u} (prod.{u u} α α)
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
       (λ (p : prod.{u u} α α),
          @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
            (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.fst.{u u} α α p))
            (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.snd.{u u} α α p)))
       t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : uniform_space.{u} α,
_x :
  prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
    (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)),
_fun_match :
  ∀
  (_a :
    prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
      (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))),
    iff
      (@has_mem.mem.{u u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))))
         (@set.has_mem.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))))
         _a
         (@separation_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
            (@uniform_space.separation_setoid.uniform_space.{u} α _inst_1)))
      (@has_mem.mem.{u u}
         (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
         (set.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))))
         (@set.has_mem.{u}
            (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
               (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))))
         _a
         (@id_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))),
a b : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1),
a b : α,
h :
  @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) a)
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) b))
    (@separation_rel.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
       (@uniform_space.separation_setoid.uniform_space.{u} α _inst_1)),
s : set.{u} (prod.{u u} α α),
hs :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (set.{u} (set.{u} (prod.{u u} α α)))
    (@set.has_mem.{u} (set.{u} (prod.{u u} α α)))
    s
    (@filter.sets.{u} (prod.{u u} α α) (@uniformity.{u} α _inst_1)),
this :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    s
    (@filter.comap.{u u} (prod.{u u} α α)
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
       (λ (p : prod.{u u} α α),
          @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
            (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.fst.{u u} α α p))
            (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.snd.{u u} α α p)))
       (@uniformity.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@uniform_space.separation_setoid.uniform_space.{u} α _inst_1))),
_let_match :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    s
    (@filter.comap.{u u} (prod.{u u} α α)
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
       (λ (p : prod.{u u} α α),
          @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
            (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.fst.{u u} α α p))
            (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.snd.{u u} α α p)))
       (@uniformity.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@uniform_space.separation_setoid.uniform_space.{u} α _inst_1))) →
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α a b)
    s,
t :
  set.{u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))))
    t
    (@uniformity.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
       (@uniform_space.separation_setoid.uniform_space.{u} α _inst_1)),
hts :
  @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α))
    (@set.preimage.{u u} (prod.{u u} α α)
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
       (λ (p : prod.{u u} α α),
          @prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
            (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
            (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.fst.{u u} α α p))
            (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) (@prod.snd.{u u} α α p)))
       t)
    s
⊢ @has_mem.mem.{u u}
    (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
    (set.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))))
    (@set.has_mem.{u}
       (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
          (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))))
    (@prod.mk.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
       (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) a)
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) b))
    t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>205      show ⟦a⟧ = ⟦b⟧, from quotient.sound this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='quotient.sound'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 98, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {α : Sort u} [s : setoid.{u} α] {a b : α}, @has_equiv.equiv.{u} α (@setoid_has_equiv.{u} α s) a b → @eq.{u} (@quotient.{u} α s) (@quotient.mk.{u} α s a) (@quotient.mk.{u} α s b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>206  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>207    assume heq : ⟦a⟧ = ⟦b⟧, assume h hs,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='set.{u} (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))) (set.{u} (set.{u} (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))))) (@set.has_mem.{u} (set.{u} (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))))) h (@filter.sets.{u} (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))) (@uniformity.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@uniform_space.separation_setoid.uniform_space.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>208    heq ▸ refl_mem_uniformity hs⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='heq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='refl_mem_uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 163, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 167, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@eq.{u+1} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) a) (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {P : α → Prop} {a b : α}, @eq.{u+1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : uniform_space.{u_1} α] {x : α} {s : set.{u_1} (prod.{u_1 u_1} α α)}, @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) s (@uniformity.{u_1} α _inst_1) → @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α x x) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))) (set.{u} (set.{u} (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))))) (@set.has_mem.{u} (set.{u} (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))))) h (@filter.sets.{u} (prod.{u u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))) (@uniformity.{u} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) (@uniform_space.separation_setoid.uniform_space.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>209  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>210  lemma separated_of_uniform_continuous {f : α → β} {x y : α}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>211    (H : uniform_continuous f) (h : x ≈ y) : f x ≈ f y :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_equiv.equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_equiv.equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 427, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 326, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 326, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_equiv.{u+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_equiv.{v+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>212  assume _ h&#x27;, h _ (H h&#x27;)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='set.{v} (prod.{v v} β β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (set.{v} (set.{v} (prod.{v v} β β))) (@set.has_mem.{v} (set.{v} (prod.{v v} β β))) _x (@filter.sets.{v} (prod.{v v} β β) (@uniformity.{v} β _inst_2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@uniform_continuous.{u v} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (set.{v} (set.{v} (prod.{v v} β β))) (@set.has_mem.{v} (set.{v} (prod.{v v} β β))) _x (@filter.sets.{v} (prod.{v v} β β) (@uniformity.{v} β _inst_2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>213  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>214  lemma eq_of_separated_of_uniform_continuous [separated β] {f : α → β} {x y : α}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='blue'><a title='separated'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='red'><a title='{&#x27;line&#x27;: 41, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='green'><a title='Π (α : Type v) [_inst_4 : uniform_space.{v} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>215    (H : uniform_continuous f) (h : x ≈ y) : f x = f y :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_equiv.equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 427, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 326, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_equiv.{u+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>216  separated_def.1 (by apply_instance) _ _ $ separated_of_uniform_continuous H h</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='separated_def'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='uniform_space.separated_of_uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 210, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_4 : uniform_space.{v} α], iff (@separated.{v} α _inst_4) (∀ (x y : α), (∀ (r : set.{v} (prod.{v v} α α)), @has_mem.mem.{v v} (set.{v} (prod.{v v} α α)) (filter.{v} (prod.{v v} α α)) (@filter.has_mem.{v} (prod.{v v} α α)) r (@uniformity.{v} α _inst_4) → @has_mem.mem.{v v} (prod.{v v} α α) (set.{v} (prod.{v v} α α)) (@set.has_mem.{v} (prod.{v v} α α)) (@prod.mk.{v v} α α x y) r) → @eq.{v+1} α x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : uniform_space.{u} α] [_inst_2 : uniform_space.{v} β] {f : α → β} {x y : α}, @uniform_continuous.{u v} α β _inst_1 _inst_2 f → @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) x y → @has_equiv.equiv.{v+1} β (@setoid_has_equiv.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) (f x) (f y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_continuous.{u v} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
_inst_4 : @separated.{v} β _inst_2,
f : α → β,
x y : α,
H : @uniform_continuous.{u v} α β _inst_1 _inst_2 f,
h : @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) x y
⊢ @separated.{v} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>217  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>218  def separation_quotient (α : Type*) [uniform_space α] := quotient (separation_setoid α)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='uniform_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='quotient'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_space.separation_setoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 88, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 102, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Sort u}, setoid.{u} α → Sort u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u) [_inst_4 : uniform_space.{u} α], setoid.{u+1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='A uniform space is a generalization of the &quot;uniform&quot; topological aspects of a
 metric space. It consists of a filter on `α × α` called the &quot;uniformity&quot;, which
 satisfies properties analogous to the reflexivity, symmetry, and triangle properties
 of a metric.

 A metric space has a natural uniformity, and a uniform space has a natural topology.
 A topological group also has a natural uniformity, even when it is not metrizable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>219  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>220  namespace separation_quotient</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>221  instance : uniform_space (separation_quotient α) := by dunfold separation_quotient ; apply_instance</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='uniform_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_space.separation_quotient'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 218, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1343, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_4 : uniform_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dunfold_config {to_dsimp_config := {md := tactic.transparency.instances, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt}} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A uniform space is a generalization of the &quot;uniform&quot; topological aspects of a
 metric space. It consists of a filter on `α × α` called the &quot;uniformity&quot;, which
 satisfies properties analogous to the reflexivity, symmetry, and triangle properties
 of a metric.

 A metric space has a natural uniformity, and a uniform space has a natural topology.
 A topological group also has a natural uniformity, even when it is not metrizable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='Similar to `unfold`, but only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='teal'><a title='dunfold'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dunfold_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                      </code><font color='lime'><a title='α : Type u,
_inst_1 : uniform_space.{u} α
⊢ uniform_space.{u} (@uniform_space.separation_quotient.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>222  instance : separated (separation_quotient α) := by dunfold separation_quotient ; apply_instance</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='separated'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_space.separation_quotient'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 41, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 218, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1343, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π (α : Type u) [_inst_4 : uniform_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_4 : uniform_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dunfold_config {to_dsimp_config := {md := tactic.transparency.instances, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt}} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='orange'><a title='Similar to `unfold`, but only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='teal'><a title='dunfold'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dunfold_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='lime'><a title='α : Type u,
_inst_1 : uniform_space.{u} α
⊢ @separated.{u} (@uniform_space.separation_quotient.{u} α _inst_1)
    (@uniform_space.separation_quotient.uniform_space.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>223  instance [inhabited α] : inhabited (separation_quotient α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='inhabited'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='inhabited'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_space.separation_quotient'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 768, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 768, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 218, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Sort u → Sort (max 1 u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_4 : uniform_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>224  by unfold separation_quotient; apply_instance</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1411, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.unfold_config {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.ff, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.ff, beta := bool.tt, eta := bool.ff, proj := bool.ff, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.ff, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Given defined constants `e₁ ... eₙ`, `unfold e₁ ... eₙ` iteratively unfolds all occurrences in the target of the main goal, using equational lemmas associated with the definitions.

As with `simp`, the `at` modifier can be used to specify locations for the unfolding.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='unfold'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.unfold_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
_inst_1 : uniform_space.{u} α,
_inst_4 : inhabited.{u+1} α
⊢ inhabited.{u+1} (@uniform_space.separation_quotient.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>225  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : uniform_space.{u} α,
_inst_4 : inhabited.{u+1} α
⊢ inhabited.{u+1} (@uniform_space.separation_quotient.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>226  def lift [separated β] (f : α → β) : (separation_quotient α → β) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='separated'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='uniform_space.separation_quotient'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 41, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;line&#x27;: 218, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π (α : Type v) [_inst_4 : uniform_space.{v} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u_1) [_inst_4 : uniform_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>227  if h : uniform_continuous f then</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='dite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 609, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 427, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (c : Prop) [h : decidable c] {α : Type (max u v)}, (c → α) → (not c → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>228    quotient.lift f (λ x y, eq_of_separated_of_uniform_continuous h)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='quotient.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_space.eq_of_separated_of_uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 102, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 214, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u} {β : Sort v} [s : setoid.{u} α] (f : α → β), (∀ (a b : α), @has_equiv.equiv.{u} α (@setoid_has_equiv.{u} α s) a b → @eq.{v} β (f a) (f b)) → @quotient.{u} α s → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : uniform_space.{u} α] [_inst_2 : uniform_space.{v} β] [_inst_4 : @separated.{v} β _inst_2] {f : α → β} {x y : α}, @uniform_continuous.{u v} α β _inst_1 _inst_2 f → @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) x y → @eq.{v+1} β (f x) (f y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_continuous.{u v} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>229  else</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>230    λ x, f (classical.inhabited_of_nonempty $ (nonempty_quotient_iff $ separation_setoid α).1 ⟨x⟩).default</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='not'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='classical.inhabited_of_nonempty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='nonempty_quotient_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='uniform_space.separation_setoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='inhabited.default'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/classical.lean&#x27;, &#x27;line&#x27;: 78, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/quot.lean&#x27;, &#x27;line&#x27;: 134, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 102, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 768, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_space.separation_quotient.{u} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u}, nonempty.{u} α → inhabited.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Sort u_1} (s : setoid.{u_1} α), iff (nonempty.{u_1} (@quotient.{u_1} α s)) (nonempty.{u_1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u) [_inst_4 : uniform_space.{u} α], setoid.{u+1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@uniform_space.separation_quotient.{u} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u) [c : inhabited.{u+1} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>231  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>232  lemma lift_mk [separated β] {f : α → β} (h : uniform_continuous f) (a : α) : lift f ⟦a⟧ = f a :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='separated'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='uniform_space.separation_quotient.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;line&#x27;: 41, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 427, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;line&#x27;: 226, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Π (α : Type v) [_inst_4 : uniform_space.{v} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : uniform_space.{u} α] [_inst_2 : uniform_space.{v} β] [_inst_4 : @separated.{v} β _inst_2], (α → β) → @uniform_space.separation_quotient.{u} α _inst_1 → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>233  by rw [lift, dif_pos h]; refl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='uniform_space.separation_quotient.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='dif_pos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 226, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 928, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : uniform_space.{?l_1} α] [_inst_2 : uniform_space.{?l_2} β] [_inst_4 : @separated.{?l_2} β _inst_2], (α → β) → @uniform_space.separation_quotient.{?l_1} α _inst_1 → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c] (hc : c) {α : Type (max u v)} {t : c → α} {e : not c → α}, @eq.{(max (u+1) (v+1))} α (@dite.{(max (u+1) (v+1))} c h α t e) (t hc)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_continuous.{u v} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
_inst_4 : @separated.{v} β _inst_2,
f : α → β,
h : @uniform_continuous.{u v} α β _inst_1 _inst_2 f,
a : α
⊢ @eq.{v+1} β
    (@uniform_space.separation_quotient.lift.{u v} α β _inst_1 _inst_2 _inst_4 f
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) a))
    (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
_inst_4 : @separated.{v} β _inst_2,
f : α → β,
h : @uniform_continuous.{u v} α β _inst_1 _inst_2 f,
a : α
⊢ @eq.{v+1} β
    (@dite.{(max (u+1) (v+1))} (@uniform_continuous.{u v} α β _inst_1 _inst_2 f)
       (classical.prop_decidable (@uniform_continuous.{u v} α β _inst_1 _inst_2 f))
       (@uniform_space.separation_quotient.{u} α _inst_1 → β)
       (λ (h : @uniform_continuous.{u v} α β _inst_1 _inst_2 f),
          @quotient.lift.{u+1 v+1} α β (@uniform_space.separation_setoid.{u} α _inst_1) f
            (@uniform_space.separation_quotient.lift._proof_1.{u v} α β _inst_1 _inst_2 _inst_4 f h))
       (λ (h : not (@uniform_continuous.{u v} α β _inst_1 _inst_2 f))
        (x : @uniform_space.separation_quotient.{u} α _inst_1),
          f
            (@inhabited.default.{u+1} α
               (@classical.inhabited_of_nonempty.{u+1} α
                  (@uniform_space.separation_quotient.lift._proof_2.{u} α _inst_1 x))))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) a))
    (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
_inst_4 : @separated.{v} β _inst_2,
f : α → β,
h : @uniform_continuous.{u v} α β _inst_1 _inst_2 f,
a : α
⊢ @eq.{v+1} β
    (@quotient.lift.{u+1 v+1} α β (@uniform_space.separation_setoid.{u} α _inst_1) f
       (@uniform_space.separation_quotient.lift._proof_1.{u v} α β _inst_1 _inst_2 _inst_4 f h)
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) a))
    (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
_inst_4 : @separated.{v} β _inst_2,
f : α → β,
h : @uniform_continuous.{u v} α β _inst_1 _inst_2 f,
a : α
⊢ @eq.{v+1} β
    (@uniform_space.separation_quotient.lift.{u v} α β _inst_1 _inst_2 _inst_4 f
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) a))
    (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>234  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
_inst_4 : @separated.{v} β _inst_2,
f : α → β,
h : @uniform_continuous.{u v} α β _inst_1 _inst_2 f,
a : α
⊢ @eq.{v+1} β
    (@uniform_space.separation_quotient.lift.{u v} α β _inst_1 _inst_2 _inst_4 f
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) a))
    (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>235  lemma uniform_continuous_lift [separated β] (f : α → β) : uniform_continuous (lift f) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='separated'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_space.separation_quotient.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;line&#x27;: 41, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 427, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 226, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Π (α : Type v) [_inst_4 : uniform_space.{v} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : uniform_space.{u} α] [_inst_2 : uniform_space.{v} β] [_inst_4 : @separated.{v} β _inst_2], (α → β) → @uniform_space.separation_quotient.{u} α _inst_1 → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>236  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
_inst_4 : @separated.{v} β _inst_2,
f : α → β
⊢ @uniform_continuous.{u v} (@uniform_space.separation_quotient.{u} α _inst_1) β
    (@uniform_space.separation_quotient.uniform_space.{u} α _inst_1)
    _inst_2
    (@uniform_space.separation_quotient.lift.{u v} α β _inst_1 _inst_2 _inst_4 f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>237    by_cases hf : uniform_continuous f,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 427, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : uniform_space.{u} α] [_inst_2 : uniform_space.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
_inst_4 : @separated.{v} β _inst_2,
f : α → β
⊢ @uniform_continuous.{u v} (@uniform_space.separation_quotient.{u} α _inst_1) β
    (@uniform_space.separation_quotient.uniform_space.{u} α _inst_1)
    _inst_2
    (@uniform_space.separation_quotient.lift.{u v} α β _inst_1 _inst_2 _inst_4 f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
_inst_4 : @separated.{v} β _inst_2,
f : α → β,
hf : @uniform_continuous.{u v} α β _inst_1 _inst_2 f
⊢ @uniform_continuous.{u v} (@uniform_space.separation_quotient.{u} α _inst_1) β
    (@uniform_space.separation_quotient.uniform_space.{u} α _inst_1)
    _inst_2
    (@uniform_space.separation_quotient.lift.{u v} α β _inst_1 _inst_2 _inst_4 f)

α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
_inst_4 : @separated.{v} β _inst_2,
f : α → β,
hf : not (@uniform_continuous.{u v} α β _inst_1 _inst_2 f)
⊢ @uniform_continuous.{u v} (@uniform_space.separation_quotient.{u} α _inst_1) β
    (@uniform_space.separation_quotient.uniform_space.{u} α _inst_1)
    _inst_2
    (@uniform_space.separation_quotient.lift.{u v} α β _inst_1 _inst_2 _inst_4 f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>238    { rw [lift, dif_pos hf], exact uniform_continuous_quotient_lift hf },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='uniform_space.separation_quotient.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='dif_pos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='uniform_space.uniform_continuous_quotient_lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 226, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 928, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 162, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : uniform_space.{?l_1} α] [_inst_2 : uniform_space.{?l_2} β] [_inst_4 : @separated.{?l_2} β _inst_2], (α → β) → @uniform_space.separation_quotient.{?l_1} α _inst_1 → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c] (hc : c) {α : Type (max u v)} {t : c → α} {e : not c → α}, @eq.{(max (u+1) (v+1))} α (@dite.{(max (u+1) (v+1))} c h α t e) (t hc)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_continuous.{u v} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : uniform_space.{u} α] [_inst_2 : uniform_space.{v} β] {f : α → β} {h : ∀ (a b : α), @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α a b) (@separation_rel.{u} α _inst_1) → @eq.{v+1} β (f a) (f b)}, @uniform_continuous.{u v} α β _inst_1 _inst_2 f → @uniform_continuous.{u v} (@quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) β (@uniform_space.separation_setoid.uniform_space.{u} α _inst_1) _inst_2 (λ (a : @quotient.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)), @quotient.lift.{u+1 v+1} α β (@uniform_space.separation_setoid.{u} α _inst_1) f h a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_continuous.{u v} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
_inst_4 : @separated.{v} β _inst_2,
f : α → β,
hf : @uniform_continuous.{u v} α β _inst_1 _inst_2 f
⊢ @uniform_continuous.{u v} (@uniform_space.separation_quotient.{u} α _inst_1) β
    (@uniform_space.separation_quotient.uniform_space.{u} α _inst_1)
    _inst_2
    (@uniform_space.separation_quotient.lift.{u v} α β _inst_1 _inst_2 _inst_4 f)

α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
_inst_4 : @separated.{v} β _inst_2,
f : α → β,
hf : not (@uniform_continuous.{u v} α β _inst_1 _inst_2 f)
⊢ @uniform_continuous.{u v} (@uniform_space.separation_quotient.{u} α _inst_1) β
    (@uniform_space.separation_quotient.uniform_space.{u} α _inst_1)
    _inst_2
    (@uniform_space.separation_quotient.lift.{u v} α β _inst_1 _inst_2 _inst_4 f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
_inst_4 : @separated.{v} β _inst_2,
f : α → β,
hf : @uniform_continuous.{u v} α β _inst_1 _inst_2 f
⊢ @uniform_continuous.{u v} (@uniform_space.separation_quotient.{u} α _inst_1) β
    (@uniform_space.separation_quotient.uniform_space.{u} α _inst_1)
    _inst_2
    (@uniform_space.separation_quotient.lift.{u v} α β _inst_1 _inst_2 _inst_4 f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
_inst_4 : @separated.{v} β _inst_2,
f : α → β,
hf : @uniform_continuous.{u v} α β _inst_1 _inst_2 f
⊢ @uniform_continuous.{u v} (@uniform_space.separation_quotient.{u} α _inst_1) β
    (@uniform_space.separation_quotient.uniform_space.{u} α _inst_1)
    _inst_2
    (@dite.{(max (u+1) (v+1))} (@uniform_continuous.{u v} α β _inst_1 _inst_2 f)
       (classical.prop_decidable (@uniform_continuous.{u v} α β _inst_1 _inst_2 f))
       (@uniform_space.separation_quotient.{u} α _inst_1 → β)
       (λ (h : @uniform_continuous.{u v} α β _inst_1 _inst_2 f),
          @quotient.lift.{u+1 v+1} α β (@uniform_space.separation_setoid.{u} α _inst_1) f
            (@uniform_space.separation_quotient.lift._proof_1.{u v} α β _inst_1 _inst_2 _inst_4 f h))
       (λ (h : not (@uniform_continuous.{u v} α β _inst_1 _inst_2 f))
        (x : @uniform_space.separation_quotient.{u} α _inst_1),
          f
            (@inhabited.default.{u+1} α
               (@classical.inhabited_of_nonempty.{u+1} α
                  (@uniform_space.separation_quotient.lift._proof_2.{u} α _inst_1 x)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
_inst_4 : @separated.{v} β _inst_2,
f : α → β,
hf : @uniform_continuous.{u v} α β _inst_1 _inst_2 f
⊢ @uniform_continuous.{u v} (@uniform_space.separation_quotient.{u} α _inst_1) β
    (@uniform_space.separation_quotient.uniform_space.{u} α _inst_1)
    _inst_2
    (@quotient.lift.{u+1 v+1} α β (@uniform_space.separation_setoid.{u} α _inst_1) f
       (@uniform_space.separation_quotient.lift._proof_1.{u v} α β _inst_1 _inst_2 _inst_4 f hf))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
_inst_4 : @separated.{v} β _inst_2,
f : α → β,
hf : not (@uniform_continuous.{u v} α β _inst_1 _inst_2 f)
⊢ @uniform_continuous.{u v} (@uniform_space.separation_quotient.{u} α _inst_1) β
    (@uniform_space.separation_quotient.uniform_space.{u} α _inst_1)
    _inst_2
    (@uniform_space.separation_quotient.lift.{u v} α β _inst_1 _inst_2 _inst_4 f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>239    { rw [lift, dif_neg hf], exact uniform_continuous_of_const (assume a b, rfl) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='uniform_space.separation_quotient.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='dif_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='uniform_continuous_of_const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 226, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 934, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 435, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : uniform_space.{?l_1} α] [_inst_2 : uniform_space.{?l_2} β] [_inst_4 : @separated.{?l_2} β _inst_2], (α → β) → @uniform_space.separation_quotient.{?l_1} α _inst_1 → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c] (hnc : not c) {α : Type (max u v)} {t : c → α} {e : not c → α}, @eq.{(max (u+1) (v+1))} α (@dite.{(max (u+1) (v+1))} c h α t e) (e hnc)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@uniform_continuous.{u v} α β _inst_1 _inst_2 f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : uniform_space.{u} α] [_inst_2 : uniform_space.{v} β] {c : α → β}, (∀ (a b : α), @eq.{v+1} β (c a) (c b)) → @uniform_continuous.{u v} α β _inst_1 _inst_2 c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {a : α}, @eq.{v+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
_inst_4 : @separated.{v} β _inst_2,
f : α → β,
hf : not (@uniform_continuous.{u v} α β _inst_1 _inst_2 f)
⊢ @uniform_continuous.{u v} (@uniform_space.separation_quotient.{u} α _inst_1) β
    (@uniform_space.separation_quotient.uniform_space.{u} α _inst_1)
    _inst_2
    (@uniform_space.separation_quotient.lift.{u v} α β _inst_1 _inst_2 _inst_4 f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
_inst_4 : @separated.{v} β _inst_2,
f : α → β,
hf : not (@uniform_continuous.{u v} α β _inst_1 _inst_2 f)
⊢ @uniform_continuous.{u v} (@uniform_space.separation_quotient.{u} α _inst_1) β
    (@uniform_space.separation_quotient.uniform_space.{u} α _inst_1)
    _inst_2
    (@dite.{(max (u+1) (v+1))} (@uniform_continuous.{u v} α β _inst_1 _inst_2 f)
       (classical.prop_decidable (@uniform_continuous.{u v} α β _inst_1 _inst_2 f))
       (@uniform_space.separation_quotient.{u} α _inst_1 → β)
       (λ (h : @uniform_continuous.{u v} α β _inst_1 _inst_2 f),
          @quotient.lift.{u+1 v+1} α β (@uniform_space.separation_setoid.{u} α _inst_1) f
            (@uniform_space.separation_quotient.lift._proof_1.{u v} α β _inst_1 _inst_2 _inst_4 f h))
       (λ (h : not (@uniform_continuous.{u v} α β _inst_1 _inst_2 f))
        (x : @uniform_space.separation_quotient.{u} α _inst_1),
          f
            (@inhabited.default.{u+1} α
               (@classical.inhabited_of_nonempty.{u+1} α
                  (@uniform_space.separation_quotient.lift._proof_2.{u} α _inst_1 x)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
_inst_4 : @separated.{v} β _inst_2,
f : α → β,
hf : not (@uniform_continuous.{u v} α β _inst_1 _inst_2 f)
⊢ @uniform_continuous.{u v} (@uniform_space.separation_quotient.{u} α _inst_1) β
    (@uniform_space.separation_quotient.uniform_space.{u} α _inst_1)
    _inst_2
    (λ (x : @uniform_space.separation_quotient.{u} α _inst_1),
       f
         (@inhabited.default.{u+1} α
            (@classical.inhabited_of_nonempty.{u+1} α
               (@uniform_space.separation_quotient.lift._proof_2.{u} α _inst_1 x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>240  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>241  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>242  def map (f : α → β) : separation_quotient α → separation_quotient β :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='uniform_space.separation_quotient'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='uniform_space.separation_quotient'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;line&#x27;: 218, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 218, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u_1) [_inst_4 : uniform_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) [_inst_4 : uniform_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>243  lift (quotient.mk ∘ f)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_space.separation_quotient.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 226, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : uniform_space.{u} α] [_inst_2 : uniform_space.{v} β] [_inst_4 : @separated.{v} β _inst_2], (α → β) → @uniform_space.separation_quotient.{u} α _inst_1 → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u} [s : setoid.{u} α], α → @quotient.{u} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β φ : Type v}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>244  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>245  lemma map_mk {f : α → β} (h : uniform_continuous f) (a : α) : map f ⟦a⟧ = ⟦f a⟧ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='uniform_space.separation_quotient.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 427, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;line&#x27;: 242, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : uniform_space.{u} α] [_inst_2 : uniform_space.{v} β], (α → β) → @uniform_space.separation_quotient.{u} α _inst_1 → @uniform_space.separation_quotient.{v} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [s : setoid.{v+1} α], α → @quotient.{v+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} [s : setoid.{v+1} α], α → @quotient.{v+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>246  by rw [map, lift_mk (uniform_continuous_quotient_mk.comp h)]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='uniform_space.separation_quotient.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_space.separation_quotient.lift_mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_space.uniform_continuous_quotient_mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 242, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 232, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 154, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : uniform_space.{?l_1} α] [_inst_2 : uniform_space.{?l_2} β], (α → β) → @uniform_space.separation_quotient.{?l_1} α _inst_1 → @uniform_space.separation_quotient.{?l_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : uniform_space.{u} α] [_inst_2 : uniform_space.{v} β] [_inst_4 : @separated.{v} β _inst_2] {f : α → β}, @uniform_continuous.{u v} α β _inst_1 _inst_2 f → ∀ (a : α), @eq.{v+1} β (@uniform_space.separation_quotient.lift.{u v} α β _inst_1 _inst_2 _inst_4 f (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) a)) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type v} [_inst_1 : uniform_space.{v} α], @uniform_continuous.{v v} α (@quotient.{v+1} α (@uniform_space.separation_setoid.{v} α _inst_1)) _inst_1 (@uniform_space.separation_setoid.uniform_space.{v} α _inst_1) (@quotient.mk.{v+1} α (@uniform_space.separation_setoid.{v} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_continuous.{u v} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
f : α → β,
h : @uniform_continuous.{u v} α β _inst_1 _inst_2 f,
a : α
⊢ @eq.{v+1} (@uniform_space.separation_quotient.{v} β _inst_2)
    (@uniform_space.separation_quotient.map.{u v} α β _inst_1 _inst_2 f
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) a))
    (@quotient.mk.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2) (f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
f : α → β,
h : @uniform_continuous.{u v} α β _inst_1 _inst_2 f,
a : α
⊢ @eq.{v+1} (@uniform_space.separation_quotient.{v} β _inst_2)
    (@uniform_space.separation_quotient.lift.{u v} α (@uniform_space.separation_quotient.{v} β _inst_2) _inst_1
       (@uniform_space.separation_quotient.uniform_space.{v} β _inst_2)
       (@uniform_space.separation_quotient.separated.{v} β _inst_2)
       (@function.comp.{u+1 v+1 v+1} α β (@uniform_space.separation_quotient.{v} β _inst_2)
          (@quotient.mk.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
          f)
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) a))
    (@quotient.mk.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2) (f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
f : α → β,
h : @uniform_continuous.{u v} α β _inst_1 _inst_2 f,
a : α
⊢ @eq.{v+1} (@uniform_space.separation_quotient.{v} β _inst_2)
    (@uniform_space.separation_quotient.map.{u v} α β _inst_1 _inst_2 f
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) a))
    (@quotient.mk.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2) (f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>247  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
f : α → β,
h : @uniform_continuous.{u v} α β _inst_1 _inst_2 f,
a : α
⊢ @eq.{v+1} (@uniform_space.separation_quotient.{v} β _inst_2)
    (@uniform_space.separation_quotient.map.{u v} α β _inst_1 _inst_2 f
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) a))
    (@quotient.mk.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2) (f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>248  lemma uniform_continuous_map (f : α → β) : uniform_continuous (map f) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_space.separation_quotient.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 427, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 242, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : uniform_space.{u} α] [_inst_2 : uniform_space.{v} β], (α → β) → @uniform_space.separation_quotient.{u} α _inst_1 → @uniform_space.separation_quotient.{v} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>249  uniform_continuous_lift (quotient.mk ∘ f)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_space.separation_quotient.uniform_continuous_lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 235, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : uniform_space.{u} α] [_inst_2 : uniform_space.{v} β] [_inst_4 : @separated.{v} β _inst_2] (f : α → β), @uniform_continuous.{u v} (@uniform_space.separation_quotient.{u} α _inst_1) β (@uniform_space.separation_quotient.uniform_space.{u} α _inst_1) _inst_2 (@uniform_space.separation_quotient.lift.{u v} α β _inst_1 _inst_2 _inst_4 f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v} [s : setoid.{v+1} α], α → @quotient.{v+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β φ : Type v}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>250  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>251  lemma map_unique {f : α → β} (hf : uniform_continuous f)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 427, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>252    {g : separation_quotient α → separation_quotient β}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='uniform_space.separation_quotient'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='uniform_space.separation_quotient'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 218, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 218, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π (α : Type u_1) [_inst_4 : uniform_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) [_inst_4 : uniform_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>253    (comm : quotient.mk ∘ f = g ∘ quotient.mk) : map f = g :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='uniform_space.separation_quotient.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 242, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π {α : Sort u} [s : setoid.{u} α], α → @quotient.{u} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β φ : Type v}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u v)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_space.separation_quotient.{u} α _inst_1 → @uniform_space.separation_quotient.{v} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u} {φ : Type v}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Sort u} [s : setoid.{u} α], α → @quotient.{u} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : uniform_space.{u} α] [_inst_2 : uniform_space.{v} β], (α → β) → @uniform_space.separation_quotient.{u} α _inst_1 → @uniform_space.separation_quotient.{v} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u v)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_space.separation_quotient.{u} α _inst_1 → @uniform_space.separation_quotient.{v} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>254  by ext ⟨a⟩;</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
f : α → β,
hf : @uniform_continuous.{u v} α β _inst_1 _inst_2 f,
g : @uniform_space.separation_quotient.{u} α _inst_1 → @uniform_space.separation_quotient.{v} β _inst_2,
comm :
  @eq.{(max (u+1) (v+1))} (α → @quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
    (@function.comp.{u+1 v+1 v+1} α β (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
       (@quotient.mk.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
       f)
    (@function.comp.{u+1 u+1 v+1} α (@uniform_space.separation_quotient.{u} α _inst_1)
       (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
       g
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
⊢ @eq.{(max (u+1) (v+1))}
    (@uniform_space.separation_quotient.{u} α _inst_1 → @uniform_space.separation_quotient.{v} β _inst_2)
    (@uniform_space.separation_quotient.map.{u v} α β _inst_1 _inst_2 f)
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>255  calc map f ⟦a⟧ = ⟦f a⟧ : map_mk hf a</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='tactic.interactive.exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='uniform_space.separation_quotient.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='quotient.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='uniform_space.separation_quotient.map_mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 242, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 245, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : uniform_space.{u} α] [_inst_2 : uniform_space.{v} β], (α → β) → @uniform_space.separation_quotient.{u} α _inst_1 → @uniform_space.separation_quotient.{v} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [s : setoid.{u+1} α], α → @quotient.{u+1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : uniform_space.{u} α] [_inst_2 : uniform_space.{v} β] {f : α → β}, @uniform_continuous.{u v} α β _inst_1 _inst_2 f → ∀ (a : α), @eq.{v+1} (@uniform_space.separation_quotient.{v} β _inst_2) (@uniform_space.separation_quotient.map.{u v} α β _inst_1 _inst_2 f (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1) a)) (@quotient.mk.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2) (f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_continuous.{u v} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
f : α → β,
hf : @uniform_continuous.{u v} α β _inst_1 _inst_2 f,
g : @uniform_space.separation_quotient.{u} α _inst_1 → @uniform_space.separation_quotient.{v} β _inst_2,
comm :
  @eq.{(max (u+1) (v+1))} (α → @quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
    (@function.comp.{u+1 v+1 v+1} α β (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
       (@quotient.mk.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
       f)
    (@function.comp.{u+1 u+1 v+1} α (@uniform_space.separation_quotient.{u} α _inst_1)
       (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
       g
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
⊢ @eq.{(max (u+1) (v+1))}
    (@uniform_space.separation_quotient.{u} α _inst_1 → @uniform_space.separation_quotient.{v} β _inst_2)
    (@uniform_space.separation_quotient.map.{u v} α β _inst_1 _inst_2 f)
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>256    ... = g ⟦a⟧ : congr_fun comm a</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='congr_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@uniform_space.separation_quotient.{u} α _inst_1 → @uniform_space.separation_quotient.{v} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {α : Type u} {β : α → Type v} {f g : Π (x : α), β x}, @eq.{(max (u+1) (v+1))} (Π (x : α), β x) f g → ∀ (a : α), @eq.{v+1} (β a) (f a) (g a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{(max (u+1) (v+1))} (α → @quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) (@function.comp.{u+1 v+1 v+1} α β (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) (@quotient.mk.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) f) (@function.comp.{u+1 u+1 v+1} α (@uniform_space.separation_quotient.{u} α _inst_1) (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) g (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
f : α → β,
hf : @uniform_continuous.{u v} α β _inst_1 _inst_2 f,
g : @uniform_space.separation_quotient.{u} α _inst_1 → @uniform_space.separation_quotient.{v} β _inst_2,
comm :
  @eq.{(max (u+1) (v+1))} (α → @quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
    (@function.comp.{u+1 v+1 v+1} α β (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
       (@quotient.mk.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
       f)
    (@function.comp.{u+1 u+1 v+1} α (@uniform_space.separation_quotient.{u} α _inst_1)
       (@quotient.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2))
       g
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))
⊢ @eq.{(max (u+1) (v+1))}
    (@uniform_space.separation_quotient.{u} α _inst_1 → @uniform_space.separation_quotient.{v} β _inst_2)
    (@uniform_space.separation_quotient.map.{u v} α β _inst_1 _inst_2 f)
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>257  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>258  lemma map_id : map (@id α) = id :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='uniform_space.separation_quotient.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;line&#x27;: 242, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : uniform_space.{u} α] [_inst_2 : uniform_space.{v} β], (α → β) → @uniform_space.separation_quotient.{u} α _inst_1 → @uniform_space.separation_quotient.{v} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Sort u}, α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Sort u}, α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>259  map_unique uniform_continuous_id rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_space.separation_quotient.map_unique'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='uniform_continuous_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 251, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 441, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : uniform_space.{u} α] [_inst_2 : uniform_space.{u} β] {f : α → β}, @uniform_continuous.{u u} α β _inst_1 _inst_2 f → ∀ {g : @uniform_space.separation_quotient.{u} α _inst_1 → @uniform_space.separation_quotient.{u} β _inst_2}, @eq.{u+1} (α → @quotient.{u+1} β (@uniform_space.separation_setoid.{u} β _inst_2)) (@function.comp.{u+1 u+1 u+1} α β (@quotient.{u+1} β (@uniform_space.separation_setoid.{u} β _inst_2)) (@quotient.mk.{u+1} β (@uniform_space.separation_setoid.{u} β _inst_2)) f) (@function.comp.{u+1 u+1 u+1} α (@uniform_space.separation_quotient.{u} α _inst_1) (@quotient.{u+1} β (@uniform_space.separation_setoid.{u} β _inst_2)) g (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))) → @eq.{u+1} (@uniform_space.separation_quotient.{u} α _inst_1 → @uniform_space.separation_quotient.{u} β _inst_2) (@uniform_space.separation_quotient.map.{u u} α β _inst_1 _inst_2 f) g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : uniform_space.{u} α], @uniform_continuous.{u u} α α _inst_1 _inst_1 (@id.{u+1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>260  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>261  lemma map_comp {f : α → β} {g : β → γ} (hf : uniform_continuous f) (hg : uniform_continuous g) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 427, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 427, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>262    map g ∘ map f = map (g ∘ f) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_space.separation_quotient.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='uniform_space.separation_quotient.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='uniform_space.separation_quotient.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 242, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 242, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 242, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : uniform_space.{u} α] [_inst_2 : uniform_space.{v} β], (α → β) → @uniform_space.separation_quotient.{u} α _inst_1 → @uniform_space.separation_quotient.{v} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} {φ : Type w}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : uniform_space.{u} α] [_inst_2 : uniform_space.{v} β], (α → β) → @uniform_space.separation_quotient.{u} α _inst_1 → @uniform_space.separation_quotient.{v} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u w)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : uniform_space.{u} α] [_inst_2 : uniform_space.{v} β], (α → β) → @uniform_space.separation_quotient.{u} α _inst_1 → @uniform_space.separation_quotient.{v} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} {φ : Type w}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>263  (map_unique (hg.comp hf) $ by simp only [(∘), map_mk, hf, hg]).symm</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='uniform_space.separation_quotient.map_unique'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_continuous.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='uniform_space.separation_quotient.map_mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 251, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 447, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 245, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {β : Type w} [_inst_1 : uniform_space.{u} α] [_inst_2 : uniform_space.{w} β] {f : α → β}, @uniform_continuous.{u w} α β _inst_1 _inst_2 f → ∀ {g : @uniform_space.separation_quotient.{u} α _inst_1 → @uniform_space.separation_quotient.{w} β _inst_2}, @eq.{(max (u+1) (w+1))} (α → @quotient.{w+1} β (@uniform_space.separation_setoid.{w} β _inst_2)) (@function.comp.{u+1 w+1 w+1} α β (@quotient.{w+1} β (@uniform_space.separation_setoid.{w} β _inst_2)) (@quotient.mk.{w+1} β (@uniform_space.separation_setoid.{w} β _inst_2)) f) (@function.comp.{u+1 u+1 w+1} α (@uniform_space.separation_quotient.{u} α _inst_1) (@quotient.{w+1} β (@uniform_space.separation_setoid.{w} β _inst_2)) g (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1))) → @eq.{(max (u+1) (w+1))} (@uniform_space.separation_quotient.{u} α _inst_1 → @uniform_space.separation_quotient.{w} β _inst_2) (@uniform_space.separation_quotient.map.{u w} α β _inst_1 _inst_2 f) g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@uniform_continuous.{v w} β γ _inst_2 _inst_3 g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} {γ : Type w} [_inst_1 : uniform_space.{u} α] [_inst_2 : uniform_space.{v} β] [_inst_3 : uniform_space.{w} γ] {g : β → γ} {f : α → β}, @uniform_continuous.{v w} β γ _inst_2 _inst_3 g → @uniform_continuous.{u v} α β _inst_1 _inst_2 f → @uniform_continuous.{u w} α γ _inst_1 _inst_3 (@function.comp.{u+1 v+1 w+1} α β γ g f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_continuous.{u v} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Sort ?l_1} {β : Sort ?l_2} {φ : Sort ?l_3}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : uniform_space.{?l_1} α] [_inst_2 : uniform_space.{?l_2} β] {f : α → β}, @uniform_continuous.{?l_1 ?l_2} α β _inst_1 _inst_2 f → ∀ (a : α), @eq.{?l_2+1} (@uniform_space.separation_quotient.{?l_2} β _inst_2) (@uniform_space.separation_quotient.map.{?l_1 ?l_2} α β _inst_1 _inst_2 f (@quotient.mk.{?l_1+1} α (@uniform_space.separation_setoid.{?l_1} α _inst_1) a)) (@quotient.mk.{?l_2+1} β (@uniform_space.separation_setoid.{?l_2} β _inst_2) (f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_continuous.{u v} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_continuous.{v w} β γ _inst_2 _inst_3 g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type (max u w)} {a b : α}, @eq.{(max (u+1) (w+1))} α a b → @eq.{(max (u+1) (w+1))} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
_inst_3 : uniform_space.{w} γ,
f : α → β,
g : β → γ,
hf : @uniform_continuous.{u v} α β _inst_1 _inst_2 f,
hg : @uniform_continuous.{v w} β γ _inst_2 _inst_3 g
⊢ @eq.{(max (u+1) (w+1))} (α → @quotient.{w+1} γ (@uniform_space.separation_setoid.{w} γ _inst_3))
    (@function.comp.{u+1 w+1 w+1} α γ (@quotient.{w+1} γ (@uniform_space.separation_setoid.{w} γ _inst_3))
       (@quotient.mk.{w+1} γ (@uniform_space.separation_setoid.{w} γ _inst_3))
       (@function.comp.{u+1 v+1 w+1} α β γ g f))
    (@function.comp.{u+1 u+1 w+1} α (@uniform_space.separation_quotient.{u} α _inst_1)
       (@quotient.{w+1} γ (@uniform_space.separation_setoid.{w} γ _inst_3))
       (@function.comp.{u+1 v+1 w+1} (@uniform_space.separation_quotient.{u} α _inst_1)
          (@uniform_space.separation_quotient.{v} β _inst_2)
          (@uniform_space.separation_quotient.{w} γ _inst_3)
          (@uniform_space.separation_quotient.map.{v w} β γ _inst_2 _inst_3 g)
          (@uniform_space.separation_quotient.map.{u v} α β _inst_1 _inst_2 f))
       (@quotient.mk.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>264  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>265  end separation_quotient</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>266  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>267  lemma separation_prod {a₁ a₂ : α} {b₁ b₂ : β} : (a₁, b₁) ≈ (a₂, b₂) ↔ a₁ ≈ a₂ ∧ b₁ ≈ b₂ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_equiv.equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_equiv.equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_equiv.equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 326, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 326, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 326, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v}, α → β → prod.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (max u v)} [c : has_equiv.{(max (u+1) (v+1))} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, α → β → prod.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_equiv.{u+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_equiv.{v+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>268  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
a₁ a₂ : α,
b₁ b₂ : β
⊢ iff
    (@has_equiv.equiv.{(max (u+1) (v+1))} (prod.{u v} α β)
       (@setoid_has_equiv.{(max (u+1) (v+1))} (prod.{u v} α β)
          (@uniform_space.separation_setoid.{(max u v)} (prod.{u v} α β)
             (@prod.uniform_space.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (and
       (@has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) a₁
          a₂)
       (@has_equiv.equiv.{v+1} β (@setoid_has_equiv.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) b₁
          b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>269    split,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
a₁ a₂ : α,
b₁ b₂ : β
⊢ iff
    (@has_equiv.equiv.{(max (u+1) (v+1))} (prod.{u v} α β)
       (@setoid_has_equiv.{(max (u+1) (v+1))} (prod.{u v} α β)
          (@uniform_space.separation_setoid.{(max u v)} (prod.{u v} α β)
             (@prod.uniform_space.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (and
       (@has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) a₁
          a₂)
       (@has_equiv.equiv.{v+1} β (@setoid_has_equiv.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) b₁
          b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
a₁ a₂ : α,
b₁ b₂ : β
⊢ @has_equiv.equiv.{(max (u+1) (v+1))} (prod.{u v} α β)
    (@setoid_has_equiv.{(max (u+1) (v+1))} (prod.{u v} α β)
       (@uniform_space.separation_setoid.{(max u v)} (prod.{u v} α β)
          (@prod.uniform_space.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₂ b₂) →
  and
    (@has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) a₁ a₂)
    (@has_equiv.equiv.{v+1} β (@setoid_has_equiv.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) b₁ b₂)

α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
a₁ a₂ : α,
b₁ b₂ : β
⊢ and
    (@has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) a₁ a₂)
    (@has_equiv.equiv.{v+1} β (@setoid_has_equiv.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) b₁
       b₂) →
  @has_equiv.equiv.{(max (u+1) (v+1))} (prod.{u v} α β)
    (@setoid_has_equiv.{(max (u+1) (v+1))} (prod.{u v} α β)
       (@uniform_space.separation_setoid.{(max u v)} (prod.{u v} α β)
          (@prod.uniform_space.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₂ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>270    { assume h,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
a₁ a₂ : α,
b₁ b₂ : β
⊢ @has_equiv.equiv.{(max (u+1) (v+1))} (prod.{u v} α β)
    (@setoid_has_equiv.{(max (u+1) (v+1))} (prod.{u v} α β)
       (@uniform_space.separation_setoid.{(max u v)} (prod.{u v} α β)
          (@prod.uniform_space.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₂ b₂) →
  and
    (@has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) a₁ a₂)
    (@has_equiv.equiv.{v+1} β (@setoid_has_equiv.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) b₁ b₂)

α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
a₁ a₂ : α,
b₁ b₂ : β
⊢ and
    (@has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) a₁ a₂)
    (@has_equiv.equiv.{v+1} β (@setoid_has_equiv.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) b₁
       b₂) →
  @has_equiv.equiv.{(max (u+1) (v+1))} (prod.{u v} α β)
    (@setoid_has_equiv.{(max (u+1) (v+1))} (prod.{u v} α β)
       (@uniform_space.separation_setoid.{(max u v)} (prod.{u v} α β)
          (@prod.uniform_space.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₂ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
a₁ a₂ : α,
b₁ b₂ : β
⊢ @has_equiv.equiv.{(max (u+1) (v+1))} (prod.{u v} α β)
    (@setoid_has_equiv.{(max (u+1) (v+1))} (prod.{u v} α β)
       (@uniform_space.separation_setoid.{(max u v)} (prod.{u v} α β)
          (@prod.uniform_space.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₂ b₂) →
  and
    (@has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) a₁ a₂)
    (@has_equiv.equiv.{v+1} β (@setoid_has_equiv.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) b₁ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
a₁ a₂ : α,
b₁ b₂ : β,
h :
  @has_equiv.equiv.{(max (u+1) (v+1))} (prod.{u v} α β)
    (@setoid_has_equiv.{(max (u+1) (v+1))} (prod.{u v} α β)
       (@uniform_space.separation_setoid.{(max u v)} (prod.{u v} α β)
          (@prod.uniform_space.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₂ b₂)
⊢ and
    (@has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) a₁ a₂)
    (@has_equiv.equiv.{v+1} β (@setoid_has_equiv.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) b₁ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>271      exact ⟨separated_of_uniform_continuous uniform_continuous_fst h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='blue'><a title='uniform_continuous_fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 726, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : uniform_space.{u} α] [_inst_2 : uniform_space.{v} β], @uniform_continuous.{(max u v) u} (prod.{u v} α β) α (@prod.uniform_space.{u v} α β _inst_1 _inst_2) _inst_1 (λ (p : prod.{u v} α β), @prod.fst.{u v} α β p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
a₁ a₂ : α,
b₁ b₂ : β,
h :
  @has_equiv.equiv.{(max (u+1) (v+1))} (prod.{u v} α β)
    (@setoid_has_equiv.{(max (u+1) (v+1))} (prod.{u v} α β)
       (@uniform_space.separation_setoid.{(max u v)} (prod.{u v} α β)
          (@prod.uniform_space.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₂ b₂)
⊢ and
    (@has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) a₁ a₂)
    (@has_equiv.equiv.{v+1} β (@setoid_has_equiv.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) b₁ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>272             separated_of_uniform_continuous uniform_continuous_snd h⟩ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='uniform_space.separated_of_uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='uniform_continuous_snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 210, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 729, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (max u v)} {β : Type u} [_inst_1 : uniform_space.{(max u v)} α] [_inst_2 : uniform_space.{u} β] {f : α → β} {x y : α}, @uniform_continuous.{(max u v) u} α β _inst_1 _inst_2 f → @has_equiv.equiv.{(max u v)+1} α (@setoid_has_equiv.{(max u v)+1} α (@uniform_space.separation_setoid.{(max u v)} α _inst_1)) x y → @has_equiv.equiv.{u+1} β (@setoid_has_equiv.{u+1} β (@uniform_space.separation_setoid.{u} β _inst_2)) (f x) (f y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : uniform_space.{u} α] [_inst_2 : uniform_space.{v} β], @uniform_continuous.{(max u v) v} (prod.{u v} α β) β (@prod.uniform_space.{u v} α β _inst_1 _inst_2) _inst_2 (λ (p : prod.{u v} α β), @prod.snd.{u v} α β p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_equiv.equiv.{(max (u+1) (v+1))} (prod.{u v} α β) (@setoid_has_equiv.{(max (u+1) (v+1))} (prod.{u v} α β) (@uniform_space.separation_setoid.{(max u v)} (prod.{u v} α β) (@prod.uniform_space.{u v} α β _inst_1 _inst_2))) (@prod.mk.{u v} α β a₁ b₁) (@prod.mk.{u v} α β a₂ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
a₁ a₂ : α,
b₁ b₂ : β,
h :
  @has_equiv.equiv.{(max (u+1) (v+1))} (prod.{u v} α β)
    (@setoid_has_equiv.{(max (u+1) (v+1))} (prod.{u v} α β)
       (@uniform_space.separation_setoid.{(max u v)} (prod.{u v} α β)
          (@prod.uniform_space.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₂ b₂)
⊢ and
    (@has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) a₁ a₂)
    (@has_equiv.equiv.{v+1} β (@setoid_has_equiv.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) b₁ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
a₁ a₂ : α,
b₁ b₂ : β
⊢ and
    (@has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) a₁ a₂)
    (@has_equiv.equiv.{v+1} β (@setoid_has_equiv.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) b₁
       b₂) →
  @has_equiv.equiv.{(max (u+1) (v+1))} (prod.{u v} α β)
    (@setoid_has_equiv.{(max (u+1) (v+1))} (prod.{u v} α β)
       (@uniform_space.separation_setoid.{(max u v)} (prod.{u v} α β)
          (@prod.uniform_space.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₂ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>273    { rintros ⟨eqv_α, eqv_β⟩ r r_in,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
a₁ a₂ : α,
b₁ b₂ : β
⊢ and
    (@has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) a₁ a₂)
    (@has_equiv.equiv.{v+1} β (@setoid_has_equiv.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) b₁
       b₂) →
  @has_equiv.equiv.{(max (u+1) (v+1))} (prod.{u v} α β)
    (@setoid_has_equiv.{(max (u+1) (v+1))} (prod.{u v} α β)
       (@uniform_space.separation_setoid.{(max u v)} (prod.{u v} α β)
          (@prod.uniform_space.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₂ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
a₁ a₂ : α,
b₁ b₂ : β,
r : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
r_in :
  @has_mem.mem.{(max u v) (max u v)}
    (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (set.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))))
    (@set.has_mem.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))))
    r
    (@filter.sets.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))
       (@uniformity.{(max u v)} (prod.{u v} α β) (@prod.uniform_space.{u v} α β _inst_1 _inst_2))),
eqv_α :
  @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) a₁ a₂,
eqv_β :
  @has_equiv.equiv.{v+1} β (@setoid_has_equiv.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) b₁ b₂
⊢ @has_mem.mem.{(max u v) (max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))
    (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_mem.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    r'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>274      rw uniformity_prod at r_in,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='uniformity_prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 682, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : uniform_space.{u} α] [_inst_2 : uniform_space.{v} β], @eq.{(max u v)+1} (filter.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))) (@uniformity.{(max u v)} (prod.{u v} α β) (@prod.uniform_space.{u v} α β _inst_1 _inst_2)) (@lattice.has_inf.inf.{(max u v)} (filter.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))) (@filter.lattice.has_inf.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))) (@filter.comap.{(max u v) u} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{u u} α α) (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)), @prod.mk.{u u} α α (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)) (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))) (@uniformity.{u} α _inst_1)) (@filter.comap.{(max u v) v} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{v v} β β) (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)), @prod.mk.{v v} β β (@prod.snd.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)) (@prod.snd.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))) (@uniformity.{v} β _inst_2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
a₁ a₂ : α,
b₁ b₂ : β,
r : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
r_in :
  @has_mem.mem.{(max u v) (max u v)}
    (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (set.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))))
    (@set.has_mem.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))))
    r
    (@filter.sets.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))
       (@uniformity.{(max u v)} (prod.{u v} α β) (@prod.uniform_space.{u v} α β _inst_1 _inst_2))),
eqv_α :
  @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) a₁ a₂,
eqv_β :
  @has_equiv.equiv.{v+1} β (@setoid_has_equiv.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) b₁ b₂
⊢ @has_mem.mem.{(max u v) (max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))
    (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_mem.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    r'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
a₁ a₂ : α,
b₁ b₂ : β,
r : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
eqv_α :
  @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) a₁ a₂,
eqv_β :
  @has_equiv.equiv.{v+1} β (@setoid_has_equiv.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) b₁ b₂,
r_in :
  @has_mem.mem.{(max u v) (max u v)}
    (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (set.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))))
    (@set.has_mem.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))))
    r
    (@filter.sets.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))
       (@lattice.has_inf.inf.{(max u v)}
          (filter.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
          (@filter.lattice.has_inf.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
          (@filter.comap.{(max u v) u} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))
             (prod.{u u} α α)
             (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
                @prod.mk.{u u} α α
                  (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
                  (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
             (@uniformity.{u} α _inst_1))
          (@filter.comap.{(max u v) v} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))
             (prod.{v v} β β)
             (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
                @prod.mk.{v v} β β
                  (@prod.snd.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
                  (@prod.snd.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
             (@uniformity.{v} β _inst_2))))
⊢ @has_mem.mem.{(max u v) (max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))
    (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_mem.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    r'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>275      rcases r_in with ⟨t_α, ⟨r_α, r_α_in, h_α⟩, t_β, ⟨r_β, r_β_in, h_β⟩, H⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='r_in'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))) (set.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))) (@set.has_mem.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))) r (@filter.sets.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (@lattice.has_inf.inf.{(max u v)} (filter.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))) (@filter.lattice.has_inf.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))) (@filter.comap.{(max u v) u} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{u u} α α) (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)), @prod.mk.{u u} α α (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)) (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))) (@uniformity.{u} α _inst_1)) (@filter.comap.{(max u v) v} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{v v} β β) (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)), @prod.mk.{v v} β β (@prod.snd.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)) (@prod.snd.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))) (@uniformity.{v} β _inst_2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
a₁ a₂ : α,
b₁ b₂ : β,
r : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
eqv_α :
  @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) a₁ a₂,
eqv_β :
  @has_equiv.equiv.{v+1} β (@setoid_has_equiv.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) b₁ b₂,
r_in :
  @has_mem.mem.{(max u v) (max u v)}
    (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (set.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))))
    (@set.has_mem.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))))
    r
    (@filter.sets.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))
       (@lattice.has_inf.inf.{(max u v)}
          (filter.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
          (@filter.lattice.has_inf.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
          (@filter.comap.{(max u v) u} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))
             (prod.{u u} α α)
             (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
                @prod.mk.{u u} α α
                  (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
                  (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
             (@uniformity.{u} α _inst_1))
          (@filter.comap.{(max u v) v} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))
             (prod.{v v} β β)
             (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
                @prod.mk.{v v} β β
                  (@prod.snd.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
                  (@prod.snd.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
             (@uniformity.{v} β _inst_2))))
⊢ @has_mem.mem.{(max u v) (max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))
    (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_mem.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    r'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
a₁ a₂ : α,
b₁ b₂ : β,
r : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
eqv_α :
  @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) a₁ a₂,
eqv_β :
  @has_equiv.equiv.{v+1} β (@setoid_has_equiv.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) b₁ b₂,
t_α : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
r_α : set.{u} (prod.{u u} α α),
r_α_in :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    r_α
    (@uniformity.{u} α _inst_1),
h_α :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.preimage.{(max u v) u} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{u u} α α)
       (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
          @prod.mk.{u u} α α
            (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
            (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
       r_α)
    t_α,
t_β : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
H :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@has_inter.inter.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
       (@set.has_inter.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
       t_α
       t_β)
    r,
r_β : set.{v} (prod.{v v} β β),
r_β_in :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    r_β
    (@uniformity.{v} β _inst_2),
h_β :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.preimage.{(max u v) v} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{v v} β β)
       (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
          @prod.mk.{v v} β β
            (@prod.snd.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
            (@prod.snd.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
       r_β)
    t_β
⊢ @has_mem.mem.{(max u v) (max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))
    (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_mem.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    r'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>276  </code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
a₁ a₂ : α,
b₁ b₂ : β,
r : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
eqv_α :
  @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) a₁ a₂,
eqv_β :
  @has_equiv.equiv.{v+1} β (@setoid_has_equiv.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) b₁ b₂,
t_α : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
r_α : set.{u} (prod.{u u} α α),
r_α_in :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    r_α
    (@uniformity.{u} α _inst_1),
h_α :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.preimage.{(max u v) u} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{u u} α α)
       (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
          @prod.mk.{u u} α α
            (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
            (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
       r_α)
    t_α,
t_β : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
H :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@has_inter.inter.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
       (@set.has_inter.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
       t_α
       t_β)
    r,
r_β : set.{v} (prod.{v v} β β),
r_β_in :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    r_β
    (@uniformity.{v} β _inst_2),
h_β :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.preimage.{(max u v) v} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{v v} β β)
       (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
          @prod.mk.{v v} β β
            (@prod.snd.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
            (@prod.snd.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
       r_β)
    t_β
⊢ @has_mem.mem.{(max u v) (max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))
    (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_mem.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    r'><code style='font-family: menlo, "Source Code Pro", monospace;'>─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>277      let p_α := λ(p : (α × β) × (α × β)), (p.1.1, p.2.1),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type (max u v) → Type (max u v) → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
a₁ a₂ : α,
b₁ b₂ : β,
r : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
eqv_α :
  @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) a₁ a₂,
eqv_β :
  @has_equiv.equiv.{v+1} β (@setoid_has_equiv.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) b₁ b₂,
t_α : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
r_α : set.{u} (prod.{u u} α α),
r_α_in :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    r_α
    (@uniformity.{u} α _inst_1),
h_α :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.preimage.{(max u v) u} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{u u} α α)
       (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
          @prod.mk.{u u} α α
            (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
            (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
       r_α)
    t_α,
t_β : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
H :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@has_inter.inter.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
       (@set.has_inter.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
       t_α
       t_β)
    r,
r_β : set.{v} (prod.{v v} β β),
r_β_in :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    r_β
    (@uniformity.{v} β _inst_2),
h_β :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.preimage.{(max u v) v} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{v v} β β)
       (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
          @prod.mk.{v v} β β
            (@prod.snd.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
            (@prod.snd.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
       r_β)
    t_β
⊢ @has_mem.mem.{(max u v) (max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))
    (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_mem.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    r'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
a₁ a₂ : α,
b₁ b₂ : β,
r : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
eqv_α :
  @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) a₁ a₂,
eqv_β :
  @has_equiv.equiv.{v+1} β (@setoid_has_equiv.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) b₁ b₂,
t_α : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
r_α : set.{u} (prod.{u u} α α),
r_α_in :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    r_α
    (@uniformity.{u} α _inst_1),
h_α :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.preimage.{(max u v) u} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{u u} α α)
       (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
          @prod.mk.{u u} α α
            (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
            (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
       r_α)
    t_α,
t_β : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
H :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@has_inter.inter.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
       (@set.has_inter.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
       t_α
       t_β)
    r,
r_β : set.{v} (prod.{v v} β β),
r_β_in :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    r_β
    (@uniformity.{v} β _inst_2),
h_β :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.preimage.{(max u v) v} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{v v} β β)
       (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
          @prod.mk.{v v} β β
            (@prod.snd.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
            (@prod.snd.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
       r_β)
    t_β,
p_α : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) → prod.{u u} α α :=
  λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
    @prod.mk.{u u} α α
      (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
      (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
⊢ @has_mem.mem.{(max u v) (max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))
    (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_mem.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    r'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>278      let p_β := λ(p : (α × β) × (α × β)), (p.1.2, p.2.2),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type v}, α → β → prod.{v v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
a₁ a₂ : α,
b₁ b₂ : β,
r : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
eqv_α :
  @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) a₁ a₂,
eqv_β :
  @has_equiv.equiv.{v+1} β (@setoid_has_equiv.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) b₁ b₂,
t_α : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
r_α : set.{u} (prod.{u u} α α),
r_α_in :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    r_α
    (@uniformity.{u} α _inst_1),
h_α :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.preimage.{(max u v) u} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{u u} α α)
       (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
          @prod.mk.{u u} α α
            (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
            (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
       r_α)
    t_α,
t_β : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
H :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@has_inter.inter.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
       (@set.has_inter.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
       t_α
       t_β)
    r,
r_β : set.{v} (prod.{v v} β β),
r_β_in :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    r_β
    (@uniformity.{v} β _inst_2),
h_β :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.preimage.{(max u v) v} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{v v} β β)
       (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
          @prod.mk.{v v} β β
            (@prod.snd.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
            (@prod.snd.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
       r_β)
    t_β,
p_α : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) → prod.{u u} α α :=
  λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
    @prod.mk.{u u} α α
      (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
      (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
⊢ @has_mem.mem.{(max u v) (max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))
    (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_mem.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    r'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
a₁ a₂ : α,
b₁ b₂ : β,
r : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
eqv_α :
  @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) a₁ a₂,
eqv_β :
  @has_equiv.equiv.{v+1} β (@setoid_has_equiv.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) b₁ b₂,
t_α : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
r_α : set.{u} (prod.{u u} α α),
r_α_in :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    r_α
    (@uniformity.{u} α _inst_1),
h_α :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.preimage.{(max u v) u} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{u u} α α)
       (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
          @prod.mk.{u u} α α
            (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
            (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
       r_α)
    t_α,
t_β : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
H :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@has_inter.inter.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
       (@set.has_inter.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
       t_α
       t_β)
    r,
r_β : set.{v} (prod.{v v} β β),
r_β_in :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    r_β
    (@uniformity.{v} β _inst_2),
h_β :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.preimage.{(max u v) v} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{v v} β β)
       (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
          @prod.mk.{v v} β β
            (@prod.snd.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
            (@prod.snd.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
       r_β)
    t_β,
p_α : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) → prod.{u u} α α :=
  λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
    @prod.mk.{u u} α α
      (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
      (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)),
p_β : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) → prod.{v v} β β :=
  λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
    @prod.mk.{v v} β β
      (@prod.snd.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
      (@prod.snd.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
⊢ @has_mem.mem.{(max u v) (max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))
    (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_mem.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    r'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>279      have key_α : p_α ((a₁, b₁), (a₂, b₂)) ∈ r_α, { simp [p_α, eqv_α r_α r_α_in] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='p_α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r_α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='p_α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eqv_α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r_α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r_α_in'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) → prod.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type (max u v)}, α → β → prod.{(max u v) (max u v)} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) → prod.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) a₁ a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) r_α (@uniformity.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
a₁ a₂ : α,
b₁ b₂ : β,
r : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
eqv_α :
  @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) a₁ a₂,
eqv_β :
  @has_equiv.equiv.{v+1} β (@setoid_has_equiv.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) b₁ b₂,
t_α : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
r_α : set.{u} (prod.{u u} α α),
r_α_in :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    r_α
    (@uniformity.{u} α _inst_1),
h_α :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.preimage.{(max u v) u} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{u u} α α)
       (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
          @prod.mk.{u u} α α
            (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
            (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
       r_α)
    t_α,
t_β : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
H :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@has_inter.inter.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
       (@set.has_inter.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
       t_α
       t_β)
    r,
r_β : set.{v} (prod.{v v} β β),
r_β_in :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    r_β
    (@uniformity.{v} β _inst_2),
h_β :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.preimage.{(max u v) v} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{v v} β β)
       (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
          @prod.mk.{v v} β β
            (@prod.snd.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
            (@prod.snd.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
       r_β)
    t_β,
p_α : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) → prod.{u u} α α :=
  λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
    @prod.mk.{u u} α α
      (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
      (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)),
p_β : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) → prod.{v v} β β :=
  λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
    @prod.mk.{v v} β β
      (@prod.snd.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
      (@prod.snd.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
⊢ @has_mem.mem.{(max u v) (max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))
    (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_mem.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    r'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
a₁ a₂ : α,
b₁ b₂ : β,
r : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
eqv_α :
  @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) a₁ a₂,
eqv_β :
  @has_equiv.equiv.{v+1} β (@setoid_has_equiv.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) b₁ b₂,
t_α : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
r_α : set.{u} (prod.{u u} α α),
r_α_in :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    r_α
    (@uniformity.{u} α _inst_1),
h_α :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.preimage.{(max u v) u} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{u u} α α)
       (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
          @prod.mk.{u u} α α
            (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
            (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
       r_α)
    t_α,
t_β : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
H :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@has_inter.inter.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
       (@set.has_inter.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
       t_α
       t_β)
    r,
r_β : set.{v} (prod.{v v} β β),
r_β_in :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    r_β
    (@uniformity.{v} β _inst_2),
h_β :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.preimage.{(max u v) v} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{v v} β β)
       (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
          @prod.mk.{v v} β β
            (@prod.snd.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
            (@prod.snd.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
       r_β)
    t_β,
p_α : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) → prod.{u u} α α :=
  λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
    @prod.mk.{u u} α α
      (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
      (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)),
p_β : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) → prod.{v v} β β :=
  λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
    @prod.mk.{v v} β β
      (@prod.snd.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
      (@prod.snd.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
⊢ @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (p_α
       (@prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) (@prod.mk.{u v} α β a₁ b₁)
          (@prod.mk.{u v} α β a₂ b₂)))
    r_α

α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
a₁ a₂ : α,
b₁ b₂ : β,
r : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
eqv_α :
  @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) a₁ a₂,
eqv_β :
  @has_equiv.equiv.{v+1} β (@setoid_has_equiv.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) b₁ b₂,
t_α : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
r_α : set.{u} (prod.{u u} α α),
r_α_in :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    r_α
    (@uniformity.{u} α _inst_1),
h_α :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.preimage.{(max u v) u} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{u u} α α)
       (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
          @prod.mk.{u u} α α
            (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
            (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
       r_α)
    t_α,
t_β : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
H :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@has_inter.inter.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
       (@set.has_inter.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
       t_α
       t_β)
    r,
r_β : set.{v} (prod.{v v} β β),
r_β_in :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    r_β
    (@uniformity.{v} β _inst_2),
h_β :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.preimage.{(max u v) v} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{v v} β β)
       (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
          @prod.mk.{v v} β β
            (@prod.snd.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
            (@prod.snd.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
       r_β)
    t_β,
p_α : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) → prod.{u u} α α :=
  λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
    @prod.mk.{u u} α α
      (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
      (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)),
p_β : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) → prod.{v v} β β :=
  λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
    @prod.mk.{v v} β β
      (@prod.snd.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
      (@prod.snd.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)),
key_α :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (p_α
       (@prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) (@prod.mk.{u v} α β a₁ b₁)
          (@prod.mk.{u v} α β a₂ b₂)))
    r_α
⊢ @has_mem.mem.{(max u v) (max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))
    (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_mem.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    r'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
a₁ a₂ : α,
b₁ b₂ : β,
r : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
eqv_α :
  @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) a₁ a₂,
eqv_β :
  @has_equiv.equiv.{v+1} β (@setoid_has_equiv.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) b₁ b₂,
t_α : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
r_α : set.{u} (prod.{u u} α α),
r_α_in :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    r_α
    (@uniformity.{u} α _inst_1),
h_α :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.preimage.{(max u v) u} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{u u} α α)
       (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
          @prod.mk.{u u} α α
            (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
            (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
       r_α)
    t_α,
t_β : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
H :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@has_inter.inter.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
       (@set.has_inter.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
       t_α
       t_β)
    r,
r_β : set.{v} (prod.{v v} β β),
r_β_in :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    r_β
    (@uniformity.{v} β _inst_2),
h_β :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.preimage.{(max u v) v} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{v v} β β)
       (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
          @prod.mk.{v v} β β
            (@prod.snd.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
            (@prod.snd.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
       r_β)
    t_β,
p_α : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) → prod.{u u} α α :=
  λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
    @prod.mk.{u u} α α
      (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
      (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)),
p_β : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) → prod.{v v} β β :=
  λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
    @prod.mk.{v v} β β
      (@prod.snd.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
      (@prod.snd.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
⊢ @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (p_α
       (@prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) (@prod.mk.{u v} α β a₁ b₁)
          (@prod.mk.{u v} α β a₂ b₂)))
    r_α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
a₁ a₂ : α,
b₁ b₂ : β,
r : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
eqv_α :
  @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) a₁ a₂,
eqv_β :
  @has_equiv.equiv.{v+1} β (@setoid_has_equiv.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) b₁ b₂,
t_α : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
r_α : set.{u} (prod.{u u} α α),
r_α_in :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    r_α
    (@uniformity.{u} α _inst_1),
h_α :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.preimage.{(max u v) u} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{u u} α α)
       (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
          @prod.mk.{u u} α α
            (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
            (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
       r_α)
    t_α,
t_β : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
H :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@has_inter.inter.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
       (@set.has_inter.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
       t_α
       t_β)
    r,
r_β : set.{v} (prod.{v v} β β),
r_β_in :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    r_β
    (@uniformity.{v} β _inst_2),
h_β :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.preimage.{(max u v) v} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{v v} β β)
       (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
          @prod.mk.{v v} β β
            (@prod.snd.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
            (@prod.snd.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
       r_β)
    t_β,
p_α : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) → prod.{u u} α α :=
  λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
    @prod.mk.{u u} α α
      (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
      (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)),
p_β : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) → prod.{v v} β β :=
  λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
    @prod.mk.{v v} β β
      (@prod.snd.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
      (@prod.snd.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)),
key_α :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (p_α
       (@prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) (@prod.mk.{u v} α β a₁ b₁)
          (@prod.mk.{u v} α β a₂ b₂)))
    r_α
⊢ @has_mem.mem.{(max u v) (max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))
    (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_mem.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    r'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>280      have key_β : p_β ((a₁, b₁), (a₂, b₂)) ∈ r_β, { simp [p_β, eqv_β r_β r_β_in] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='p_β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='r_β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='p_β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eqv_β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r_β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r_β_in'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) → prod.{v v} β β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type (max u v)}, α → β → prod.{(max u v) (max u v)} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{v} (prod.{v v} β β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) → prod.{v v} β β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_equiv.equiv.{v+1} β (@setoid_has_equiv.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) b₁ b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{v} (prod.{v v} β β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β)) (@filter.has_mem.{v} (prod.{v v} β β)) r_β (@uniformity.{v} β _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
a₁ a₂ : α,
b₁ b₂ : β,
r : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
eqv_α :
  @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) a₁ a₂,
eqv_β :
  @has_equiv.equiv.{v+1} β (@setoid_has_equiv.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) b₁ b₂,
t_α : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
r_α : set.{u} (prod.{u u} α α),
r_α_in :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    r_α
    (@uniformity.{u} α _inst_1),
h_α :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.preimage.{(max u v) u} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{u u} α α)
       (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
          @prod.mk.{u u} α α
            (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
            (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
       r_α)
    t_α,
t_β : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
H :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@has_inter.inter.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
       (@set.has_inter.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
       t_α
       t_β)
    r,
r_β : set.{v} (prod.{v v} β β),
r_β_in :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    r_β
    (@uniformity.{v} β _inst_2),
h_β :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.preimage.{(max u v) v} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{v v} β β)
       (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
          @prod.mk.{v v} β β
            (@prod.snd.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
            (@prod.snd.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
       r_β)
    t_β,
p_α : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) → prod.{u u} α α :=
  λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
    @prod.mk.{u u} α α
      (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
      (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)),
p_β : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) → prod.{v v} β β :=
  λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
    @prod.mk.{v v} β β
      (@prod.snd.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
      (@prod.snd.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)),
key_α :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (p_α
       (@prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) (@prod.mk.{u v} α β a₁ b₁)
          (@prod.mk.{u v} α β a₂ b₂)))
    r_α
⊢ @has_mem.mem.{(max u v) (max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))
    (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_mem.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    r'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
a₁ a₂ : α,
b₁ b₂ : β,
r : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
eqv_α :
  @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) a₁ a₂,
eqv_β :
  @has_equiv.equiv.{v+1} β (@setoid_has_equiv.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) b₁ b₂,
t_α : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
r_α : set.{u} (prod.{u u} α α),
r_α_in :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    r_α
    (@uniformity.{u} α _inst_1),
h_α :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.preimage.{(max u v) u} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{u u} α α)
       (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
          @prod.mk.{u u} α α
            (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
            (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
       r_α)
    t_α,
t_β : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
H :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@has_inter.inter.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
       (@set.has_inter.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
       t_α
       t_β)
    r,
r_β : set.{v} (prod.{v v} β β),
r_β_in :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    r_β
    (@uniformity.{v} β _inst_2),
h_β :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.preimage.{(max u v) v} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{v v} β β)
       (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
          @prod.mk.{v v} β β
            (@prod.snd.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
            (@prod.snd.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
       r_β)
    t_β,
p_α : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) → prod.{u u} α α :=
  λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
    @prod.mk.{u u} α α
      (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
      (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)),
p_β : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) → prod.{v v} β β :=
  λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
    @prod.mk.{v v} β β
      (@prod.snd.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
      (@prod.snd.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)),
key_α :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (p_α
       (@prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) (@prod.mk.{u v} α β a₁ b₁)
          (@prod.mk.{u v} α β a₂ b₂)))
    r_α
⊢ @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
    (p_β
       (@prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) (@prod.mk.{u v} α β a₁ b₁)
          (@prod.mk.{u v} α β a₂ b₂)))
    r_β

α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
a₁ a₂ : α,
b₁ b₂ : β,
r : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
eqv_α :
  @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) a₁ a₂,
eqv_β :
  @has_equiv.equiv.{v+1} β (@setoid_has_equiv.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) b₁ b₂,
t_α : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
r_α : set.{u} (prod.{u u} α α),
r_α_in :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    r_α
    (@uniformity.{u} α _inst_1),
h_α :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.preimage.{(max u v) u} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{u u} α α)
       (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
          @prod.mk.{u u} α α
            (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
            (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
       r_α)
    t_α,
t_β : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
H :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@has_inter.inter.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
       (@set.has_inter.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
       t_α
       t_β)
    r,
r_β : set.{v} (prod.{v v} β β),
r_β_in :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    r_β
    (@uniformity.{v} β _inst_2),
h_β :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.preimage.{(max u v) v} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{v v} β β)
       (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
          @prod.mk.{v v} β β
            (@prod.snd.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
            (@prod.snd.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
       r_β)
    t_β,
p_α : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) → prod.{u u} α α :=
  λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
    @prod.mk.{u u} α α
      (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
      (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)),
p_β : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) → prod.{v v} β β :=
  λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
    @prod.mk.{v v} β β
      (@prod.snd.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
      (@prod.snd.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)),
key_α :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (p_α
       (@prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) (@prod.mk.{u v} α β a₁ b₁)
          (@prod.mk.{u v} α β a₂ b₂)))
    r_α,
key_β :
  @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
    (p_β
       (@prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) (@prod.mk.{u v} α β a₁ b₁)
          (@prod.mk.{u v} α β a₂ b₂)))
    r_β
⊢ @has_mem.mem.{(max u v) (max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))
    (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_mem.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    r'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
a₁ a₂ : α,
b₁ b₂ : β,
r : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
eqv_α :
  @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) a₁ a₂,
eqv_β :
  @has_equiv.equiv.{v+1} β (@setoid_has_equiv.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) b₁ b₂,
t_α : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
r_α : set.{u} (prod.{u u} α α),
r_α_in :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    r_α
    (@uniformity.{u} α _inst_1),
h_α :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.preimage.{(max u v) u} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{u u} α α)
       (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
          @prod.mk.{u u} α α
            (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
            (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
       r_α)
    t_α,
t_β : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
H :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@has_inter.inter.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
       (@set.has_inter.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
       t_α
       t_β)
    r,
r_β : set.{v} (prod.{v v} β β),
r_β_in :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    r_β
    (@uniformity.{v} β _inst_2),
h_β :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.preimage.{(max u v) v} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{v v} β β)
       (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
          @prod.mk.{v v} β β
            (@prod.snd.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
            (@prod.snd.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
       r_β)
    t_β,
p_α : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) → prod.{u u} α α :=
  λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
    @prod.mk.{u u} α α
      (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
      (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)),
p_β : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) → prod.{v v} β β :=
  λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
    @prod.mk.{v v} β β
      (@prod.snd.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
      (@prod.snd.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)),
key_α :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (p_α
       (@prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) (@prod.mk.{u v} α β a₁ b₁)
          (@prod.mk.{u v} α β a₂ b₂)))
    r_α
⊢ @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
    (p_β
       (@prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) (@prod.mk.{u v} α β a₁ b₁)
          (@prod.mk.{u v} α β a₂ b₂)))
    r_β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
a₁ a₂ : α,
b₁ b₂ : β,
r : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
eqv_α :
  @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) a₁ a₂,
eqv_β :
  @has_equiv.equiv.{v+1} β (@setoid_has_equiv.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) b₁ b₂,
t_α : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
r_α : set.{u} (prod.{u u} α α),
r_α_in :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    r_α
    (@uniformity.{u} α _inst_1),
h_α :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.preimage.{(max u v) u} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{u u} α α)
       (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
          @prod.mk.{u u} α α
            (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
            (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
       r_α)
    t_α,
t_β : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
H :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@has_inter.inter.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
       (@set.has_inter.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
       t_α
       t_β)
    r,
r_β : set.{v} (prod.{v v} β β),
r_β_in :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    r_β
    (@uniformity.{v} β _inst_2),
h_β :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.preimage.{(max u v) v} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{v v} β β)
       (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
          @prod.mk.{v v} β β
            (@prod.snd.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
            (@prod.snd.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
       r_β)
    t_β,
p_α : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) → prod.{u u} α α :=
  λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
    @prod.mk.{u u} α α
      (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
      (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)),
p_β : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) → prod.{v v} β β :=
  λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
    @prod.mk.{v v} β β
      (@prod.snd.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
      (@prod.snd.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)),
key_α :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (p_α
       (@prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) (@prod.mk.{u v} α β a₁ b₁)
          (@prod.mk.{u v} α β a₂ b₂)))
    r_α,
key_β :
  @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
    (p_β
       (@prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) (@prod.mk.{u v} α β a₁ b₁)
          (@prod.mk.{u v} α β a₂ b₂)))
    r_β
⊢ @has_mem.mem.{(max u v) (max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))
    (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_mem.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    r'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>281      exact H ⟨h_α key_α, h_β key_β⟩ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h_α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='key_α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h_β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='key_β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))) (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))) (@has_inter.inter.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))) (@set.has_inter.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))) t_α t_β) r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))) (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))) (@set.preimage.{(max u v) u} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{u u} α α) (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)), @prod.mk.{u u} α α (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)) (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))) r_α) t_α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (p_α (@prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) (@prod.mk.{u v} α β a₁ b₁) (@prod.mk.{u v} α β a₂ b₂))) r_α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))) (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))) (@set.preimage.{(max u v) v} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{v v} β β) (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)), @prod.mk.{v v} β β (@prod.snd.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)) (@prod.snd.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))) r_β) t_β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β)) (p_β (@prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) (@prod.mk.{u v} α β a₁ b₁) (@prod.mk.{u v} α β a₂ b₂))) r_β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : uniform_space.{u} α,
_inst_2 : uniform_space.{v} β,
a₁ a₂ : α,
b₁ b₂ : β,
r : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
eqv_α :
  @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) a₁ a₂,
eqv_β :
  @has_equiv.equiv.{v+1} β (@setoid_has_equiv.{v+1} β (@uniform_space.separation_setoid.{v} β _inst_2)) b₁ b₂,
t_α : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
r_α : set.{u} (prod.{u u} α α),
r_α_in :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    r_α
    (@uniformity.{u} α _inst_1),
h_α :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.preimage.{(max u v) u} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{u u} α α)
       (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
          @prod.mk.{u u} α α
            (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
            (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
       r_α)
    t_α,
t_β : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
H :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@has_inter.inter.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
       (@set.has_inter.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
       t_α
       t_β)
    r,
r_β : set.{v} (prod.{v v} β β),
r_β_in :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    r_β
    (@uniformity.{v} β _inst_2),
h_β :
  @has_subset.subset.{(max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_subset.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.preimage.{(max u v) v} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (prod.{v v} β β)
       (λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
          @prod.mk.{v v} β β
            (@prod.snd.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
            (@prod.snd.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)))
       r_β)
    t_β,
p_α : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) → prod.{u u} α α :=
  λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
    @prod.mk.{u u} α α
      (@prod.fst.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
      (@prod.fst.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)),
p_β : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) → prod.{v v} β β :=
  λ (p : prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)),
    @prod.mk.{v v} β β
      (@prod.snd.{u v} α β (@prod.fst.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p))
      (@prod.snd.{u v} α β (@prod.snd.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) p)),
key_α :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (p_α
       (@prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) (@prod.mk.{u v} α β a₁ b₁)
          (@prod.mk.{u v} α β a₂ b₂)))
    r_α,
key_β :
  @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
    (p_β
       (@prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) (@prod.mk.{u v} α β a₁ b₁)
          (@prod.mk.{u v} α β a₂ b₂)))
    r_β
⊢ @has_mem.mem.{(max u v) (max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))
    (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@set.has_mem.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)))
    (@prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    r'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>282  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>283  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>284  instance separated.prod [separated α] [separated β] : separated (α × β) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='separated'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='separated'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='separated'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;line&#x27;: 41, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 41, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 41, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Π (α : Type u) [_inst_4 : uniform_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type v) [_inst_4 : uniform_space.{v} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u) [_inst_4 : uniform_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>285  separated_def.2 $ assume x y H, prod.ext</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='separated_def'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/prod.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_4 : uniform_space.{u} α], iff (@separated.{u} α _inst_4) (∀ (x y : α), (∀ (r : set.{u} (prod.{u u} α α)), @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) r (@uniformity.{u} α _inst_4) → @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α x y) r) → @eq.{u+1} α x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='prod.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (r : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))), @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))) (filter.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))) (@filter.has_mem.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))) r (@uniformity.{(max u v)} (prod.{u v} α β) (@prod.uniform_space.{u v} α β _inst_1 _inst_2)) → @has_mem.mem.{(max u v) (max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))) (@set.has_mem.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))) (@prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) x y) r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {p q : prod.{u_1 u_2} α β}, @eq.{u_1+1} α (@prod.fst.{u_1 u_2} α β p) (@prod.fst.{u_1 u_2} α β q) → @eq.{u_2+1} β (@prod.snd.{u_1 u_2} α β p) (@prod.snd.{u_1 u_2} α β q) → @eq.{(max (u_1+1) (u_2+1))} (prod.{u_1 u_2} α β) p q'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>286    (eq_of_separated_of_uniform_continuous uniform_continuous_fst H)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='uniform_space.eq_of_separated_of_uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='uniform_continuous_fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 214, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 726, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : uniform_space.{u} α] [_inst_2 : uniform_space.{v} β] [_inst_4 : @separated.{v} β _inst_2] {f : α → β} {x y : α}, @uniform_continuous.{u v} α β _inst_1 _inst_2 f → @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) x y → @eq.{v+1} β (f x) (f y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], @uniform_continuous.{(max u_1 u_2) u_1} (prod.{u_1 u_2} α β) α (@prod.uniform_space.{u_1 u_2} α β _inst_1 _inst_2) _inst_1 (λ (p : prod.{u_1 u_2} α β), @prod.fst.{u_1 u_2} α β p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (r : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))), @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))) (filter.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))) (@filter.has_mem.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))) r (@uniformity.{(max u v)} (prod.{u v} α β) (@prod.uniform_space.{u v} α β _inst_1 _inst_2)) → @has_mem.mem.{(max u v) (max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))) (@set.has_mem.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))) (@prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) x y) r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>287    (eq_of_separated_of_uniform_continuous uniform_continuous_snd H)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='uniform_space.eq_of_separated_of_uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='uniform_continuous_snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 214, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 729, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : uniform_space.{u} α] [_inst_2 : uniform_space.{v} β] [_inst_4 : @separated.{v} β _inst_2] {f : α → β} {x y : α}, @uniform_continuous.{u v} α β _inst_1 _inst_2 f → @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α (@uniform_space.separation_setoid.{u} α _inst_1)) x y → @eq.{v+1} β (f x) (f y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], @uniform_continuous.{(max u_1 u_2) u_2} (prod.{u_1 u_2} α β) β (@prod.uniform_space.{u_1 u_2} α β _inst_1 _inst_2) _inst_2 (λ (p : prod.{u_1 u_2} α β), @prod.snd.{u_1 u_2} α β p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (r : set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))), @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))) (filter.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))) (@filter.has_mem.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))) r (@uniformity.{(max u v)} (prod.{u v} α β) (@prod.uniform_space.{u v} α β _inst_1 _inst_2)) → @has_mem.mem.{(max u v) (max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β)) (set.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))) (@set.has_mem.{(max u v)} (prod.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β))) (@prod.mk.{(max u v) (max u v)} (prod.{u v} α β) (prod.{u v} α β) x y) r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>288  end uniform_space</code></pre>
</body>