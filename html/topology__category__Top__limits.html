<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2017 Scott Morrison. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Patrick Massot, Scott Morrison, Mario Carneiro</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  import topology.category.Top.basic</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/Top/basic.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  import category_theory.limits.types</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/types.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  import category_theory.limits.preserves</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/preserves.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  open topological_space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  open category_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  open category_theory.limits</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  universe u</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  namespace Top</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  variables {J : Type u} [small_category J]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='category_theory.small_category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 87, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Type u → Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='A `small_category` has objects and morphisms in the same universe level.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  local notation `forget` := forget Top</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='category_theory.forget'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/Top/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Π (C : Type (u+1)) [_inst_1 : category_theory.concrete_category.{u} C], @category_theory.functor.{u u u+1 u+1} C (@category_theory.concrete_category.to_category.{u} C _inst_1) (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='The forgetful functor from a concrete category to `Type u`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The category of topological spaces and continuous maps.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  def limit (F : J ⥤ Top.{u}) : cone F :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  { X := ⟨limit (F ⋙ forget), ⨅j, (F.obj j).str.induced (limit.π (F ⋙ forget) j)⟩,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24    π :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25    { app := λ j, ⟨limit.π (F ⋙ forget) j, continuous_iff_le_induced.mpr (lattice.infi_le _ _)⟩,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26      naturality&#x27; := λ j j&#x27; f, subtype.eq ((limit.cone (F ⋙ forget)).π.naturality f) } }</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  def limit_is_limit (F : J ⥤ Top.{u}) : is_limit (limit F) :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  by { refine is_limit.of_faithful forget (limit.is_limit _) (λ s, ⟨_, _⟩) (λ s, rfl),</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30       exact continuous_iff_coinduced_le.mpr (lattice.le_infi $ λ j,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31         coinduced_le_iff_le_induced.mp $ continuous_iff_coinduced_le.mp (s.π.app j).property) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='blue'><a title='continuous_iff_coinduced_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 401, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α β : Type u} {f : α → β} {t₁ : topological_space.{u} α} {t₂ : topological_space.{u} β}, iff (@continuous.{u u} α β t₁ t₂ f) (@has_le.le.{u} (topological_space.{u} β) (@preorder.to_has_le.{u} (topological_space.{u} β) (@partial_order.to_preorder.{u} (topological_space.{u} β) (@topological_space.partial_order.{u} β))) (@topological_space.coinduced.{u u} α β f t₁) t₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{u u+1} J _inst_1 Top.{u} (@category_theory.bundled_hom.category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u})) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='lime'><a title='J : Type u,
_inst_1 : category_theory.small_category.{u} J,
F :
  @category_theory.functor.{u u u u+1} J _inst_1 Top.{u}
    (@category_theory.bundled_hom.category.{u} topological_space.{u}
       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
          Top.concrete_category_continuous.{u})),
s :
  @category_theory.limits.cone.{u u+1} J _inst_1 Top.{u}
    (@category_theory.bundled_hom.category.{u} topological_space.{u}
       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
          Top.concrete_category_continuous.{u}))
    F
⊢ @continuous.{u u}
    (@category_theory.bundled.α.{u u} topological_space.{u}
       (@category_theory.limits.cone.X.{u u+1} J _inst_1 Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))
          F
          s))
    (@category_theory.bundled.α.{u u} topological_space.{u}
       (@category_theory.limits.cone.X.{u u+1} J _inst_1 Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))
          F
          (@Top.limit.{u} J _inst_1 F)))
    (@category_theory.bundled.str.{u u} topological_space.{u}
       (@category_theory.limits.cone.X.{u u+1} J _inst_1 Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))
          F
          s))
    (@category_theory.bundled.str.{u u} topological_space.{u}
       (@category_theory.limits.cone.X.{u u+1} J _inst_1 Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))
          F
          (@Top.limit.{u} J _inst_1 F)))
    (λ
     (v :
       @category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u}
         (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
            (@category_theory.bundled_hom.category.{u} topological_space.{u}
               (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                  @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
               (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                  continuous.{u u}
                  Top.concrete_category_continuous.{u}))
            (Type u)
            category_theory.types.{u}
            F
            (@category_theory.forget.{u} Top.{u}
               (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                  (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                     @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                  (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                     continuous.{u u}
                     Top.concrete_category_continuous.{u}))))
         (@category_theory.functor.map_cone.{u u+1 u+1} J _inst_1 Top.{u}
            (@category_theory.bundled_hom.category.{u} topological_space.{u}
               (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                  @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
               (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                  continuous.{u u}
                  Top.concrete_category_continuous.{u}))
            (Type u)
            category_theory.types.{u}
            F
            (@category_theory.forget.{u} Top.{u}
               (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                  (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                     @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                  (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                     continuous.{u u}
                     Top.concrete_category_continuous.{u})))
            s)),
       @subtype.mk.{u+1}
         (Π (j : J),
            @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
              (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                 (@category_theory.bundled_hom.category.{u} topological_space.{u}
                    (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                       @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                    (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                       continuous.{u u}
                       Top.concrete_category_continuous.{u}))
                 (Type u)
                 category_theory.types.{u}
                 F
                 (@category_theory.forget.{u} Top.{u}
                    (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                          continuous.{u u}
                          Top.concrete_category_continuous.{u}))))
              j)
         (λ
          (x :
            Π (j : J),
              @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                   (@category_theory.bundled_hom.category.{u} topological_space.{u}
                      (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                         @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                         continuous.{u u}
                         Top.concrete_category_continuous.{u}))
                   (Type u)
                   category_theory.types.{u}
                   F
                   (@category_theory.forget.{u} Top.{u}
                      (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                         (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                            @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                         (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                            continuous.{u u}
                            Top.concrete_category_continuous.{u}))))
                j),
            @has_mem.mem.{u u}
              (Π (j : J),
                 @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                   (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                      (@category_theory.bundled_hom.category.{u} topological_space.{u}
                         (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                            @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                         (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                            continuous.{u u}
                            Top.concrete_category_continuous.{u}))
                      (Type u)
                      category_theory.types.{u}
                      F
                      (@category_theory.forget.{u} Top.{u}
                         (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                            (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                               @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                            (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                               continuous.{u u}
                               Top.concrete_category_continuous.{u}))))
                   j)
              (set.{u}
                 (Π (j : J),
                    @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                      (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                         (@category_theory.bundled_hom.category.{u} topological_space.{u}
                            (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                               @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                            (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                               continuous.{u u}
                               Top.concrete_category_continuous.{u}))
                         (Type u)
                         category_theory.types.{u}
                         F
                         (@category_theory.forget.{u} Top.{u}
                            (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                               (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                                  @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                               (@category_theory.unbundled_hom.bundled_hom.{u}
                                  (λ (α : Type u), topological_space.{u} α)
                                  continuous.{u u}
                                  Top.concrete_category_continuous.{u}))))
                      j))
              (@set.has_mem.{u}
                 (Π (j : J),
                    @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                      (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                         (@category_theory.bundled_hom.category.{u} topological_space.{u}
                            (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                               @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                            (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                               continuous.{u u}
                               Top.concrete_category_continuous.{u}))
                         (Type u)
                         category_theory.types.{u}
                         F
                         (@category_theory.forget.{u} Top.{u}
                            (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                               (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                                  @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                               (@category_theory.unbundled_hom.bundled_hom.{u}
                                  (λ (α : Type u), topological_space.{u} α)
                                  continuous.{u u}
                                  Top.concrete_category_continuous.{u}))))
                      j))
              x
              (@category_theory.functor.sections.{u u u} J _inst_1
                 (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                    (@category_theory.bundled_hom.category.{u} topological_space.{u}
                       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                          continuous.{u u}
                          Top.concrete_category_continuous.{u}))
                    (Type u)
                    category_theory.types.{u}
                    F
                    (@category_theory.forget.{u} Top.{u}
                       (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                             continuous.{u u}
                             Top.concrete_category_continuous.{u}))))))
         (λ (j : J),
            @category_theory.nat_trans.app.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
              (@category_theory.functor.obj.{u u u+1 u+1} (Type u) category_theory.types.{u}
                 (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                 (@category_theory.functor.category.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                 (@category_theory.functor.const.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                 (@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u}
                    (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                       (@category_theory.bundled_hom.category.{u} topological_space.{u}
                          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                             continuous.{u u}
                             Top.concrete_category_continuous.{u}))
                       (Type u)
                       category_theory.types.{u}
                       F
                       (@category_theory.forget.{u} Top.{u}
                          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                             (@category_theory.unbundled_hom.bundled_hom.{u}
                                (λ (α : Type u), topological_space.{u} α)
                                continuous.{u u}
                                Top.concrete_category_continuous.{u}))))
                    (@category_theory.functor.map_cone.{u u+1 u+1} J _inst_1 Top.{u}
                       (@category_theory.bundled_hom.category.{u} topological_space.{u}
                          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                             continuous.{u u}
                             Top.concrete_category_continuous.{u}))
                       (Type u)
                       category_theory.types.{u}
                       F
                       (@category_theory.forget.{u} Top.{u}
                          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                             (@category_theory.unbundled_hom.bundled_hom.{u}
                                (λ (α : Type u), topological_space.{u} α)
                                continuous.{u u}
                                Top.concrete_category_continuous.{u})))
                       s)))
              (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                 (@category_theory.bundled_hom.category.{u} topological_space.{u}
                    (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                       @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                    (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                       continuous.{u u}
                       Top.concrete_category_continuous.{u}))
                 (Type u)
                 category_theory.types.{u}
                 F
                 (@category_theory.forget.{u} Top.{u}
                    (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                          continuous.{u u}
                          Top.concrete_category_continuous.{u}))))
              (@category_theory.limits.cone.π.{u u+1} J _inst_1 (Type u) category_theory.types.{u}
                 (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                    (@category_theory.bundled_hom.category.{u} topological_space.{u}
                       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                          continuous.{u u}
                          Top.concrete_category_continuous.{u}))
                    (Type u)
                    category_theory.types.{u}
                    F
                    (@category_theory.forget.{u} Top.{u}
                       (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                             continuous.{u u}
                             Top.concrete_category_continuous.{u}))))
                 (@category_theory.functor.map_cone.{u u+1 u+1} J _inst_1 Top.{u}
                    (@category_theory.bundled_hom.category.{u} topological_space.{u}
                       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                          continuous.{u u}
                          Top.concrete_category_continuous.{u}))
                    (Type u)
                    category_theory.types.{u}
                    F
                    (@category_theory.forget.{u} Top.{u}
                       (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                             continuous.{u u}
                             Top.concrete_category_continuous.{u})))
                    s))
              j
              v)
         (@category_theory.limits.types.limit_is_limit._proof_1.{u} J _inst_1
            (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
               (@category_theory.bundled_hom.category.{u} topological_space.{u}
                  (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                     @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                  (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                     continuous.{u u}
                     Top.concrete_category_continuous.{u}))
               (Type u)
               category_theory.types.{u}
               F
               (@category_theory.forget.{u} Top.{u}
                  (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                     (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                        @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                     (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                        continuous.{u u}
                        Top.concrete_category_continuous.{u}))))
            (@category_theory.functor.map_cone.{u u+1 u+1} J _inst_1 Top.{u}
               (@category_theory.bundled_hom.category.{u} topological_space.{u}
                  (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                     @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                  (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                     continuous.{u u}
                     Top.concrete_category_continuous.{u}))
               (Type u)
               category_theory.types.{u}
               F
               (@category_theory.forget.{u} Top.{u}
                  (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                     (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                        @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                     (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                        continuous.{u u}
                        Top.concrete_category_continuous.{u})))
               s)
            v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  instance Top_has_limits : has_limits.{u} Top.{u} :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='category_theory.limits.has_limits'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='Top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 416, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/Top/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Π (C : Type u) [𝒞 : category_theory.category.{v u} C], Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='`C` has all (small) limits if it has limits of every shape.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The category of topological spaces and continuous maps.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  { has_limits_of_shape := λ J 𝒥,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝒥'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='category_theory.small_category.{u} J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35    { has_limit := λ F, by exactI { cone := limit F, is_limit := limit_is_limit F } } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='Top.limit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='Top.limit_is_limit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 22, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J 𝒥 Top.{u} (@category_theory.bundled_hom.category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u}))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] (F : @category_theory.functor.{u u u u+1} J _inst_1 Top.{u} (@category_theory.bundled_hom.category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u}))), @category_theory.limits.cone.{u u+1} J _inst_1 Top.{u} (@category_theory.bundled_hom.category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u})) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] (F : @category_theory.functor.{u u u u+1} J _inst_1 Top.{u} (@category_theory.bundled_hom.category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u}))), @category_theory.limits.is_limit.{u u+1} J _inst_1 Top.{u} (@category_theory.bundled_hom.category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u})) F (@Top.limit.{u} J _inst_1 F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.functor.{u u u u+1} J 𝒥 Top.{u} (@category_theory.bundled_hom.category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u}))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='lime'><a title='J : Type u,
𝒥 : category_theory.small_category.{u} J,
F :
  @category_theory.functor.{u u u u+1} J 𝒥 Top.{u}
    (@category_theory.bundled_hom.category.{u} topological_space.{u}
       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
          Top.concrete_category_continuous.{u}))
⊢ @category_theory.limits.has_limit.{u u+1} J 𝒥 Top.{u}
    (@category_theory.bundled_hom.category.{u} topological_space.{u}
       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
          Top.concrete_category_continuous.{u}))
    F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  instance forget_preserves_limits : preserves_limits (forget : Top.{u} ⥤ Type u) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='category_theory.limits.preserves_limits'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.forget'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/preserves.lean&#x27;, &#x27;line&#x27;: 57, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/Top/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v u₂} D], @category_theory.functor.{v v u₁ u₂} C 𝒞 D 𝒟 → Type (max u₁ u₂ (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (C : Type (u+1)) [_inst_1 : category_theory.concrete_category.{u} C], @category_theory.functor.{u u u+1 u+1} C (@category_theory.concrete_category.to_category.{u} C _inst_1) (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (C : Type (u+1)) [_inst_1 : category_theory.category.{u u+1} C] (D : Type (u+1)) [_inst_2 : category_theory.category.{u u+1} D], Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='orange'><a title='The forgetful functor from a concrete category to `Type u`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The category of topological spaces and continuous maps.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  { preserves_limits_of_shape := λ J 𝒥,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝒥'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='category_theory.small_category.{u} J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39    { preserves_limit := λ F,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J 𝒥 Top.{u} (@category_theory.concrete_category.to_category.{u} Top.{u} (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u})))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40      by exactI preserves_limit_of_preserves_limit_cone</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='category_theory.limits.preserves_limit_of_preserves_limit_cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/preserves.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (u+1)} [𝒞 : category_theory.category.{u u+1} C] {D : Type (u+1)} [𝒟 : category_theory.category.{u u+1} D] {J : Type u} [_inst_1 : category_theory.small_category.{u} J] {K : @category_theory.functor.{u u u u+1} J _inst_1 C 𝒞} {F : @category_theory.functor.{u u u+1 u+1} C 𝒞 D 𝒟} {t : @category_theory.limits.cone.{u u+1} J _inst_1 C 𝒞 K}, @category_theory.limits.is_limit.{u u+1} J _inst_1 C 𝒞 K t → @category_theory.limits.is_limit.{u u+1} J _inst_1 D 𝒟 (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 C 𝒞 D 𝒟 K F) (@category_theory.functor.map_cone.{u u+1 u+1} J _inst_1 C 𝒞 D 𝒟 K F t) → @category_theory.limits.preserves_limit.{u u+1 u+1} C 𝒞 D 𝒟 J _inst_1 K F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='If F preserves one limit cone for the diagram K,
 then it preserves any limit cone for K.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='lime'><a title='J : Type u,
𝒥 : category_theory.small_category.{u} J,
F :
  @category_theory.functor.{u u u u+1} J 𝒥 Top.{u}
    (@category_theory.concrete_category.to_category.{u} Top.{u}
       (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u})))
⊢ @category_theory.limits.preserves_limit.{u u+1 u+1} Top.{u}
    (@category_theory.concrete_category.to_category.{u} Top.{u}
       (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u})))
    (Type u)
    category_theory.types.{u}
    J
    𝒥
    F
    (@category_theory.forget.{u} Top.{u}
       (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u})))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41        (limit.is_limit F) (limit.is_limit (F ⋙ forget)) } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='category_theory.limits.limit.is_limit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.forget'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 446, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] {C : Type (u+1)} [𝒞 : category_theory.category.{u u+1} C] (F : @category_theory.functor.{u u u u+1} J _inst_1 C 𝒞) [_inst_3 : @category_theory.limits.has_limit.{u u+1} J _inst_1 C 𝒞 F], @category_theory.limits.is_limit.{u u+1} J _inst_1 C 𝒞 F (@category_theory.limits.limit.cone.{u u+1} J _inst_1 C 𝒞 F _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J 𝒥 Top.{u} (@category_theory.concrete_category.to_category.{u} Top.{u} (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u})))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{u u} C] {D : Type (u+1)} [𝒟 : category_theory.category.{u u+1} D] {E : Type (u+1)} [ℰ : category_theory.category.{u u+1} E], @category_theory.functor.{u u u u+1} C 𝒞 D 𝒟 → @category_theory.functor.{u u u+1 u+1} D 𝒟 E ℰ → @category_theory.functor.{u u u u+1} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (C : Type (u+1)) [_inst_1 : category_theory.concrete_category.{u} C], @category_theory.functor.{u u u+1 u+1} C (@category_theory.concrete_category.to_category.{u} C _inst_1) (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The forgetful functor from a concrete category to `Type u`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type u,
𝒥 : category_theory.small_category.{u} J,
F :
  @category_theory.functor.{u u u u+1} J 𝒥 Top.{u}
    (@category_theory.concrete_category.to_category.{u} Top.{u}
       (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u})))
⊢ @category_theory.limits.preserves_limit.{u u+1 u+1} Top.{u}
    (@category_theory.concrete_category.to_category.{u} Top.{u}
       (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u})))
    (Type u)
    category_theory.types.{u}
    J
    𝒥
    F
    (@category_theory.forget.{u} Top.{u}
       (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u})))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  def colimit (F : J ⥤ Top.{u}) : cocone F :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.limits.cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/Top/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u) [_inst_1 : category_theory.category.{u u} C] (D : Type (u+1)) [_inst_2 : category_theory.category.{u u+1} D], Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J _inst_1 Top.{u} (@category_theory.bundled_hom.category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u}))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The category of topological spaces and continuous maps.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A `c : cocone F` is
* an object `c.X` and
* a natural transformation `c.ι : F ⟶ c.X` from `F` to the constant `c.X` functor.

`cocone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cocones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  { X := ⟨colimit (F ⋙ forget), ⨆ j, (F.obj j).str.coinduced (colimit.ι (F ⋙ forget) j)⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.limits.colimit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.forget'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='lattice.supr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='lattice.supr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.bundled.str'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='topological_space.coinduced'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.limits.colimit.ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.forget'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 696, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/bundled.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 265, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 698, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] (F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞) [_inst_3 : @category_theory.limits.has_colimit.{v u} J _inst_1 C 𝒞 F], C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J _inst_1 Top.{u} (@category_theory.bundled_hom.category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u}))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{u u} C] {D : Type (u+1)} [𝒟 : category_theory.category.{u u+1} D] {E : Type (u+1)} [ℰ : category_theory.category.{u u+1} E], @category_theory.functor.{u u u u+1} C 𝒞 D 𝒟 → @category_theory.functor.{u u u+1 u+1} D 𝒟 E ℰ → @category_theory.functor.{u u u u+1} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type (u+1)) [_inst_1 : category_theory.concrete_category.{u} C], @category_theory.functor.{u u u+1 u+1} C (@category_theory.concrete_category.to_category.{u} C _inst_1) (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α ι : Type u} [_inst_1 : lattice.has_Sup.{u} α], (ι → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α ι : Type u} [_inst_1 : lattice.has_Sup.{u} α], (ι → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J _inst_1 Top.{u} (@category_theory.bundled_hom.category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u}))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{u u} C] {D : Type (u+1)} [_inst_2 : category_theory.category.{u u+1} D], @category_theory.functor.{u u u u+1} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {c : Type u → Type u} (c_1 : category_theory.bundled.{u u} c), auto_param.{u+1} (c (@category_theory.bundled.α.{u u} c c_1)) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u}, (α → β) → topological_space.{u} α → topological_space.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] (F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞) [_inst_3 : @category_theory.limits.has_colimit.{v u} J _inst_1 C 𝒞 F] (j : J), @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j) (@category_theory.limits.colimit.{v u} J _inst_1 C 𝒞 F _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J _inst_1 Top.{u} (@category_theory.bundled_hom.category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u}))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{u u} C] {D : Type (u+1)} [𝒟 : category_theory.category.{u u+1} D] {E : Type (u+1)} [ℰ : category_theory.category.{u u+1} E], @category_theory.functor.{u u u u+1} C 𝒞 D 𝒟 → @category_theory.functor.{u u u+1 u+1} D 𝒟 E ℰ → @category_theory.functor.{u u u u+1} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type (u+1)) [_inst_1 : category_theory.concrete_category.{u} C], @category_theory.functor.{u u u+1 u+1} C (@category_theory.concrete_category.to_category.{u} C _inst_1) (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The forgetful functor from a concrete category to `Type u`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Indexed supremum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Indexed supremum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='Given `f : α → β` and a topology on `α`, the coinduced topology on `β` is defined
 such that `s:set β` is open if the preimage of `s` is open. This is the finest topology that
 makes `f` continuous.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The forgetful functor from a concrete category to `Type u`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45    ι :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46    { app := λ j, ⟨colimit.ι (F ⋙ forget) j, continuous_iff_coinduced_le.mpr (lattice.le_supr _ j)⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.limits.colimit.ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.forget'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='continuous_iff_coinduced_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lattice.le_supr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 698, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 401, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 231, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] (F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞) [_inst_3 : @category_theory.limits.has_colimit.{v u} J _inst_1 C 𝒞 F] (j : J), @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j) (@category_theory.limits.colimit.{v u} J _inst_1 C 𝒞 F _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J _inst_1 Top.{u} (@category_theory.bundled_hom.category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u}))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{u u} C] {D : Type (u+1)} [𝒟 : category_theory.category.{u u+1} D] {E : Type (u+1)} [ℰ : category_theory.category.{u u+1} E], @category_theory.functor.{u u u u+1} C 𝒞 D 𝒟 → @category_theory.functor.{u u u+1 u+1} D 𝒟 E ℰ → @category_theory.functor.{u u u u+1} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type (u+1)) [_inst_1 : category_theory.concrete_category.{u} C], @category_theory.functor.{u u u+1 u+1} C (@category_theory.concrete_category.to_category.{u} C _inst_1) (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α β : Type u} {f : α → β} {t₁ : topological_space.{u} α} {t₂ : topological_space.{u} β}, iff (@continuous.{u u} α β t₁ t₂ f) (@has_le.le.{u} (topological_space.{u} β) (@preorder.to_has_le.{u} (topological_space.{u} β) (@partial_order.to_preorder.{u} (topological_space.{u} β) (@topological_space.partial_order.{u} β))) (@topological_space.coinduced.{u u} α β f t₁) t₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {ι : Sort w} [_inst_1 : lattice.complete_lattice.{u} α] (s : ι → α) (i : ι), @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.order_bot.to_partial_order.{u} α (@lattice.bounded_lattice.to_order_bot.{u} α (@lattice.complete_lattice.to_bounded_lattice.{u} α _inst_1))))) (s i) (@lattice.supr.{u w} α ι (@lattice.complete_lattice.to_has_Sup.{u} α _inst_1) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The forgetful functor from a concrete category to `Type u`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47      naturality&#x27; := λ j j&#x27; f, subtype.eq ((colimit.cocone (F ⋙ forget)).ι.naturality f) } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='subtype.eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.limits.colimit.cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.forget'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.cocone.ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.naturality'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/subtype/basic.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 694, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{u u} J (@category_theory.category_struct.to_has_hom.{u u} J (@category_theory.category.to_category_struct.{u u} J _inst_1)) j j&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {p : α → Prop} {a1 a2 : @subtype.{u+1} α (λ (x : α), p x)}, @eq.{u+1} α (@subtype.val.{u+1} α (λ (x : α), p x) a1) (@subtype.val.{u+1} α (λ (x : α), p x) a2) → @eq.{(max 1 (u+1))} (@subtype.{u+1} α (λ (x : α), p x)) a1 a2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] (F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞) [_inst_3 : @category_theory.limits.has_colimit.{v u} J _inst_1 C 𝒞 F], @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J _inst_1 Top.{u} (@category_theory.bundled_hom.category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u}))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{u u} C] {D : Type (u+1)} [𝒟 : category_theory.category.{u u+1} D] {E : Type (u+1)} [ℰ : category_theory.category.{u u+1} E], @category_theory.functor.{u u u u+1} C 𝒞 D 𝒟 → @category_theory.functor.{u u u+1 u+1} D 𝒟 E ℰ → @category_theory.functor.{u u u u+1} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type (u+1)) [_inst_1 : category_theory.concrete_category.{u} C], @category_theory.functor.{u u u+1 u+1} C (@category_theory.concrete_category.to_category.{u} C _inst_1) (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] {C : Type (u+1)} [𝒞 : category_theory.category.{u u+1} C] {F : @category_theory.functor.{u u u u+1} J _inst_1 C 𝒞} (c : @category_theory.limits.cocone.{u u+1} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{u u+1} (@category_theory.functor.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{u u+1} (@category_theory.functor.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{u u+1} (@category_theory.functor.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.functor.category.{u u u u+1} J _inst_1 C 𝒞))) F (@category_theory.functor.obj.{u u u+1 u+1} C 𝒞 (@category_theory.functor.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.functor.category.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.functor.const.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{u u+1} J _inst_1 C 𝒞 F c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {C : Type u} [𝒞 : category_theory.category.{u u} C] {D : Type (u+1)} [𝒟 : category_theory.category.{u u+1} D] {F G : @category_theory.functor.{u u u u+1} C 𝒞 D 𝒟} (c : @category_theory.nat_trans.{u u u u+1} C 𝒞 D 𝒟 F G) ⦃X Y : C⦄ (f : @category_theory.has_hom.hom.{u u} C (@category_theory.category_struct.to_has_hom.{u u} C (@category_theory.category.to_category_struct.{u u} C 𝒞)) X Y), @eq.{u+1} (@category_theory.has_hom.hom.{u u+1} D (@category_theory.category_struct.to_has_hom.{u u+1} D (@category_theory.category.to_category_struct.{u u+1} D 𝒟)) (@category_theory.functor.obj.{u u u u+1} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{u u u u+1} C 𝒞 D 𝒟 G Y)) (@category_theory.category_struct.comp.{u u+1} D (@category_theory.category.to_category_struct.{u u+1} D 𝒟) (@category_theory.functor.obj.{u u u u+1} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{u u u u+1} C 𝒞 D 𝒟 F Y) (@category_theory.functor.obj.{u u u u+1} C 𝒞 D 𝒟 G Y) (@category_theory.functor.map.{u u u u+1} C 𝒞 D 𝒟 F X Y f) (@category_theory.nat_trans.app.{u u u u+1} C 𝒞 D 𝒟 F G c Y)) (@category_theory.category_struct.comp.{u u+1} D (@category_theory.category.to_category_struct.{u u+1} D 𝒟) (@category_theory.functor.obj.{u u u u+1} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{u u u u+1} C 𝒞 D 𝒟 G X) (@category_theory.functor.obj.{u u u u+1} C 𝒞 D 𝒟 G Y) (@category_theory.nat_trans.app.{u u u u+1} C 𝒞 D 𝒟 F G c X) (@category_theory.functor.map.{u u u u+1} C 𝒞 D 𝒟 G X Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{u u} J (@category_theory.category_struct.to_has_hom.{u u} J (@category_theory.category.to_category_struct.{u u} J _inst_1)) j j&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                            </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The forgetful functor from a concrete category to `Type u`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  def colimit_is_colimit (F : J ⥤ Top.{u}) : is_colimit (colimit F) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.limits.is_colimit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Top.colimit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/Top/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 214, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 43, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u) [_inst_1 : category_theory.category.{u u} C] (D : Type (u+1)) [_inst_2 : category_theory.category.{u u+1} D], Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] (F : @category_theory.functor.{u u u u+1} J _inst_1 Top.{u} (@category_theory.bundled_hom.category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u}))), @category_theory.limits.cocone.{u u+1} J _inst_1 Top.{u} (@category_theory.bundled_hom.category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u})) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J _inst_1 Top.{u} (@category_theory.bundled_hom.category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u}))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The category of topological spaces and continuous maps.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A cocone `t` on `F` is a colimit cocone if each cocone on `F` admits a unique
 cocone morphism from `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  by { refine is_colimit.of_faithful forget (colimit.is_colimit _) (λ s, ⟨_, _⟩) (λ s, rfl),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='category_theory.limits.is_colimit.of_faithful'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.forget'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.colimit.is_colimit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 300, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 707, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] {C : Type (u+1)} [𝒞 : category_theory.category.{u u+1} C] {F : @category_theory.functor.{u u u u+1} J _inst_1 C 𝒞} {t : @category_theory.limits.cocone.{u u+1} J _inst_1 C 𝒞 F} {D : Type (u+1)} [_inst_3 : category_theory.category.{u u+1} D] (G : @category_theory.functor.{u u u+1 u+1} C 𝒞 D _inst_3) [_inst_4 : @category_theory.faithful.{u u u+1 u+1} C 𝒞 D _inst_3 G] (ht : @category_theory.limits.is_colimit.{u u+1} J _inst_1 D _inst_3 (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 C 𝒞 D _inst_3 F G) (@category_theory.functor.map_cocone.{u u+1 u+1} J _inst_1 C 𝒞 D _inst_3 F G t)) (desc : Π (s : @category_theory.limits.cocone.{u u+1} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{u u+1} C (@category_theory.category_struct.to_has_hom.{u u+1} C (@category_theory.category.to_category_struct.{u u+1} C 𝒞)) (@category_theory.limits.cocone.X.{u u+1} J _inst_1 C 𝒞 F t) (@category_theory.limits.cocone.X.{u u+1} J _inst_1 C 𝒞 F s)), (∀ (s : @category_theory.limits.cocone.{u u+1} J _inst_1 C 𝒞 F), @eq.{u+1} (@category_theory.has_hom.hom.{u u+1} D (@category_theory.category_struct.to_has_hom.{u u+1} D (@category_theory.category.to_category_struct.{u u+1} D _inst_3)) (@category_theory.functor.obj.{u u u+1 u+1} C 𝒞 D _inst_3 G (@category_theory.limits.cocone.X.{u u+1} J _inst_1 C 𝒞 F t)) (@category_theory.functor.obj.{u u u+1 u+1} C 𝒞 D _inst_3 G (@category_theory.limits.cocone.X.{u u+1} J _inst_1 C 𝒞 F s))) (@category_theory.functor.map.{u u u+1 u+1} C 𝒞 D _inst_3 G (@category_theory.limits.cocone.X.{u u+1} J _inst_1 C 𝒞 F t) (@category_theory.limits.cocone.X.{u u+1} J _inst_1 C 𝒞 F s) (desc s)) (@category_theory.limits.is_colimit.desc.{u u+1} J _inst_1 D _inst_3 (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 C 𝒞 D _inst_3 F G) (@category_theory.functor.map_cocone.{u u+1 u+1} J _inst_1 C 𝒞 D _inst_3 F G t) ht (@category_theory.functor.map_cocone.{u u+1 u+1} J _inst_1 C 𝒞 D _inst_3 F G s))) → @category_theory.limits.is_colimit.{u u+1} J _inst_1 C 𝒞 F t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (C : Type (u+1)) [_inst_1 : category_theory.concrete_category.{u} C], @category_theory.functor.{u u u+1 u+1} C (@category_theory.concrete_category.to_category.{u} C _inst_1) (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] {C : Type (u+1)} [𝒞 : category_theory.category.{u u+1} C] (F : @category_theory.functor.{u u u u+1} J _inst_1 C 𝒞) [_inst_3 : @category_theory.limits.has_colimit.{u u+1} J _inst_1 C 𝒞 F], @category_theory.limits.is_colimit.{u u+1} J _inst_1 C 𝒞 F (@category_theory.limits.colimit.cocone.{u u+1} J _inst_1 C 𝒞 F _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='If G : C → D is a faithful functor which sends t to a colimit cocone,
 then it suffices to check that the induced maps for the image of t
 can be lifted to maps of C.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The forgetful functor from a concrete category to `Type u`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='J : Type u,
_inst_1 : category_theory.small_category.{u} J,
F :
  @category_theory.functor.{u u u u+1} J _inst_1 Top.{u}
    (@category_theory.bundled_hom.category.{u} topological_space.{u}
       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
          Top.concrete_category_continuous.{u}))
⊢ @category_theory.limits.is_colimit.{u u+1} J _inst_1 Top.{u}
    (@category_theory.bundled_hom.category.{u} topological_space.{u}
       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
          Top.concrete_category_continuous.{u}))
    F
    (@Top.colimit.{u} J _inst_1 F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type u,
_inst_1 : category_theory.small_category.{u} J,
F :
  @category_theory.functor.{u u u u+1} J _inst_1 Top.{u}
    (@category_theory.bundled_hom.category.{u} topological_space.{u}
       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
          Top.concrete_category_continuous.{u})),
s :
  @category_theory.limits.cocone.{u u+1} J _inst_1 Top.{u}
    (@category_theory.bundled_hom.category.{u} topological_space.{u}
       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
          Top.concrete_category_continuous.{u}))
    F
⊢ @continuous.{u u}
    (@category_theory.bundled.α.{u u} topological_space.{u}
       (@category_theory.limits.cocone.X.{u u+1} J _inst_1 Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))
          F
          (@Top.colimit.{u} J _inst_1 F)))
    (@category_theory.bundled.α.{u u} topological_space.{u}
       (@category_theory.limits.cocone.X.{u u+1} J _inst_1 Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))
          F
          s))
    (@category_theory.bundled.str.{u u} topological_space.{u}
       (@category_theory.limits.cocone.X.{u u+1} J _inst_1 Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))
          F
          (@Top.colimit.{u} J _inst_1 F)))
    (@category_theory.bundled.str.{u u} topological_space.{u}
       (@category_theory.limits.cocone.X.{u u+1} J _inst_1 Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))
          F
          s))
    (@quot.lift.{u+1 u+1}
       (@sigma.{u u} J
          (λ (j : J),
             @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
               (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                  (@category_theory.bundled_hom.category.{u} topological_space.{u}
                     (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                        @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                     (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                        continuous.{u u}
                        Top.concrete_category_continuous.{u}))
                  (Type u)
                  category_theory.types.{u}
                  F
                  (@category_theory.forget.{u} Top.{u}
                     (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                        (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                           @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                        (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                           continuous.{u u}
                           Top.concrete_category_continuous.{u}))))
               j))
       (λ
        (p p&#x27; :
          @sigma.{u u} J
            (λ (j : J),
               @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                 (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                    (@category_theory.bundled_hom.category.{u} topological_space.{u}
                       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                          continuous.{u u}
                          Top.concrete_category_continuous.{u}))
                    (Type u)
                    category_theory.types.{u}
                    F
                    (@category_theory.forget.{u} Top.{u}
                       (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                             continuous.{u u}
                             Top.concrete_category_continuous.{u}))))
                 j)),
          @Exists.{u+1}
            (@category_theory.has_hom.hom.{u u} J
               (@category_theory.category_struct.to_has_hom.{u u} J
                  (@category_theory.category.to_category_struct.{u u} J _inst_1))
               (@sigma.fst.{u u} J
                  (λ (j : J),
                     @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                       (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                          (@category_theory.bundled_hom.category.{u} topological_space.{u}
                             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                             (@category_theory.unbundled_hom.bundled_hom.{u}
                                (λ (α : Type u), topological_space.{u} α)
                                continuous.{u u}
                                Top.concrete_category_continuous.{u}))
                          (Type u)
                          category_theory.types.{u}
                          F
                          (@category_theory.forget.{u} Top.{u}
                             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                (@category_theory.unbundled_hom.bundled_hom.{u}
                                   (λ (α : Type u), topological_space.{u} α)
                                   continuous.{u u}
                                   Top.concrete_category_continuous.{u}))))
                       j)
                  p)
               (@sigma.fst.{u u} J
                  (λ (j : J),
                     @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                       (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                          (@category_theory.bundled_hom.category.{u} topological_space.{u}
                             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                             (@category_theory.unbundled_hom.bundled_hom.{u}
                                (λ (α : Type u), topological_space.{u} α)
                                continuous.{u u}
                                Top.concrete_category_continuous.{u}))
                          (Type u)
                          category_theory.types.{u}
                          F
                          (@category_theory.forget.{u} Top.{u}
                             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                (@category_theory.unbundled_hom.bundled_hom.{u}
                                   (λ (α : Type u), topological_space.{u} α)
                                   continuous.{u u}
                                   Top.concrete_category_continuous.{u}))))
                       j)
                  p&#x27;))
            (λ
             (f :
               @category_theory.has_hom.hom.{u u} J
                 (@category_theory.category_struct.to_has_hom.{u u} J
                    (@category_theory.category.to_category_struct.{u u} J _inst_1))
                 (@sigma.fst.{u u} J
                    (λ (j : J),
                       @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                         (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                            (@category_theory.bundled_hom.category.{u} topological_space.{u}
                               (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                                  @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                               (@category_theory.unbundled_hom.bundled_hom.{u}
                                  (λ (α : Type u), topological_space.{u} α)
                                  continuous.{u u}
                                  Top.concrete_category_continuous.{u}))
                            (Type u)
                            category_theory.types.{u}
                            F
                            (@category_theory.forget.{u} Top.{u}
                               (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                                  (λ (α β : Type u) (Iα : topological_space.{u} α)
                                   (Iβ : topological_space.{u} β),
                                     @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                  (@category_theory.unbundled_hom.bundled_hom.{u}
                                     (λ (α : Type u), topological_space.{u} α)
                                     continuous.{u u}
                                     Top.concrete_category_continuous.{u}))))
                         j)
                    p)
                 (@sigma.fst.{u u} J
                    (λ (j : J),
                       @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                         (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                            (@category_theory.bundled_hom.category.{u} topological_space.{u}
                               (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                                  @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                               (@category_theory.unbundled_hom.bundled_hom.{u}
                                  (λ (α : Type u), topological_space.{u} α)
                                  continuous.{u u}
                                  Top.concrete_category_continuous.{u}))
                            (Type u)
                            category_theory.types.{u}
                            F
                            (@category_theory.forget.{u} Top.{u}
                               (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                                  (λ (α β : Type u) (Iα : topological_space.{u} α)
                                   (Iβ : topological_space.{u} β),
                                     @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                  (@category_theory.unbundled_hom.bundled_hom.{u}
                                     (λ (α : Type u), topological_space.{u} α)
                                     continuous.{u u}
                                     Top.concrete_category_continuous.{u}))))
                         j)
                    p&#x27;)),
               @eq.{u+1}
                 (@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                    (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                       (@category_theory.bundled_hom.category.{u} topological_space.{u}
                          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                             continuous.{u u}
                             Top.concrete_category_continuous.{u}))
                       (Type u)
                       category_theory.types.{u}
                       F
                       (@category_theory.forget.{u} Top.{u}
                          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                             (@category_theory.unbundled_hom.bundled_hom.{u}
                                (λ (α : Type u), topological_space.{u} α)
                                continuous.{u u}
                                Top.concrete_category_continuous.{u}))))
                    (@sigma.fst.{u u} J
                       (λ (j : J),
                          @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                            (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                               (@category_theory.bundled_hom.category.{u} topological_space.{u}
                                  (λ (α β : Type u) (Iα : topological_space.{u} α)
                                   (Iβ : topological_space.{u} β),
                                     @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                  (@category_theory.unbundled_hom.bundled_hom.{u}
                                     (λ (α : Type u), topological_space.{u} α)
                                     continuous.{u u}
                                     Top.concrete_category_continuous.{u}))
                               (Type u)
                               category_theory.types.{u}
                               F
                               (@category_theory.forget.{u} Top.{u}
                                  (@category_theory.bundled_hom.category_theory.concrete_category.{u}
                                     topological_space.{u}
                                     (λ (α β : Type u) (Iα : topological_space.{u} α)
                                      (Iβ : topological_space.{u} β),
                                        @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                     (@category_theory.unbundled_hom.bundled_hom.{u}
                                        (λ (α : Type u), topological_space.{u} α)
                                        continuous.{u u}
                                        Top.concrete_category_continuous.{u}))))
                            j)
                       p&#x27;))
                 (@sigma.snd.{u u} J
                    (λ (j : J),
                       @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                         (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                            (@category_theory.bundled_hom.category.{u} topological_space.{u}
                               (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                                  @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                               (@category_theory.unbundled_hom.bundled_hom.{u}
                                  (λ (α : Type u), topological_space.{u} α)
                                  continuous.{u u}
                                  Top.concrete_category_continuous.{u}))
                            (Type u)
                            category_theory.types.{u}
                            F
                            (@category_theory.forget.{u} Top.{u}
                               (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                                  (λ (α β : Type u) (Iα : topological_space.{u} α)
                                   (Iβ : topological_space.{u} β),
                                     @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                  (@category_theory.unbundled_hom.bundled_hom.{u}
                                     (λ (α : Type u), topological_space.{u} α)
                                     continuous.{u u}
                                     Top.concrete_category_continuous.{u}))))
                         j)
                    p&#x27;)
                 (@category_theory.functor.map.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                    (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                       (@category_theory.bundled_hom.category.{u} topological_space.{u}
                          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                             continuous.{u u}
                             Top.concrete_category_continuous.{u}))
                       (Type u)
                       category_theory.types.{u}
                       F
                       (@category_theory.forget.{u} Top.{u}
                          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                             (@category_theory.unbundled_hom.bundled_hom.{u}
                                (λ (α : Type u), topological_space.{u} α)
                                continuous.{u u}
                                Top.concrete_category_continuous.{u}))))
                    (@sigma.fst.{u u} J
                       (λ (j : J),
                          @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                            (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                               (@category_theory.bundled_hom.category.{u} topological_space.{u}
                                  (λ (α β : Type u) (Iα : topological_space.{u} α)
                                   (Iβ : topological_space.{u} β),
                                     @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                  (@category_theory.unbundled_hom.bundled_hom.{u}
                                     (λ (α : Type u), topological_space.{u} α)
                                     continuous.{u u}
                                     Top.concrete_category_continuous.{u}))
                               (Type u)
                               category_theory.types.{u}
                               F
                               (@category_theory.forget.{u} Top.{u}
                                  (@category_theory.bundled_hom.category_theory.concrete_category.{u}
                                     topological_space.{u}
                                     (λ (α β : Type u) (Iα : topological_space.{u} α)
                                      (Iβ : topological_space.{u} β),
                                        @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                     (@category_theory.unbundled_hom.bundled_hom.{u}
                                        (λ (α : Type u), topological_space.{u} α)
                                        continuous.{u u}
                                        Top.concrete_category_continuous.{u}))))
                            j)
                       p)
                    (@sigma.fst.{u u} J
                       (λ (j : J),
                          @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                            (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                               (@category_theory.bundled_hom.category.{u} topological_space.{u}
                                  (λ (α β : Type u) (Iα : topological_space.{u} α)
                                   (Iβ : topological_space.{u} β),
                                     @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                  (@category_theory.unbundled_hom.bundled_hom.{u}
                                     (λ (α : Type u), topological_space.{u} α)
                                     continuous.{u u}
                                     Top.concrete_category_continuous.{u}))
                               (Type u)
                               category_theory.types.{u}
                               F
                               (@category_theory.forget.{u} Top.{u}
                                  (@category_theory.bundled_hom.category_theory.concrete_category.{u}
                                     topological_space.{u}
                                     (λ (α β : Type u) (Iα : topological_space.{u} α)
                                      (Iβ : topological_space.{u} β),
                                        @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                     (@category_theory.unbundled_hom.bundled_hom.{u}
                                        (λ (α : Type u), topological_space.{u} α)
                                        continuous.{u u}
                                        Top.concrete_category_continuous.{u}))))
                            j)
                       p&#x27;)
                    f
                    (@sigma.snd.{u u} J
                       (λ (j : J),
                          @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                            (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                               (@category_theory.bundled_hom.category.{u} topological_space.{u}
                                  (λ (α β : Type u) (Iα : topological_space.{u} α)
                                   (Iβ : topological_space.{u} β),
                                     @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                  (@category_theory.unbundled_hom.bundled_hom.{u}
                                     (λ (α : Type u), topological_space.{u} α)
                                     continuous.{u u}
                                     Top.concrete_category_continuous.{u}))
                               (Type u)
                               category_theory.types.{u}
                               F
                               (@category_theory.forget.{u} Top.{u}
                                  (@category_theory.bundled_hom.category_theory.concrete_category.{u}
                                     topological_space.{u}
                                     (λ (α β : Type u) (Iα : topological_space.{u} α)
                                      (Iβ : topological_space.{u} β),
                                        @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                     (@category_theory.unbundled_hom.bundled_hom.{u}
                                        (λ (α : Type u), topological_space.{u} α)
                                        continuous.{u u}
                                        Top.concrete_category_continuous.{u}))))
                            j)
                       p))))
       (@category_theory.limits.cocone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u}
          (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
             (@category_theory.bundled_hom.category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u}))
             (Type u)
             category_theory.types.{u}
             F
             (@category_theory.forget.{u} Top.{u}
                (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                   (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                      @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                      continuous.{u u}
                      Top.concrete_category_continuous.{u}))))
          (@category_theory.functor.map_cocone.{u u+1 u+1} J _inst_1 Top.{u}
             (@category_theory.bundled_hom.category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u}))
             (Type u)
             category_theory.types.{u}
             F
             (@category_theory.forget.{u} Top.{u}
                (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                   (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                      @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                      continuous.{u u}
                      Top.concrete_category_continuous.{u})))
             s))
       (λ
        (p :
          @sigma.{u u} J
            (λ (j : J),
               @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                 (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                    (@category_theory.bundled_hom.category.{u} topological_space.{u}
                       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                          continuous.{u u}
                          Top.concrete_category_continuous.{u}))
                    (Type u)
                    category_theory.types.{u}
                    F
                    (@category_theory.forget.{u} Top.{u}
                       (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                             continuous.{u u}
                             Top.concrete_category_continuous.{u}))))
                 j)),
          @category_theory.nat_trans.app.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
            (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
               (@category_theory.bundled_hom.category.{u} topological_space.{u}
                  (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                     @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                  (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                     continuous.{u u}
                     Top.concrete_category_continuous.{u}))
               (Type u)
               category_theory.types.{u}
               F
               (@category_theory.forget.{u} Top.{u}
                  (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                     (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                        @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                     (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                        continuous.{u u}
                        Top.concrete_category_continuous.{u}))))
            (@category_theory.functor.obj.{u u u+1 u+1} (Type u) category_theory.types.{u}
               (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
               (@category_theory.functor.category.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
               (@category_theory.functor.const.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
               (@category_theory.limits.cocone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u}
                  (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                     (@category_theory.bundled_hom.category.{u} topological_space.{u}
                        (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                           @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                        (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                           continuous.{u u}
                           Top.concrete_category_continuous.{u}))
                     (Type u)
                     category_theory.types.{u}
                     F
                     (@category_theory.forget.{u} Top.{u}
                        (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                           (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                              @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                              continuous.{u u}
                              Top.concrete_category_continuous.{u}))))
                  (@category_theory.functor.map_cocone.{u u+1 u+1} J _inst_1 Top.{u}
                     (@category_theory.bundled_hom.category.{u} topological_space.{u}
                        (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                           @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                        (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                           continuous.{u u}
                           Top.concrete_category_continuous.{u}))
                     (Type u)
                     category_theory.types.{u}
                     F
                     (@category_theory.forget.{u} Top.{u}
                        (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                           (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                              @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                              continuous.{u u}
                              Top.concrete_category_continuous.{u})))
                     s)))
            (@category_theory.limits.cocone.ι.{u u+1} J _inst_1 (Type u) category_theory.types.{u}
               (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                  (@category_theory.bundled_hom.category.{u} topological_space.{u}
                     (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                        @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                     (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                        continuous.{u u}
                        Top.concrete_category_continuous.{u}))
                  (Type u)
                  category_theory.types.{u}
                  F
                  (@category_theory.forget.{u} Top.{u}
                     (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                        (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                           @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                        (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                           continuous.{u u}
                           Top.concrete_category_continuous.{u}))))
               (@category_theory.functor.map_cocone.{u u+1 u+1} J _inst_1 Top.{u}
                  (@category_theory.bundled_hom.category.{u} topological_space.{u}
                     (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                        @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                     (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                        continuous.{u u}
                        Top.concrete_category_continuous.{u}))
                  (Type u)
                  category_theory.types.{u}
                  F
                  (@category_theory.forget.{u} Top.{u}
                     (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                        (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                           @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                        (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                           continuous.{u u}
                           Top.concrete_category_continuous.{u})))
                  s))
            (@sigma.fst.{u u} J
               (λ (j : J),
                  @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                    (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                       (@category_theory.bundled_hom.category.{u} topological_space.{u}
                          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                             continuous.{u u}
                             Top.concrete_category_continuous.{u}))
                       (Type u)
                       category_theory.types.{u}
                       F
                       (@category_theory.forget.{u} Top.{u}
                          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                             (@category_theory.unbundled_hom.bundled_hom.{u}
                                (λ (α : Type u), topological_space.{u} α)
                                continuous.{u u}
                                Top.concrete_category_continuous.{u}))))
                    j)
               p)
            (@sigma.snd.{u u} J
               (λ (j : J),
                  @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                    (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                       (@category_theory.bundled_hom.category.{u} topological_space.{u}
                          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                             continuous.{u u}
                             Top.concrete_category_continuous.{u}))
                       (Type u)
                       category_theory.types.{u}
                       F
                       (@category_theory.forget.{u} Top.{u}
                          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                             (@category_theory.unbundled_hom.bundled_hom.{u}
                                (λ (α : Type u), topological_space.{u} α)
                                continuous.{u u}
                                Top.concrete_category_continuous.{u}))))
                    j)
               p))
       (@category_theory.limits.types.colimit_is_colimit._proof_1.{u} J _inst_1
          (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
             (@category_theory.bundled_hom.category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u}))
             (Type u)
             category_theory.types.{u}
             F
             (@category_theory.forget.{u} Top.{u}
                (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                   (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                      @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                      continuous.{u u}
                      Top.concrete_category_continuous.{u}))))
          (@category_theory.functor.map_cocone.{u u+1 u+1} J _inst_1 Top.{u}
             (@category_theory.bundled_hom.category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u}))
             (Type u)
             category_theory.types.{u}
             F
             (@category_theory.forget.{u} Top.{u}
                (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                   (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                      @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                      continuous.{u u}
                      Top.concrete_category_continuous.{u})))
             s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51       exact continuous_iff_le_induced.mpr (lattice.supr_le $ λ j,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='continuous_iff_le_induced'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lattice.supr_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 404, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 254, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} {f : α → β} {t₁ : topological_space.{u} α} {t₂ : topological_space.{u} β}, iff (@continuous.{u u} α β t₁ t₂ f) (@has_le.le.{u} (topological_space.{u} α) (@preorder.to_has_le.{u} (topological_space.{u} α) (@partial_order.to_preorder.{u} (topological_space.{u} α) (@topological_space.partial_order.{u} α))) t₁ (@topological_space.induced.{u u} α β f t₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α ι : Type u} [_inst_1 : lattice.complete_lattice.{u} α] {s : ι → α} {a : α}, (∀ (i : ι), @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.order_bot.to_partial_order.{u} α (@lattice.bounded_lattice.to_order_bot.{u} α (@lattice.complete_lattice.to_bounded_lattice.{u} α _inst_1))))) (s i) a) → @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.order_bot.to_partial_order.{u} α (@lattice.bounded_lattice.to_order_bot.{u} α (@lattice.complete_lattice.to_bounded_lattice.{u} α _inst_1))))) (@lattice.supr.{u u+1} α ι (@lattice.complete_lattice.to_has_Sup.{u} α _inst_1) s) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type u,
_inst_1 : category_theory.small_category.{u} J,
F :
  @category_theory.functor.{u u u u+1} J _inst_1 Top.{u}
    (@category_theory.bundled_hom.category.{u} topological_space.{u}
       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
          Top.concrete_category_continuous.{u})),
s :
  @category_theory.limits.cocone.{u u+1} J _inst_1 Top.{u}
    (@category_theory.bundled_hom.category.{u} topological_space.{u}
       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
          Top.concrete_category_continuous.{u}))
    F
⊢ @continuous.{u u}
    (@category_theory.bundled.α.{u u} topological_space.{u}
       (@category_theory.limits.cocone.X.{u u+1} J _inst_1 Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))
          F
          (@Top.colimit.{u} J _inst_1 F)))
    (@category_theory.bundled.α.{u u} topological_space.{u}
       (@category_theory.limits.cocone.X.{u u+1} J _inst_1 Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))
          F
          s))
    (@category_theory.bundled.str.{u u} topological_space.{u}
       (@category_theory.limits.cocone.X.{u u+1} J _inst_1 Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))
          F
          (@Top.colimit.{u} J _inst_1 F)))
    (@category_theory.bundled.str.{u u} topological_space.{u}
       (@category_theory.limits.cocone.X.{u u+1} J _inst_1 Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))
          F
          s))
    (@quot.lift.{u+1 u+1}
       (@sigma.{u u} J
          (λ (j : J),
             @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
               (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                  (@category_theory.bundled_hom.category.{u} topological_space.{u}
                     (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                        @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                     (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                        continuous.{u u}
                        Top.concrete_category_continuous.{u}))
                  (Type u)
                  category_theory.types.{u}
                  F
                  (@category_theory.forget.{u} Top.{u}
                     (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                        (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                           @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                        (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                           continuous.{u u}
                           Top.concrete_category_continuous.{u}))))
               j))
       (λ
        (p p&#x27; :
          @sigma.{u u} J
            (λ (j : J),
               @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                 (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                    (@category_theory.bundled_hom.category.{u} topological_space.{u}
                       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                          continuous.{u u}
                          Top.concrete_category_continuous.{u}))
                    (Type u)
                    category_theory.types.{u}
                    F
                    (@category_theory.forget.{u} Top.{u}
                       (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                             continuous.{u u}
                             Top.concrete_category_continuous.{u}))))
                 j)),
          @Exists.{u+1}
            (@category_theory.has_hom.hom.{u u} J
               (@category_theory.category_struct.to_has_hom.{u u} J
                  (@category_theory.category.to_category_struct.{u u} J _inst_1))
               (@sigma.fst.{u u} J
                  (λ (j : J),
                     @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                       (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                          (@category_theory.bundled_hom.category.{u} topological_space.{u}
                             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                             (@category_theory.unbundled_hom.bundled_hom.{u}
                                (λ (α : Type u), topological_space.{u} α)
                                continuous.{u u}
                                Top.concrete_category_continuous.{u}))
                          (Type u)
                          category_theory.types.{u}
                          F
                          (@category_theory.forget.{u} Top.{u}
                             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                (@category_theory.unbundled_hom.bundled_hom.{u}
                                   (λ (α : Type u), topological_space.{u} α)
                                   continuous.{u u}
                                   Top.concrete_category_continuous.{u}))))
                       j)
                  p)
               (@sigma.fst.{u u} J
                  (λ (j : J),
                     @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                       (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                          (@category_theory.bundled_hom.category.{u} topological_space.{u}
                             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                             (@category_theory.unbundled_hom.bundled_hom.{u}
                                (λ (α : Type u), topological_space.{u} α)
                                continuous.{u u}
                                Top.concrete_category_continuous.{u}))
                          (Type u)
                          category_theory.types.{u}
                          F
                          (@category_theory.forget.{u} Top.{u}
                             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                (@category_theory.unbundled_hom.bundled_hom.{u}
                                   (λ (α : Type u), topological_space.{u} α)
                                   continuous.{u u}
                                   Top.concrete_category_continuous.{u}))))
                       j)
                  p&#x27;))
            (λ
             (f :
               @category_theory.has_hom.hom.{u u} J
                 (@category_theory.category_struct.to_has_hom.{u u} J
                    (@category_theory.category.to_category_struct.{u u} J _inst_1))
                 (@sigma.fst.{u u} J
                    (λ (j : J),
                       @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                         (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                            (@category_theory.bundled_hom.category.{u} topological_space.{u}
                               (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                                  @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                               (@category_theory.unbundled_hom.bundled_hom.{u}
                                  (λ (α : Type u), topological_space.{u} α)
                                  continuous.{u u}
                                  Top.concrete_category_continuous.{u}))
                            (Type u)
                            category_theory.types.{u}
                            F
                            (@category_theory.forget.{u} Top.{u}
                               (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                                  (λ (α β : Type u) (Iα : topological_space.{u} α)
                                   (Iβ : topological_space.{u} β),
                                     @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                  (@category_theory.unbundled_hom.bundled_hom.{u}
                                     (λ (α : Type u), topological_space.{u} α)
                                     continuous.{u u}
                                     Top.concrete_category_continuous.{u}))))
                         j)
                    p)
                 (@sigma.fst.{u u} J
                    (λ (j : J),
                       @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                         (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                            (@category_theory.bundled_hom.category.{u} topological_space.{u}
                               (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                                  @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                               (@category_theory.unbundled_hom.bundled_hom.{u}
                                  (λ (α : Type u), topological_space.{u} α)
                                  continuous.{u u}
                                  Top.concrete_category_continuous.{u}))
                            (Type u)
                            category_theory.types.{u}
                            F
                            (@category_theory.forget.{u} Top.{u}
                               (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                                  (λ (α β : Type u) (Iα : topological_space.{u} α)
                                   (Iβ : topological_space.{u} β),
                                     @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                  (@category_theory.unbundled_hom.bundled_hom.{u}
                                     (λ (α : Type u), topological_space.{u} α)
                                     continuous.{u u}
                                     Top.concrete_category_continuous.{u}))))
                         j)
                    p&#x27;)),
               @eq.{u+1}
                 (@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                    (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                       (@category_theory.bundled_hom.category.{u} topological_space.{u}
                          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                             continuous.{u u}
                             Top.concrete_category_continuous.{u}))
                       (Type u)
                       category_theory.types.{u}
                       F
                       (@category_theory.forget.{u} Top.{u}
                          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                             (@category_theory.unbundled_hom.bundled_hom.{u}
                                (λ (α : Type u), topological_space.{u} α)
                                continuous.{u u}
                                Top.concrete_category_continuous.{u}))))
                    (@sigma.fst.{u u} J
                       (λ (j : J),
                          @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                            (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                               (@category_theory.bundled_hom.category.{u} topological_space.{u}
                                  (λ (α β : Type u) (Iα : topological_space.{u} α)
                                   (Iβ : topological_space.{u} β),
                                     @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                  (@category_theory.unbundled_hom.bundled_hom.{u}
                                     (λ (α : Type u), topological_space.{u} α)
                                     continuous.{u u}
                                     Top.concrete_category_continuous.{u}))
                               (Type u)
                               category_theory.types.{u}
                               F
                               (@category_theory.forget.{u} Top.{u}
                                  (@category_theory.bundled_hom.category_theory.concrete_category.{u}
                                     topological_space.{u}
                                     (λ (α β : Type u) (Iα : topological_space.{u} α)
                                      (Iβ : topological_space.{u} β),
                                        @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                     (@category_theory.unbundled_hom.bundled_hom.{u}
                                        (λ (α : Type u), topological_space.{u} α)
                                        continuous.{u u}
                                        Top.concrete_category_continuous.{u}))))
                            j)
                       p&#x27;))
                 (@sigma.snd.{u u} J
                    (λ (j : J),
                       @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                         (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                            (@category_theory.bundled_hom.category.{u} topological_space.{u}
                               (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                                  @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                               (@category_theory.unbundled_hom.bundled_hom.{u}
                                  (λ (α : Type u), topological_space.{u} α)
                                  continuous.{u u}
                                  Top.concrete_category_continuous.{u}))
                            (Type u)
                            category_theory.types.{u}
                            F
                            (@category_theory.forget.{u} Top.{u}
                               (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                                  (λ (α β : Type u) (Iα : topological_space.{u} α)
                                   (Iβ : topological_space.{u} β),
                                     @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                  (@category_theory.unbundled_hom.bundled_hom.{u}
                                     (λ (α : Type u), topological_space.{u} α)
                                     continuous.{u u}
                                     Top.concrete_category_continuous.{u}))))
                         j)
                    p&#x27;)
                 (@category_theory.functor.map.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                    (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                       (@category_theory.bundled_hom.category.{u} topological_space.{u}
                          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                             continuous.{u u}
                             Top.concrete_category_continuous.{u}))
                       (Type u)
                       category_theory.types.{u}
                       F
                       (@category_theory.forget.{u} Top.{u}
                          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                             (@category_theory.unbundled_hom.bundled_hom.{u}
                                (λ (α : Type u), topological_space.{u} α)
                                continuous.{u u}
                                Top.concrete_category_continuous.{u}))))
                    (@sigma.fst.{u u} J
                       (λ (j : J),
                          @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                            (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                               (@category_theory.bundled_hom.category.{u} topological_space.{u}
                                  (λ (α β : Type u) (Iα : topological_space.{u} α)
                                   (Iβ : topological_space.{u} β),
                                     @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                  (@category_theory.unbundled_hom.bundled_hom.{u}
                                     (λ (α : Type u), topological_space.{u} α)
                                     continuous.{u u}
                                     Top.concrete_category_continuous.{u}))
                               (Type u)
                               category_theory.types.{u}
                               F
                               (@category_theory.forget.{u} Top.{u}
                                  (@category_theory.bundled_hom.category_theory.concrete_category.{u}
                                     topological_space.{u}
                                     (λ (α β : Type u) (Iα : topological_space.{u} α)
                                      (Iβ : topological_space.{u} β),
                                        @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                     (@category_theory.unbundled_hom.bundled_hom.{u}
                                        (λ (α : Type u), topological_space.{u} α)
                                        continuous.{u u}
                                        Top.concrete_category_continuous.{u}))))
                            j)
                       p)
                    (@sigma.fst.{u u} J
                       (λ (j : J),
                          @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                            (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                               (@category_theory.bundled_hom.category.{u} topological_space.{u}
                                  (λ (α β : Type u) (Iα : topological_space.{u} α)
                                   (Iβ : topological_space.{u} β),
                                     @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                  (@category_theory.unbundled_hom.bundled_hom.{u}
                                     (λ (α : Type u), topological_space.{u} α)
                                     continuous.{u u}
                                     Top.concrete_category_continuous.{u}))
                               (Type u)
                               category_theory.types.{u}
                               F
                               (@category_theory.forget.{u} Top.{u}
                                  (@category_theory.bundled_hom.category_theory.concrete_category.{u}
                                     topological_space.{u}
                                     (λ (α β : Type u) (Iα : topological_space.{u} α)
                                      (Iβ : topological_space.{u} β),
                                        @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                     (@category_theory.unbundled_hom.bundled_hom.{u}
                                        (λ (α : Type u), topological_space.{u} α)
                                        continuous.{u u}
                                        Top.concrete_category_continuous.{u}))))
                            j)
                       p&#x27;)
                    f
                    (@sigma.snd.{u u} J
                       (λ (j : J),
                          @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                            (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                               (@category_theory.bundled_hom.category.{u} topological_space.{u}
                                  (λ (α β : Type u) (Iα : topological_space.{u} α)
                                   (Iβ : topological_space.{u} β),
                                     @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                  (@category_theory.unbundled_hom.bundled_hom.{u}
                                     (λ (α : Type u), topological_space.{u} α)
                                     continuous.{u u}
                                     Top.concrete_category_continuous.{u}))
                               (Type u)
                               category_theory.types.{u}
                               F
                               (@category_theory.forget.{u} Top.{u}
                                  (@category_theory.bundled_hom.category_theory.concrete_category.{u}
                                     topological_space.{u}
                                     (λ (α β : Type u) (Iα : topological_space.{u} α)
                                      (Iβ : topological_space.{u} β),
                                        @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                     (@category_theory.unbundled_hom.bundled_hom.{u}
                                        (λ (α : Type u), topological_space.{u} α)
                                        continuous.{u u}
                                        Top.concrete_category_continuous.{u}))))
                            j)
                       p))))
       (@category_theory.limits.cocone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u}
          (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
             (@category_theory.bundled_hom.category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u}))
             (Type u)
             category_theory.types.{u}
             F
             (@category_theory.forget.{u} Top.{u}
                (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                   (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                      @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                      continuous.{u u}
                      Top.concrete_category_continuous.{u}))))
          (@category_theory.functor.map_cocone.{u u+1 u+1} J _inst_1 Top.{u}
             (@category_theory.bundled_hom.category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u}))
             (Type u)
             category_theory.types.{u}
             F
             (@category_theory.forget.{u} Top.{u}
                (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                   (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                      @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                      continuous.{u u}
                      Top.concrete_category_continuous.{u})))
             s))
       (λ
        (p :
          @sigma.{u u} J
            (λ (j : J),
               @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                 (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                    (@category_theory.bundled_hom.category.{u} topological_space.{u}
                       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                          continuous.{u u}
                          Top.concrete_category_continuous.{u}))
                    (Type u)
                    category_theory.types.{u}
                    F
                    (@category_theory.forget.{u} Top.{u}
                       (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                             continuous.{u u}
                             Top.concrete_category_continuous.{u}))))
                 j)),
          @category_theory.nat_trans.app.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
            (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
               (@category_theory.bundled_hom.category.{u} topological_space.{u}
                  (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                     @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                  (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                     continuous.{u u}
                     Top.concrete_category_continuous.{u}))
               (Type u)
               category_theory.types.{u}
               F
               (@category_theory.forget.{u} Top.{u}
                  (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                     (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                        @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                     (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                        continuous.{u u}
                        Top.concrete_category_continuous.{u}))))
            (@category_theory.functor.obj.{u u u+1 u+1} (Type u) category_theory.types.{u}
               (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
               (@category_theory.functor.category.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
               (@category_theory.functor.const.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
               (@category_theory.limits.cocone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u}
                  (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                     (@category_theory.bundled_hom.category.{u} topological_space.{u}
                        (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                           @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                        (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                           continuous.{u u}
                           Top.concrete_category_continuous.{u}))
                     (Type u)
                     category_theory.types.{u}
                     F
                     (@category_theory.forget.{u} Top.{u}
                        (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                           (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                              @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                              continuous.{u u}
                              Top.concrete_category_continuous.{u}))))
                  (@category_theory.functor.map_cocone.{u u+1 u+1} J _inst_1 Top.{u}
                     (@category_theory.bundled_hom.category.{u} topological_space.{u}
                        (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                           @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                        (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                           continuous.{u u}
                           Top.concrete_category_continuous.{u}))
                     (Type u)
                     category_theory.types.{u}
                     F
                     (@category_theory.forget.{u} Top.{u}
                        (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                           (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                              @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                              continuous.{u u}
                              Top.concrete_category_continuous.{u})))
                     s)))
            (@category_theory.limits.cocone.ι.{u u+1} J _inst_1 (Type u) category_theory.types.{u}
               (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                  (@category_theory.bundled_hom.category.{u} topological_space.{u}
                     (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                        @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                     (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                        continuous.{u u}
                        Top.concrete_category_continuous.{u}))
                  (Type u)
                  category_theory.types.{u}
                  F
                  (@category_theory.forget.{u} Top.{u}
                     (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                        (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                           @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                        (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                           continuous.{u u}
                           Top.concrete_category_continuous.{u}))))
               (@category_theory.functor.map_cocone.{u u+1 u+1} J _inst_1 Top.{u}
                  (@category_theory.bundled_hom.category.{u} topological_space.{u}
                     (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                        @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                     (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                        continuous.{u u}
                        Top.concrete_category_continuous.{u}))
                  (Type u)
                  category_theory.types.{u}
                  F
                  (@category_theory.forget.{u} Top.{u}
                     (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                        (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                           @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                        (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                           continuous.{u u}
                           Top.concrete_category_continuous.{u})))
                  s))
            (@sigma.fst.{u u} J
               (λ (j : J),
                  @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                    (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                       (@category_theory.bundled_hom.category.{u} topological_space.{u}
                          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                             continuous.{u u}
                             Top.concrete_category_continuous.{u}))
                       (Type u)
                       category_theory.types.{u}
                       F
                       (@category_theory.forget.{u} Top.{u}
                          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                             (@category_theory.unbundled_hom.bundled_hom.{u}
                                (λ (α : Type u), topological_space.{u} α)
                                continuous.{u u}
                                Top.concrete_category_continuous.{u}))))
                    j)
               p)
            (@sigma.snd.{u u} J
               (λ (j : J),
                  @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                    (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                       (@category_theory.bundled_hom.category.{u} topological_space.{u}
                          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                             continuous.{u u}
                             Top.concrete_category_continuous.{u}))
                       (Type u)
                       category_theory.types.{u}
                       F
                       (@category_theory.forget.{u} Top.{u}
                          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                             (@category_theory.unbundled_hom.bundled_hom.{u}
                                (λ (α : Type u), topological_space.{u} α)
                                continuous.{u u}
                                Top.concrete_category_continuous.{u}))))
                    j)
               p))
       (@category_theory.limits.types.colimit_is_colimit._proof_1.{u} J _inst_1
          (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
             (@category_theory.bundled_hom.category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u}))
             (Type u)
             category_theory.types.{u}
             F
             (@category_theory.forget.{u} Top.{u}
                (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                   (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                      @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                      continuous.{u u}
                      Top.concrete_category_continuous.{u}))))
          (@category_theory.functor.map_cocone.{u u+1 u+1} J _inst_1 Top.{u}
             (@category_theory.bundled_hom.category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u}))
             (Type u)
             category_theory.types.{u}
             F
             (@category_theory.forget.{u} Top.{u}
                (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                   (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                      @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                      continuous.{u u}
                      Top.concrete_category_continuous.{u})))
             s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52         coinduced_le_iff_le_induced.mp $ continuous_iff_coinduced_le.mp (s.ι.app j).property) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='coinduced_le_iff_le_induced'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='continuous_iff_coinduced_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 280, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 401, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} {f : α → β} {tα : topological_space.{u} α} {tβ : topological_space.{u} β}, iff (@has_le.le.{u} (topological_space.{u} β) (@preorder.to_has_le.{u} (topological_space.{u} β) (@partial_order.to_preorder.{u} (topological_space.{u} β) (@topological_space.partial_order.{u} β))) (@topological_space.coinduced.{u u} α β f tα) tβ) (@has_le.le.{u} (topological_space.{u} α) (@preorder.to_has_le.{u} (topological_space.{u} α) (@partial_order.to_preorder.{u} (topological_space.{u} α) (@topological_space.partial_order.{u} α))) tα (@topological_space.induced.{u u} α β f tβ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} {f : α → β} {t₁ : topological_space.{u} α} {t₂ : topological_space.{u} β}, iff (@continuous.{u u} α β t₁ t₂ f) (@has_le.le.{u} (topological_space.{u} β) (@preorder.to_has_le.{u} (topological_space.{u} β) (@partial_order.to_preorder.{u} (topological_space.{u} β) (@topological_space.partial_order.{u} β))) (@topological_space.coinduced.{u u} α β f t₁) t₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{u u+1} J _inst_1 Top.{u} (@category_theory.bundled_hom.category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u})) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type u,
_inst_1 : category_theory.small_category.{u} J,
F :
  @category_theory.functor.{u u u u+1} J _inst_1 Top.{u}
    (@category_theory.bundled_hom.category.{u} topological_space.{u}
       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
          Top.concrete_category_continuous.{u})),
s :
  @category_theory.limits.cocone.{u u+1} J _inst_1 Top.{u}
    (@category_theory.bundled_hom.category.{u} topological_space.{u}
       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
          Top.concrete_category_continuous.{u}))
    F
⊢ @continuous.{u u}
    (@category_theory.bundled.α.{u u} topological_space.{u}
       (@category_theory.limits.cocone.X.{u u+1} J _inst_1 Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))
          F
          (@Top.colimit.{u} J _inst_1 F)))
    (@category_theory.bundled.α.{u u} topological_space.{u}
       (@category_theory.limits.cocone.X.{u u+1} J _inst_1 Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))
          F
          s))
    (@category_theory.bundled.str.{u u} topological_space.{u}
       (@category_theory.limits.cocone.X.{u u+1} J _inst_1 Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))
          F
          (@Top.colimit.{u} J _inst_1 F)))
    (@category_theory.bundled.str.{u u} topological_space.{u}
       (@category_theory.limits.cocone.X.{u u+1} J _inst_1 Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))
          F
          s))
    (@quot.lift.{u+1 u+1}
       (@sigma.{u u} J
          (λ (j : J),
             @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
               (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                  (@category_theory.bundled_hom.category.{u} topological_space.{u}
                     (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                        @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                     (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                        continuous.{u u}
                        Top.concrete_category_continuous.{u}))
                  (Type u)
                  category_theory.types.{u}
                  F
                  (@category_theory.forget.{u} Top.{u}
                     (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                        (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                           @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                        (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                           continuous.{u u}
                           Top.concrete_category_continuous.{u}))))
               j))
       (λ
        (p p&#x27; :
          @sigma.{u u} J
            (λ (j : J),
               @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                 (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                    (@category_theory.bundled_hom.category.{u} topological_space.{u}
                       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                          continuous.{u u}
                          Top.concrete_category_continuous.{u}))
                    (Type u)
                    category_theory.types.{u}
                    F
                    (@category_theory.forget.{u} Top.{u}
                       (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                             continuous.{u u}
                             Top.concrete_category_continuous.{u}))))
                 j)),
          @Exists.{u+1}
            (@category_theory.has_hom.hom.{u u} J
               (@category_theory.category_struct.to_has_hom.{u u} J
                  (@category_theory.category.to_category_struct.{u u} J _inst_1))
               (@sigma.fst.{u u} J
                  (λ (j : J),
                     @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                       (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                          (@category_theory.bundled_hom.category.{u} topological_space.{u}
                             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                             (@category_theory.unbundled_hom.bundled_hom.{u}
                                (λ (α : Type u), topological_space.{u} α)
                                continuous.{u u}
                                Top.concrete_category_continuous.{u}))
                          (Type u)
                          category_theory.types.{u}
                          F
                          (@category_theory.forget.{u} Top.{u}
                             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                (@category_theory.unbundled_hom.bundled_hom.{u}
                                   (λ (α : Type u), topological_space.{u} α)
                                   continuous.{u u}
                                   Top.concrete_category_continuous.{u}))))
                       j)
                  p)
               (@sigma.fst.{u u} J
                  (λ (j : J),
                     @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                       (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                          (@category_theory.bundled_hom.category.{u} topological_space.{u}
                             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                             (@category_theory.unbundled_hom.bundled_hom.{u}
                                (λ (α : Type u), topological_space.{u} α)
                                continuous.{u u}
                                Top.concrete_category_continuous.{u}))
                          (Type u)
                          category_theory.types.{u}
                          F
                          (@category_theory.forget.{u} Top.{u}
                             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                (@category_theory.unbundled_hom.bundled_hom.{u}
                                   (λ (α : Type u), topological_space.{u} α)
                                   continuous.{u u}
                                   Top.concrete_category_continuous.{u}))))
                       j)
                  p&#x27;))
            (λ
             (f :
               @category_theory.has_hom.hom.{u u} J
                 (@category_theory.category_struct.to_has_hom.{u u} J
                    (@category_theory.category.to_category_struct.{u u} J _inst_1))
                 (@sigma.fst.{u u} J
                    (λ (j : J),
                       @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                         (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                            (@category_theory.bundled_hom.category.{u} topological_space.{u}
                               (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                                  @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                               (@category_theory.unbundled_hom.bundled_hom.{u}
                                  (λ (α : Type u), topological_space.{u} α)
                                  continuous.{u u}
                                  Top.concrete_category_continuous.{u}))
                            (Type u)
                            category_theory.types.{u}
                            F
                            (@category_theory.forget.{u} Top.{u}
                               (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                                  (λ (α β : Type u) (Iα : topological_space.{u} α)
                                   (Iβ : topological_space.{u} β),
                                     @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                  (@category_theory.unbundled_hom.bundled_hom.{u}
                                     (λ (α : Type u), topological_space.{u} α)
                                     continuous.{u u}
                                     Top.concrete_category_continuous.{u}))))
                         j)
                    p)
                 (@sigma.fst.{u u} J
                    (λ (j : J),
                       @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                         (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                            (@category_theory.bundled_hom.category.{u} topological_space.{u}
                               (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                                  @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                               (@category_theory.unbundled_hom.bundled_hom.{u}
                                  (λ (α : Type u), topological_space.{u} α)
                                  continuous.{u u}
                                  Top.concrete_category_continuous.{u}))
                            (Type u)
                            category_theory.types.{u}
                            F
                            (@category_theory.forget.{u} Top.{u}
                               (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                                  (λ (α β : Type u) (Iα : topological_space.{u} α)
                                   (Iβ : topological_space.{u} β),
                                     @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                  (@category_theory.unbundled_hom.bundled_hom.{u}
                                     (λ (α : Type u), topological_space.{u} α)
                                     continuous.{u u}
                                     Top.concrete_category_continuous.{u}))))
                         j)
                    p&#x27;)),
               @eq.{u+1}
                 (@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                    (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                       (@category_theory.bundled_hom.category.{u} topological_space.{u}
                          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                             continuous.{u u}
                             Top.concrete_category_continuous.{u}))
                       (Type u)
                       category_theory.types.{u}
                       F
                       (@category_theory.forget.{u} Top.{u}
                          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                             (@category_theory.unbundled_hom.bundled_hom.{u}
                                (λ (α : Type u), topological_space.{u} α)
                                continuous.{u u}
                                Top.concrete_category_continuous.{u}))))
                    (@sigma.fst.{u u} J
                       (λ (j : J),
                          @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                            (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                               (@category_theory.bundled_hom.category.{u} topological_space.{u}
                                  (λ (α β : Type u) (Iα : topological_space.{u} α)
                                   (Iβ : topological_space.{u} β),
                                     @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                  (@category_theory.unbundled_hom.bundled_hom.{u}
                                     (λ (α : Type u), topological_space.{u} α)
                                     continuous.{u u}
                                     Top.concrete_category_continuous.{u}))
                               (Type u)
                               category_theory.types.{u}
                               F
                               (@category_theory.forget.{u} Top.{u}
                                  (@category_theory.bundled_hom.category_theory.concrete_category.{u}
                                     topological_space.{u}
                                     (λ (α β : Type u) (Iα : topological_space.{u} α)
                                      (Iβ : topological_space.{u} β),
                                        @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                     (@category_theory.unbundled_hom.bundled_hom.{u}
                                        (λ (α : Type u), topological_space.{u} α)
                                        continuous.{u u}
                                        Top.concrete_category_continuous.{u}))))
                            j)
                       p&#x27;))
                 (@sigma.snd.{u u} J
                    (λ (j : J),
                       @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                         (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                            (@category_theory.bundled_hom.category.{u} topological_space.{u}
                               (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                                  @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                               (@category_theory.unbundled_hom.bundled_hom.{u}
                                  (λ (α : Type u), topological_space.{u} α)
                                  continuous.{u u}
                                  Top.concrete_category_continuous.{u}))
                            (Type u)
                            category_theory.types.{u}
                            F
                            (@category_theory.forget.{u} Top.{u}
                               (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                                  (λ (α β : Type u) (Iα : topological_space.{u} α)
                                   (Iβ : topological_space.{u} β),
                                     @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                  (@category_theory.unbundled_hom.bundled_hom.{u}
                                     (λ (α : Type u), topological_space.{u} α)
                                     continuous.{u u}
                                     Top.concrete_category_continuous.{u}))))
                         j)
                    p&#x27;)
                 (@category_theory.functor.map.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                    (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                       (@category_theory.bundled_hom.category.{u} topological_space.{u}
                          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                             continuous.{u u}
                             Top.concrete_category_continuous.{u}))
                       (Type u)
                       category_theory.types.{u}
                       F
                       (@category_theory.forget.{u} Top.{u}
                          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                             (@category_theory.unbundled_hom.bundled_hom.{u}
                                (λ (α : Type u), topological_space.{u} α)
                                continuous.{u u}
                                Top.concrete_category_continuous.{u}))))
                    (@sigma.fst.{u u} J
                       (λ (j : J),
                          @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                            (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                               (@category_theory.bundled_hom.category.{u} topological_space.{u}
                                  (λ (α β : Type u) (Iα : topological_space.{u} α)
                                   (Iβ : topological_space.{u} β),
                                     @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                  (@category_theory.unbundled_hom.bundled_hom.{u}
                                     (λ (α : Type u), topological_space.{u} α)
                                     continuous.{u u}
                                     Top.concrete_category_continuous.{u}))
                               (Type u)
                               category_theory.types.{u}
                               F
                               (@category_theory.forget.{u} Top.{u}
                                  (@category_theory.bundled_hom.category_theory.concrete_category.{u}
                                     topological_space.{u}
                                     (λ (α β : Type u) (Iα : topological_space.{u} α)
                                      (Iβ : topological_space.{u} β),
                                        @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                     (@category_theory.unbundled_hom.bundled_hom.{u}
                                        (λ (α : Type u), topological_space.{u} α)
                                        continuous.{u u}
                                        Top.concrete_category_continuous.{u}))))
                            j)
                       p)
                    (@sigma.fst.{u u} J
                       (λ (j : J),
                          @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                            (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                               (@category_theory.bundled_hom.category.{u} topological_space.{u}
                                  (λ (α β : Type u) (Iα : topological_space.{u} α)
                                   (Iβ : topological_space.{u} β),
                                     @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                  (@category_theory.unbundled_hom.bundled_hom.{u}
                                     (λ (α : Type u), topological_space.{u} α)
                                     continuous.{u u}
                                     Top.concrete_category_continuous.{u}))
                               (Type u)
                               category_theory.types.{u}
                               F
                               (@category_theory.forget.{u} Top.{u}
                                  (@category_theory.bundled_hom.category_theory.concrete_category.{u}
                                     topological_space.{u}
                                     (λ (α β : Type u) (Iα : topological_space.{u} α)
                                      (Iβ : topological_space.{u} β),
                                        @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                     (@category_theory.unbundled_hom.bundled_hom.{u}
                                        (λ (α : Type u), topological_space.{u} α)
                                        continuous.{u u}
                                        Top.concrete_category_continuous.{u}))))
                            j)
                       p&#x27;)
                    f
                    (@sigma.snd.{u u} J
                       (λ (j : J),
                          @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                            (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                               (@category_theory.bundled_hom.category.{u} topological_space.{u}
                                  (λ (α β : Type u) (Iα : topological_space.{u} α)
                                   (Iβ : topological_space.{u} β),
                                     @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                  (@category_theory.unbundled_hom.bundled_hom.{u}
                                     (λ (α : Type u), topological_space.{u} α)
                                     continuous.{u u}
                                     Top.concrete_category_continuous.{u}))
                               (Type u)
                               category_theory.types.{u}
                               F
                               (@category_theory.forget.{u} Top.{u}
                                  (@category_theory.bundled_hom.category_theory.concrete_category.{u}
                                     topological_space.{u}
                                     (λ (α β : Type u) (Iα : topological_space.{u} α)
                                      (Iβ : topological_space.{u} β),
                                        @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                                     (@category_theory.unbundled_hom.bundled_hom.{u}
                                        (λ (α : Type u), topological_space.{u} α)
                                        continuous.{u u}
                                        Top.concrete_category_continuous.{u}))))
                            j)
                       p))))
       (@category_theory.limits.cocone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u}
          (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
             (@category_theory.bundled_hom.category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u}))
             (Type u)
             category_theory.types.{u}
             F
             (@category_theory.forget.{u} Top.{u}
                (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                   (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                      @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                      continuous.{u u}
                      Top.concrete_category_continuous.{u}))))
          (@category_theory.functor.map_cocone.{u u+1 u+1} J _inst_1 Top.{u}
             (@category_theory.bundled_hom.category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u}))
             (Type u)
             category_theory.types.{u}
             F
             (@category_theory.forget.{u} Top.{u}
                (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                   (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                      @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                      continuous.{u u}
                      Top.concrete_category_continuous.{u})))
             s))
       (λ
        (p :
          @sigma.{u u} J
            (λ (j : J),
               @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                 (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                    (@category_theory.bundled_hom.category.{u} topological_space.{u}
                       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                          continuous.{u u}
                          Top.concrete_category_continuous.{u}))
                    (Type u)
                    category_theory.types.{u}
                    F
                    (@category_theory.forget.{u} Top.{u}
                       (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                             continuous.{u u}
                             Top.concrete_category_continuous.{u}))))
                 j)),
          @category_theory.nat_trans.app.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
            (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
               (@category_theory.bundled_hom.category.{u} topological_space.{u}
                  (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                     @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                  (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                     continuous.{u u}
                     Top.concrete_category_continuous.{u}))
               (Type u)
               category_theory.types.{u}
               F
               (@category_theory.forget.{u} Top.{u}
                  (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                     (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                        @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                     (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                        continuous.{u u}
                        Top.concrete_category_continuous.{u}))))
            (@category_theory.functor.obj.{u u u+1 u+1} (Type u) category_theory.types.{u}
               (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
               (@category_theory.functor.category.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
               (@category_theory.functor.const.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
               (@category_theory.limits.cocone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u}
                  (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                     (@category_theory.bundled_hom.category.{u} topological_space.{u}
                        (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                           @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                        (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                           continuous.{u u}
                           Top.concrete_category_continuous.{u}))
                     (Type u)
                     category_theory.types.{u}
                     F
                     (@category_theory.forget.{u} Top.{u}
                        (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                           (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                              @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                              continuous.{u u}
                              Top.concrete_category_continuous.{u}))))
                  (@category_theory.functor.map_cocone.{u u+1 u+1} J _inst_1 Top.{u}
                     (@category_theory.bundled_hom.category.{u} topological_space.{u}
                        (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                           @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                        (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                           continuous.{u u}
                           Top.concrete_category_continuous.{u}))
                     (Type u)
                     category_theory.types.{u}
                     F
                     (@category_theory.forget.{u} Top.{u}
                        (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                           (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                              @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                              continuous.{u u}
                              Top.concrete_category_continuous.{u})))
                     s)))
            (@category_theory.limits.cocone.ι.{u u+1} J _inst_1 (Type u) category_theory.types.{u}
               (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                  (@category_theory.bundled_hom.category.{u} topological_space.{u}
                     (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                        @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                     (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                        continuous.{u u}
                        Top.concrete_category_continuous.{u}))
                  (Type u)
                  category_theory.types.{u}
                  F
                  (@category_theory.forget.{u} Top.{u}
                     (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                        (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                           @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                        (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                           continuous.{u u}
                           Top.concrete_category_continuous.{u}))))
               (@category_theory.functor.map_cocone.{u u+1 u+1} J _inst_1 Top.{u}
                  (@category_theory.bundled_hom.category.{u} topological_space.{u}
                     (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                        @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                     (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                        continuous.{u u}
                        Top.concrete_category_continuous.{u}))
                  (Type u)
                  category_theory.types.{u}
                  F
                  (@category_theory.forget.{u} Top.{u}
                     (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                        (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                           @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                        (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                           continuous.{u u}
                           Top.concrete_category_continuous.{u})))
                  s))
            (@sigma.fst.{u u} J
               (λ (j : J),
                  @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                    (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                       (@category_theory.bundled_hom.category.{u} topological_space.{u}
                          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                             continuous.{u u}
                             Top.concrete_category_continuous.{u}))
                       (Type u)
                       category_theory.types.{u}
                       F
                       (@category_theory.forget.{u} Top.{u}
                          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                             (@category_theory.unbundled_hom.bundled_hom.{u}
                                (λ (α : Type u), topological_space.{u} α)
                                continuous.{u u}
                                Top.concrete_category_continuous.{u}))))
                    j)
               p)
            (@sigma.snd.{u u} J
               (λ (j : J),
                  @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                    (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
                       (@category_theory.bundled_hom.category.{u} topological_space.{u}
                          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                             continuous.{u u}
                             Top.concrete_category_continuous.{u}))
                       (Type u)
                       category_theory.types.{u}
                       F
                       (@category_theory.forget.{u} Top.{u}
                          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                             (@category_theory.unbundled_hom.bundled_hom.{u}
                                (λ (α : Type u), topological_space.{u} α)
                                continuous.{u u}
                                Top.concrete_category_continuous.{u}))))
                    j)
               p))
       (@category_theory.limits.types.colimit_is_colimit._proof_1.{u} J _inst_1
          (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 Top.{u}
             (@category_theory.bundled_hom.category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u}))
             (Type u)
             category_theory.types.{u}
             F
             (@category_theory.forget.{u} Top.{u}
                (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                   (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                      @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                      continuous.{u u}
                      Top.concrete_category_continuous.{u}))))
          (@category_theory.functor.map_cocone.{u u+1 u+1} J _inst_1 Top.{u}
             (@category_theory.bundled_hom.category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u}))
             (Type u)
             category_theory.types.{u}
             F
             (@category_theory.forget.{u} Top.{u}
                (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                   (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                      @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                      continuous.{u u}
                      Top.concrete_category_continuous.{u})))
             s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54  instance Top_has_colimits : has_colimits.{u} Top.{u} :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='category_theory.limits.has_colimits'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='Top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 677, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/Top/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Π (C : Type u) [𝒞 : category_theory.category.{v u} C], Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='`C` has all (small) colimits if it has colimits of every shape.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The category of topological spaces and continuous maps.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  { has_colimits_of_shape := λ J 𝒥,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝒥'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='category_theory.small_category.{u} J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56    { has_colimit := λ F, by exactI { cocone := colimit F, is_colimit := colimit_is_colimit F } } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='Top.colimit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='Top.colimit_is_colimit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 43, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J 𝒥 Top.{u} (@category_theory.bundled_hom.category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u}))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] (F : @category_theory.functor.{u u u u+1} J _inst_1 Top.{u} (@category_theory.bundled_hom.category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u}))), @category_theory.limits.cocone.{u u+1} J _inst_1 Top.{u} (@category_theory.bundled_hom.category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u})) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] (F : @category_theory.functor.{u u u u+1} J _inst_1 Top.{u} (@category_theory.bundled_hom.category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u}))), @category_theory.limits.is_colimit.{u u+1} J _inst_1 Top.{u} (@category_theory.bundled_hom.category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u})) F (@Top.colimit.{u} J _inst_1 F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.functor.{u u u u+1} J 𝒥 Top.{u} (@category_theory.bundled_hom.category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u}))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='lime'><a title='J : Type u,
𝒥 : category_theory.small_category.{u} J,
F :
  @category_theory.functor.{u u u u+1} J 𝒥 Top.{u}
    (@category_theory.bundled_hom.category.{u} topological_space.{u}
       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
          Top.concrete_category_continuous.{u}))
⊢ @category_theory.limits.has_colimit.{u u+1} J 𝒥 Top.{u}
    (@category_theory.bundled_hom.category.{u} topological_space.{u}
       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
          Top.concrete_category_continuous.{u}))
    F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58  instance forget_preserves_colimits : preserves_colimits (forget : Top.{u} ⥤ Type u) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='category_theory.limits.preserves_colimits'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.forget'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/preserves.lean&#x27;, &#x27;line&#x27;: 59, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/Top/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v u₂} D], @category_theory.functor.{v v u₁ u₂} C 𝒞 D 𝒟 → Type (max u₁ u₂ (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (C : Type (u+1)) [_inst_1 : category_theory.concrete_category.{u} C], @category_theory.functor.{u u u+1 u+1} C (@category_theory.concrete_category.to_category.{u} C _inst_1) (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (C : Type (u+1)) [_inst_1 : category_theory.category.{u u+1} C] (D : Type (u+1)) [_inst_2 : category_theory.category.{u u+1} D], Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                         </code><font color='orange'><a title='The forgetful functor from a concrete category to `Type u`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The category of topological spaces and continuous maps.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  { preserves_colimits_of_shape := λ J 𝒥,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝒥'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='category_theory.small_category.{u} J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60    { preserves_colimit := λ F,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J 𝒥 Top.{u} (@category_theory.concrete_category.to_category.{u} Top.{u} (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u})))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61      by exactI preserves_colimit_of_preserves_colimit_cocone</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='category_theory.limits.preserves_colimit_of_preserves_colimit_cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/preserves.lean&#x27;, &#x27;line&#x27;: 123, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (u+1)} [𝒞 : category_theory.category.{u u+1} C] {D : Type (u+1)} [𝒟 : category_theory.category.{u u+1} D] {J : Type u} [_inst_1 : category_theory.small_category.{u} J] {K : @category_theory.functor.{u u u u+1} J _inst_1 C 𝒞} {F : @category_theory.functor.{u u u+1 u+1} C 𝒞 D 𝒟} {t : @category_theory.limits.cocone.{u u+1} J _inst_1 C 𝒞 K}, @category_theory.limits.is_colimit.{u u+1} J _inst_1 C 𝒞 K t → @category_theory.limits.is_colimit.{u u+1} J _inst_1 D 𝒟 (@category_theory.functor.comp.{u u u u u+1 u+1} J _inst_1 C 𝒞 D 𝒟 K F) (@category_theory.functor.map_cocone.{u u+1 u+1} J _inst_1 C 𝒞 D 𝒟 K F t) → @category_theory.limits.preserves_colimit.{u u+1 u+1} C 𝒞 D 𝒟 J _inst_1 K F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='If F preserves one colimit cocone for the diagram K,
 then it preserves any colimit cocone for K.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='lime'><a title='J : Type u,
𝒥 : category_theory.small_category.{u} J,
F :
  @category_theory.functor.{u u u u+1} J 𝒥 Top.{u}
    (@category_theory.concrete_category.to_category.{u} Top.{u}
       (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u})))
⊢ @category_theory.limits.preserves_colimit.{u u+1 u+1} Top.{u}
    (@category_theory.concrete_category.to_category.{u} Top.{u}
       (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u})))
    (Type u)
    category_theory.types.{u}
    J
    𝒥
    F
    (@category_theory.forget.{u} Top.{u}
       (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u})))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62        (colimit.is_colimit F) (colimit.is_colimit (F ⋙ forget)) } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='category_theory.limits.colimit.is_colimit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.forget'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 707, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] {C : Type (u+1)} [𝒞 : category_theory.category.{u u+1} C] (F : @category_theory.functor.{u u u u+1} J _inst_1 C 𝒞) [_inst_3 : @category_theory.limits.has_colimit.{u u+1} J _inst_1 C 𝒞 F], @category_theory.limits.is_colimit.{u u+1} J _inst_1 C 𝒞 F (@category_theory.limits.colimit.cocone.{u u+1} J _inst_1 C 𝒞 F _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J 𝒥 Top.{u} (@category_theory.concrete_category.to_category.{u} Top.{u} (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u})))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{u u} C] {D : Type (u+1)} [𝒟 : category_theory.category.{u u+1} D] {E : Type (u+1)} [ℰ : category_theory.category.{u u+1} E], @category_theory.functor.{u u u u+1} C 𝒞 D 𝒟 → @category_theory.functor.{u u u+1 u+1} D 𝒟 E ℰ → @category_theory.functor.{u u u u+1} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (C : Type (u+1)) [_inst_1 : category_theory.concrete_category.{u} C], @category_theory.functor.{u u u+1 u+1} C (@category_theory.concrete_category.to_category.{u} C _inst_1) (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The forgetful functor from a concrete category to `Type u`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type u,
𝒥 : category_theory.small_category.{u} J,
F :
  @category_theory.functor.{u u u u+1} J 𝒥 Top.{u}
    (@category_theory.concrete_category.to_category.{u} Top.{u}
       (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u})))
⊢ @category_theory.limits.preserves_colimit.{u u+1 u+1} Top.{u}
    (@category_theory.concrete_category.to_category.{u} Top.{u}
       (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u})))
    (Type u)
    category_theory.types.{u}
    J
    𝒥
    F
    (@category_theory.forget.{u} Top.{u}
       (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u})))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  end Top</code></pre>
</body>