<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2018 Mario Carneiro. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Author: Mario Carneiro</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  Denumerable (countably infinite) types, as a typeclass extending</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  encodable. This is used to provide explicit encode/decode functions</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  from nat, where the functions are known inverses of each other.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  import data.equiv.encodable data.sigma data.fintype data.list.min_max</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/encodable.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/sigma/default.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/min_max.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  open nat</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  section prio</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  set_option default_priority 100 -- see Note [default priority]</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='default priority for attributes'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  /-- A denumerable type is one which is (constructively) bijective with ℕ.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16    Although we already have a name for this property, namely `α ≃ ℕ`,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17    we are here interested in using it as a typeclass. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  class denumerable (α : Type*) extends encodable α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='encodable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/encodable.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='orange'><a title='An encodable type is a &quot;constructively countable&quot; type. This is where
 we have an explicit injection `encode : α → nat` and a partial inverse
 `decode : nat → option α`. This makes the range of `encode` decidable,
 although it is not decidable if `α` is finite or not.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  (decode_inv : ∀ n, ∃ a ∈ decode n, encode a = n)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='decode'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='encode'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@(λ {α : Type u_1} (c : encodable.{u_1} α), nat → option.{u_1} α) α to_encodable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@(λ {α : Type u_1} (c : encodable.{u_1} α), α → nat) α to_encodable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  end prio</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  namespace denumerable</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  section</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  variables {α : Type*} {β : Type*} [denumerable α] [denumerable β]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='denumerable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='denumerable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='A denumerable type is one which is (constructively) bijective with ℕ.
 Although we already have a name for this property, namely `α ≃ ℕ`,
 we are here interested in using it as a typeclass.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A denumerable type is one which is (constructively) bijective with ℕ.
 Although we already have a name for this property, namely `α ≃ ℕ`,
 we are here interested in using it as a typeclass.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  open encodable</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  @[simp] theorem decode_is_some (α) [denumerable α] (n : ℕ) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='denumerable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='red'><a title='{&#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='A denumerable type is one which is (constructively) bijective with ℕ.
 Although we already have a name for this property, namely `α ≃ ℕ`,
 we are here interested in using it as a typeclass.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29    (decode α n).is_some :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='encodable.decode'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.is_some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/encodable.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/option/basic.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) [c : encodable.{u_1} α], nat → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, option.{u_1} α → bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  option.is_some_iff_exists.2 $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='option.is_some_iff_exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/option/basic.lean&#x27;, &#x27;line&#x27;: 115, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {x : option.{u_1} α}, iff (@coe_sort.{1 1} bool coe_sort_bool (@option.is_some.{u_1} α x)) (@Exists.{u_1+1} α (λ (a : α), @eq.{u_1+1} (option.{u_1} α) x (@option.some.{u_1} α a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  (decode_inv α n).imp $ λ a, Exists.fst</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='denumerable.decode_inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Exists.imp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 426, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 549, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (α : Type u_1) [c : denumerable.{u_1} α] (n : nat), @Exists.{u_1+1} α (λ (a : α), @Exists.{0} (@has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) a (@encodable.decode.{u_1} α (@denumerable.to_encodable.{u_1} α c) n)) (λ (H : @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) a (@encodable.decode.{u_1} α (@denumerable.to_encodable.{u_1} α c) n)), @eq.{1} nat (@encodable.encode.{u_1} α (@denumerable.to_encodable.{u_1} α c) a) n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {q p : α → Prop}, (∀ (a : α), p a → q a) → @Exists.{u_1+1} α (λ (a : α), p a) → @Exists.{u_1+1} α (λ (a : α), q a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {b : Prop} {p : b → Prop}, @Exists.{0} b p → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  def of_nat (α) [f : denumerable α] (n : ℕ) : α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='denumerable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='A denumerable type is one which is (constructively) bijective with ℕ.
 Although we already have a name for this property, namely `α ≃ ℕ`,
 we are here interested in using it as a typeclass.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  option.get (decode_is_some α n)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='option.get'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='denumerable.decode_is_some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/option/basic.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 28, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {o : option.{u} α}, @coe_sort.{1 1} bool coe_sort_bool (@option.is_some.{u} α o) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ (α : Type u_1) [_inst_3 : denumerable.{u_1} α] (n : nat), @coe_sort.{1 1} bool coe_sort_bool (@option.is_some.{u_1} α (@encodable.decode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_3) n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36  @[simp] theorem decode_eq_of_nat (α) [denumerable α] (n : ℕ) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='blue'><a title='denumerable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='A denumerable type is one which is (constructively) bijective with ℕ.
 Although we already have a name for this property, namely `α ≃ ℕ`,
 we are here interested in using it as a typeclass.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37    decode α n = some (of_nat α n) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='encodable.decode'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='denumerable.of_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/encodable.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [c : encodable.{u_1} α], nat → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [f : denumerable.{u_1} α], nat → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  option.eq_some_of_is_some _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='option.eq_some_of_is_some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/option/instances.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {o : option.{u_1} α} (h : @coe_sort.{1 1} bool coe_sort_bool (@option.is_some.{u_1} α o)), @eq.{u_1+1} (option.{u_1} α) o (@option.some.{u_1} α (@option.get.{u_1} α o h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  @[simp] theorem of_nat_of_decode {n b}</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41    (h : decode α n = some b) : of_nat α n = b :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='encodable.decode'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='denumerable.of_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/encodable.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π (α : Type u_1) [c : encodable.{u_1} α], nat → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u_1) [f : denumerable.{u_1} α], nat → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  option.some.inj $ (decode_eq_of_nat _ _).symm.trans h</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='option.some.inj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='denumerable.decode_eq_of_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 36, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 195, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {val val_1 : α}, @eq.{u_1+1} (option.{u_1} α) (@option.some.{u_1} α val) (@option.some.{u_1} α val_1) → @eq.{u_1+1} α val val_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ (α : Type u_1) [_inst_3 : denumerable.{u_1} α] (n : nat), @eq.{u_1+1} (option.{u_1} α) (@encodable.decode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_3) n) (@option.some.{u_1} α (@denumerable.of_nat.{u_1} α _inst_3 n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u_1} {a b : α}, @eq.{u_1+1} α a b → @eq.{u_1+1} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {a b c : α}, @eq.{u_1+1} α a b → @eq.{u_1+1} α b c → @eq.{u_1+1} α a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@eq.{u_1+1} (option.{u_1} α) (@encodable.decode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) n) (@option.some.{u_1} α b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  @[simp] theorem encode_of_nat (n) : encode (of_nat α n) = n :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='encodable.encode'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='denumerable.of_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/encodable.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='Π {α : Type u_1} [c : encodable.{u_1} α], α → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [f : denumerable.{u_1} α], nat → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  let ⟨a, h, e⟩ := decode_inv α n in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='denumerable.decode_inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{u_1+1} α (λ (a : α), @Exists.{0} (@has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) a (@encodable.decode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) n)) (λ (H : @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) a (@encodable.decode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) n)), @eq.{1} nat (@encodable.encode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) a) n)) → @eq.{1} nat (@encodable.encode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) (@denumerable.of_nat.{u_1} α _inst_1 n)) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='∀ (α : Type u_1) [c : denumerable.{u_1} α] (n : nat), @Exists.{u_1+1} α (λ (a : α), @Exists.{0} (@has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) a (@encodable.decode.{u_1} α (@denumerable.to_encodable.{u_1} α c) n)) (λ (H : @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) a (@encodable.decode.{u_1} α (@denumerable.to_encodable.{u_1} α c) n)), @eq.{1} nat (@encodable.encode.{u_1} α (@denumerable.to_encodable.{u_1} α c) a) n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  by rwa [of_nat_of_decode h]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='denumerable.of_nat_of_decode'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 40, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : denumerable.{u_1} α] {n : nat} {b : α}, @eq.{u_1+1} (option.{u_1} α) (@encodable.decode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) n) (@option.some.{u_1} α b) → @eq.{u_1+1} α (@denumerable.of_nat.{u_1} α _inst_1 n) b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) a (@encodable.decode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u_1,
_inst_1 : denumerable.{u_1} α,
n : nat,
_let_match :
  @Exists.{u_1+1} α
    (λ (a : α),
       @Exists.{0}
         (@has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) a
            (@encodable.decode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) n))
         (λ
          (H :
            @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) a
              (@encodable.decode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) n)),
            @eq.{1} nat (@encodable.encode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) a) n)) →
  @eq.{1} nat
    (@encodable.encode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) (@denumerable.of_nat.{u_1} α _inst_1 n))
    n,
a : α,
h :
  @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) a
    (@encodable.decode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) n),
e : @eq.{1} nat (@encodable.encode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) a) n
⊢ @eq.{1} nat
    (@encodable.encode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) (@denumerable.of_nat.{u_1} α _inst_1 n))
    n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : denumerable.{u_1} α,
n : nat,
_let_match :
  @Exists.{u_1+1} α
    (λ (a : α),
       @Exists.{0}
         (@has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) a
            (@encodable.decode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) n))
         (λ
          (H :
            @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) a
              (@encodable.decode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) n)),
            @eq.{1} nat (@encodable.encode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) a) n)) →
  @eq.{1} nat
    (@encodable.encode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) (@denumerable.of_nat.{u_1} α _inst_1 n))
    n,
a : α,
h :
  @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) a
    (@encodable.decode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) n),
e : @eq.{1} nat (@encodable.encode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) a) n
⊢ @eq.{1} nat (@encodable.encode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) a) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : denumerable.{u_1} α,
n : nat,
_let_match :
  @Exists.{u_1+1} α
    (λ (a : α),
       @Exists.{0}
         (@has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) a
            (@encodable.decode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) n))
         (λ
          (H :
            @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) a
              (@encodable.decode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) n)),
            @eq.{1} nat (@encodable.encode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) a) n)) →
  @eq.{1} nat
    (@encodable.encode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) (@denumerable.of_nat.{u_1} α _inst_1 n))
    n,
a : α,
h :
  @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) a
    (@encodable.decode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) n),
e : @eq.{1} nat (@encodable.encode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) a) n
⊢ @eq.{1} nat
    (@encodable.encode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) (@denumerable.of_nat.{u_1} α _inst_1 n))
    n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : denumerable.{u_1} α,
n : nat,
_let_match :
  @Exists.{u_1+1} α
    (λ (a : α),
       @Exists.{0}
         (@has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) a
            (@encodable.decode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) n))
         (λ
          (H :
            @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) a
              (@encodable.decode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) n)),
            @eq.{1} nat (@encodable.encode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) a) n)) →
  @eq.{1} nat
    (@encodable.encode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) (@denumerable.of_nat.{u_1} α _inst_1 n))
    n,
a : α,
h :
  @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) a
    (@encodable.decode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) n),
e : @eq.{1} nat (@encodable.encode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) a) n
⊢ @eq.{1} nat
    (@encodable.encode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) (@denumerable.of_nat.{u_1} α _inst_1 n))
    n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  @[simp] theorem of_nat_encode (a) : of_nat α (encode a) = a :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='denumerable.of_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='encodable.encode'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/encodable.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='Π (α : Type u_1) [f : denumerable.{u_1} α], nat → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [c : encodable.{u_1} α], α → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  of_nat_of_decode (encodek _)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='denumerable.of_nat_of_decode'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='encodable.encodek'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 40, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/encodable.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : denumerable.{u_1} α] {n : nat} {b : α}, @eq.{u_1+1} (option.{u_1} α) (@encodable.decode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) n) (@option.some.{u_1} α b) → @eq.{u_1+1} α (@denumerable.of_nat.{u_1} α _inst_1 n) b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} [c : encodable.{u_1} α] (a : α), @eq.{u_1+1} (option.{u_1} α) (@encodable.decode.{u_1} α c (@encodable.encode.{u_1} α c a)) (@option.some.{u_1} α a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  def eqv (α) [denumerable α] : α ≃ ℕ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='denumerable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='A denumerable type is one which is (constructively) bijective with ℕ.
 Although we already have a name for this property, namely `α ≃ ℕ`,
 we are here interested in using it as a typeclass.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`α ≃ β` is the type of functions from `α → β` with a two-sided inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  ⟨encode, of_nat α, of_nat_encode, encode_of_nat⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='encodable.encode'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='denumerable.of_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='denumerable.of_nat_encode'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='denumerable.encode_of_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/encodable.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 48, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : encodable.{u_1} α], α → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [f : denumerable.{u_1} α], nat → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : denumerable.{u_1} α] (a : α), @eq.{u_1+1} α (@denumerable.of_nat.{u_1} α _inst_1 (@encodable.encode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) a)) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : denumerable.{u_1} α] (n : nat), @eq.{1} nat (@encodable.encode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1) (@denumerable.of_nat.{u_1} α _inst_1 n)) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54  def mk&#x27; {α} (e : α ≃ ℕ) : denumerable α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='denumerable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`α ≃ β` is the type of functions from `α → β` with a two-sided inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A denumerable type is one which is (constructively) bijective with ℕ.
 Although we already have a name for this property, namely `α ≃ ℕ`,
 we are here interested in using it as a typeclass.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  { encode := e,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='equiv.{u_1+1 1} α nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56    decode := some ∘ e.symm,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} {β φ : Type u_1}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.{u_1+1 1} α nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type}, equiv.{u_1+1 1} α β → equiv.{1 u_1+1} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57    encodek := λ a, congr_arg some (e.symm_apply_apply _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='congr_arg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='equiv.symm_apply_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 98, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), @eq.{u} α a₁ a₂ → @eq.{v} β (f a₁) (f a₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='equiv.{u_1+1 1} α nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type} (e : equiv.{u_1+1 1} α β) (x : α), @eq.{u_1+1} α (@coe_fn.{(max 1 (max 1 (u_1+1)) (u_1+1) 1) (max 1 (u_1+1))} (equiv.{1 u_1+1} β α) (@equiv.has_coe_to_fun.{1 u_1+1} β α) (@equiv.symm.{u_1+1 1} α β e) (@coe_fn.{(max 1 (max (u_1+1) 1) 1 (u_1+1)) (max (u_1+1) 1)} (equiv.{u_1+1 1} α β) (@equiv.has_coe_to_fun.{u_1+1 1} α β) e x)) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58    decode_inv := λ n, ⟨_, rfl, e.apply_symm_apply _⟩ }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='equiv.apply_symm_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 95, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α : Sort u} {a : α}, @eq.{u} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='equiv.{u_1+1 1} α nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type} (e : equiv.{u_1+1 1} α β) (x : β), @eq.{1} β (@coe_fn.{(max 1 (max (u_1+1) 1) 1 (u_1+1)) (max (u_1+1) 1)} (equiv.{u_1+1 1} α β) (@equiv.has_coe_to_fun.{u_1+1 1} α β) e (@coe_fn.{(max 1 (max 1 (u_1+1)) (u_1+1) 1) (max 1 (u_1+1))} (equiv.{1 u_1+1} β α) (@equiv.has_coe_to_fun.{1 u_1+1} β α) (@equiv.symm.{u_1+1 1} α β e) x)) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60  def of_equiv (α) {β} [denumerable α] (e : β ≃ α) : denumerable β :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='denumerable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='denumerable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2 → Type u_1 → Type (max (max u_2 u_1) u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='A denumerable type is one which is (constructively) bijective with ℕ.
 Although we already have a name for this property, namely `α ≃ ℕ`,
 we are here interested in using it as a typeclass.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`α ≃ β` is the type of functions from `α → β` with a two-sided inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A denumerable type is one which is (constructively) bijective with ℕ.
 Although we already have a name for this property, namely `α ≃ ℕ`,
 we are here interested in using it as a typeclass.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  { decode_inv := λ n, by simp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='lime'><a title='α : Type ?l_1,
β : Type ?l_2,
_inst_3 : denumerable.{?l_1} α,
e : equiv.{?l_2+1 ?l_1+1} β α,
n : nat
⊢ @Exists.{?l_2+1} β
    (λ (a : β),
       @Exists.{0}
         ((λ (a : β) (b : option.{?l_2} β), @eq.{?l_2+1} (option.{?l_2} β) b (@option.some.{?l_2} β a)) a
            ((λ (n : nat),
                @option.bind.{?l_1 ?l_2} α β
                  (@encodable.decode.{?l_1} α (@denumerable.to_encodable.{?l_1} α _inst_3) n)
                  (@function.comp.{?l_1+1 ?l_2+1 ?l_2+1} α β (option.{?l_2} β) (@option.some.{?l_2} β)
                     (@coe_fn.{(max 1 (max (?l_1+1) (?l_2+1)) (?l_2+1) (?l_1+1)) (max (?l_1+1) (?l_2+1))}
                        (equiv.{?l_1+1 ?l_2+1} α β)
                        (@equiv.has_coe_to_fun.{?l_1+1 ?l_2+1} α β)
                        (@equiv.symm.{?l_2+1 ?l_1+1} β α e))))
               n))
         (λ
          (H :
            (λ (a : β) (b : option.{?l_2} β), @eq.{?l_2+1} (option.{?l_2} β) b (@option.some.{?l_2} β a)) a
              ((λ (n : nat),
                  @option.bind.{?l_1 ?l_2} α β
                    (@encodable.decode.{?l_1} α (@denumerable.to_encodable.{?l_1} α _inst_3) n)
                    (@function.comp.{?l_1+1 ?l_2+1 ?l_2+1} α β (option.{?l_2} β) (@option.some.{?l_2} β)
                       (@coe_fn.{(max 1 (max (?l_1+1) (?l_2+1)) (?l_2+1) (?l_1+1)) (max (?l_1+1) (?l_2+1))}
                          (equiv.{?l_1+1 ?l_2+1} α β)
                          (@equiv.has_coe_to_fun.{?l_1+1 ?l_2+1} α β)
                          (@equiv.symm.{?l_2+1 ?l_1+1} β α e))))
                 n)),
            @eq.{1} nat
              ((λ (b : β),
                  @encodable.encode.{?l_1} α (@denumerable.to_encodable.{?l_1} α _inst_3)
                    (@coe_fn.{(max 1 (max (?l_2+1) (?l_1+1)) (?l_1+1) (?l_2+1)) (max (?l_2+1) (?l_1+1))}
                       (equiv.{?l_2+1 ?l_1+1} β α)
                       (@equiv.has_coe_to_fun.{?l_2+1 ?l_1+1} β α)
                       e
                       b))
                 a)
              n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62    ..encodable.of_equiv _ e }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='encodable.of_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/encodable.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {β : Type u_2} (α : Type u_1) [_inst_1 : encodable.{u_1} α], equiv.{u_2+1 u_1+1} β α → encodable.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='equiv.{u_2+1 u_1+1} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='If `α` is encodable and `β ≃ α`, then so is `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  @[simp] theorem of_equiv_of_nat (α) {β} [denumerable α] (e : β ≃ α)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='blue'><a title='denumerable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='red'><a title='{&#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2 → Type u_1 → Type (max (max u_2 u_1) u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='A denumerable type is one which is (constructively) bijective with ℕ.
 Although we already have a name for this property, namely `α ≃ ℕ`,
 we are here interested in using it as a typeclass.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`α ≃ β` is the type of functions from `α → β` with a two-sided inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65    (n) : @of_nat β (of_equiv _ e) n = e.symm (of_nat α n) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='denumerable.of_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='denumerable.of_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='denumerable.of_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π (α : Type u_1) [f : denumerable.{u_1} α], nat → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) {β : Type u_2} [_inst_3 : denumerable.{u_1} α], equiv.{u_2+1 u_1+1} β α → denumerable.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='equiv.{u_2+1 u_1+1} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.{u_2+1 u_1+1} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type u_1}, equiv.{u_2+1 u_1+1} α β → equiv.{u_1+1 u_2+1} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [f : denumerable.{u_1} α], nat → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  by apply of_nat_of_decode; show option.map _ _ = _; simp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='denumerable.of_nat_of_decode'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='option.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 40, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/option/basic.lean&#x27;, &#x27;line&#x27;: 49, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : denumerable.{u_2} α] {n : nat} {b : α}, @eq.{u_2+1} (option.{u_2} α) (@encodable.decode.{u_2} α (@denumerable.to_encodable.{u_2} α _inst_1) n) (@option.some.{u_2} α b) → @eq.{u_2+1} α (@denumerable.of_nat.{u_2} α _inst_1 n) b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, (α → β) → option.{u_1} α → option.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_3 : denumerable.{u_1} α,
e : equiv.{u_2+1 u_1+1} β α,
n : nat
⊢ @eq.{u_2+1} β (@denumerable.of_nat.{u_2} β (@denumerable.of_equiv.{u_1 u_2} α β _inst_3 e) n)
    (@coe_fn.{(max 1 (max (u_1+1) (u_2+1)) (u_2+1) (u_1+1)) (max (u_1+1) (u_2+1))} (equiv.{u_1+1 u_2+1} α β)
       (@equiv.has_coe_to_fun.{u_1+1 u_2+1} α β)
       (@equiv.symm.{u_2+1 u_1+1} β α e)
       (@denumerable.of_nat.{u_1} α _inst_3 n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_3 : denumerable.{u_1} α,
e : equiv.{u_2+1 u_1+1} β α,
n : nat
⊢ @eq.{u_2+1} β (@denumerable.of_nat.{u_2} β (@denumerable.of_equiv.{u_1 u_2} α β _inst_3 e) n)
    (@coe_fn.{(max 1 (max (u_1+1) (u_2+1)) (u_2+1) (u_1+1)) (max (u_1+1) (u_2+1))} (equiv.{u_1+1 u_2+1} α β)
       (@equiv.has_coe_to_fun.{u_1+1 u_2+1} α β)
       (@equiv.symm.{u_2+1 u_1+1} β α e)
       (@denumerable.of_nat.{u_1} α _inst_3 n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68  def equiv₂ (α β) [denumerable α] [denumerable β] : α ≃ β := (eqv α).trans (eqv β).symm</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='denumerable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='denumerable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='denumerable.eqv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='denumerable.eqv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 51, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 60, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 51, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_2 → Type (max (max u_1 u_2) u_2 u_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u_1) [_inst_3 : denumerable.{u_1} α], equiv.{u_1+1 1} α nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type} {γ : Type u_2}, equiv.{u_1+1 1} α β → equiv.{1 u_2+1} β γ → equiv.{u_1+1 u_2+1} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) [_inst_3 : denumerable.{u_1} α], equiv.{u_1+1 1} α nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {β : Type}, equiv.{u_2+1 1} α β → equiv.{1 u_2+1} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='A denumerable type is one which is (constructively) bijective with ℕ.
 Although we already have a name for this property, namely `α ≃ ℕ`,
 we are here interested in using it as a typeclass.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A denumerable type is one which is (constructively) bijective with ℕ.
 Although we already have a name for this property, namely `α ≃ ℕ`,
 we are here interested in using it as a typeclass.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`α ≃ β` is the type of functions from `α → β` with a two-sided inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  instance nat : denumerable nat := ⟨λ n, ⟨_, rfl, rfl⟩⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='denumerable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α : Sort u} {a : α}, @eq.{u} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Sort u} {a : α}, @eq.{u} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='A denumerable type is one which is (constructively) bijective with ℕ.
 Although we already have a name for this property, namely `α ≃ ℕ`,
 we are here interested in using it as a typeclass.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72  @[simp] theorem of_nat_nat (n) : of_nat ℕ n = n := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='denumerable.of_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Π (α : Type u_1) [f : denumerable.{u_1} α], nat → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type} {a : α}, @eq.{1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74  instance option : denumerable (option α) := ⟨λ n, by cases n; simp⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='denumerable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='option'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='A denumerable type is one which is (constructively) bijective with ℕ.
 Although we already have a name for this property, namely `α ≃ ℕ`,
 we are here interested in using it as a typeclass.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='lime'><a title='α : Type u_1,
_inst_1 : denumerable.{u_1} α,
n : nat
⊢ @Exists.{u_1+1} (option.{u_1} α)
    (λ (a : option.{u_1} α),
       @Exists.{0}
         (@has_mem.mem.{u_1 u_1} (option.{u_1} α) (option.{u_1} (option.{u_1} α))
            (@option.has_mem.{u_1} (option.{u_1} α))
            a
            (@encodable.decode.{u_1} (option.{u_1} α)
               (@encodable.option.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1))
               n))
         (λ
          (H :
            @has_mem.mem.{u_1 u_1} (option.{u_1} α) (option.{u_1} (option.{u_1} α))
              (@option.has_mem.{u_1} (option.{u_1} α))
              a
              (@encodable.decode.{u_1} (option.{u_1} α)
                 (@encodable.option.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1))
                 n)),
            @eq.{1} nat
              (@encodable.encode.{u_1} (option.{u_1} α)
                 (@encodable.option.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1))
                 a)
              n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76  instance sum : denumerable (α ⊕ β) :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77  ⟨λ n, begin</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78    suffices : ∃ a ∈ @decode_sum α β _ _ n,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u_1 u_2)}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : denumerable.{u_1} α,
_inst_2 : denumerable.{u_2} β,
n : nat
⊢ @Exists.{(max u_1 u_2)+1} (sum.{u_1 u_2} α β)
    (λ (a : sum.{u_1 u_2} α β),
       @Exists.{0}
         (@has_mem.mem.{(max u_1 u_2) (max u_1 u_2)} (sum.{u_1 u_2} α β)
            (option.{(max u_1 u_2)} (sum.{u_1 u_2} α β))
            (@option.has_mem.{(max u_1 u_2)} (sum.{u_1 u_2} α β))
            a
            (@encodable.decode.{(max u_1 u_2)} (sum.{u_1 u_2} α β)
               (@encodable.sum.{u_1 u_2} α β (@denumerable.to_encodable.{u_1} α _inst_1)
                  (@denumerable.to_encodable.{u_2} β _inst_2))
               n))
         (λ
          (H :
            @has_mem.mem.{(max u_1 u_2) (max u_1 u_2)} (sum.{u_1 u_2} α β)
              (option.{(max u_1 u_2)} (sum.{u_1 u_2} α β))
              (@option.has_mem.{(max u_1 u_2)} (sum.{u_1 u_2} α β))
              a
              (@encodable.decode.{(max u_1 u_2)} (sum.{u_1 u_2} α β)
                 (@encodable.sum.{u_1 u_2} α β (@denumerable.to_encodable.{u_1} α _inst_1)
                    (@denumerable.to_encodable.{u_2} β _inst_2))
                 n)),
            @eq.{1} nat
              (@encodable.encode.{(max u_1 u_2)} (sum.{u_1 u_2} α β)
                 (@encodable.sum.{u_1 u_2} α β (@denumerable.to_encodable.{u_1} α _inst_1)
                    (@denumerable.to_encodable.{u_2} β _inst_2))
                 a)
              n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79      encode_sum a = bit (bodd n) (div2 n), {simpa [bit_decomp]},</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='encodable.encode_sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat.bit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.bodd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='nat.div2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='nat.bit_decomp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/encodable.lean&#x27;, &#x27;line&#x27;: 125, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/bitwise.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/bitwise.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/bitwise.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/bitwise.lean&#x27;, &#x27;line&#x27;: 90, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : encodable.{u_1} α] [_inst_2 : encodable.{u_2} β], sum.{u_1 u_2} α β → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='bool → nat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (n : nat), @eq.{1} nat (nat.bit (nat.bodd n) (nat.div2 n)) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : denumerable.{u_1} α,
_inst_2 : denumerable.{u_2} β,
n : nat
⊢ @Exists.{(max u_1 u_2)+1} (sum.{u_1 u_2} α β)
    (λ (a : sum.{u_1 u_2} α β),
       @Exists.{0}
         (@has_mem.mem.{(max u_1 u_2) (max u_1 u_2)} (sum.{u_1 u_2} α β)
            (option.{(max u_1 u_2)} (sum.{u_1 u_2} α β))
            (@option.has_mem.{(max u_1 u_2)} (sum.{u_1 u_2} α β))
            a
            (@encodable.decode.{(max u_1 u_2)} (sum.{u_1 u_2} α β)
               (@encodable.sum.{u_1 u_2} α β (@denumerable.to_encodable.{u_1} α _inst_1)
                  (@denumerable.to_encodable.{u_2} β _inst_2))
               n))
         (λ
          (H :
            @has_mem.mem.{(max u_1 u_2) (max u_1 u_2)} (sum.{u_1 u_2} α β)
              (option.{(max u_1 u_2)} (sum.{u_1 u_2} α β))
              (@option.has_mem.{(max u_1 u_2)} (sum.{u_1 u_2} α β))
              a
              (@encodable.decode.{(max u_1 u_2)} (sum.{u_1 u_2} α β)
                 (@encodable.sum.{u_1 u_2} α β (@denumerable.to_encodable.{u_1} α _inst_1)
                    (@denumerable.to_encodable.{u_2} β _inst_2))
                 n)),
            @eq.{1} nat
              (@encodable.encode.{(max u_1 u_2)} (sum.{u_1 u_2} α β)
                 (@encodable.sum.{u_1 u_2} α β (@denumerable.to_encodable.{u_1} α _inst_1)
                    (@denumerable.to_encodable.{u_2} β _inst_2))
                 a)
              n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
_inst_1 : denumerable.{u_1} α,
_inst_2 : denumerable.{u_2} β,
n : nat,
this :
  @Exists.{(max u_1 u_2)+1} (sum.{u_1 u_2} α β)
    (λ (a : sum.{u_1 u_2} α β),
       @Exists.{0}
         (@has_mem.mem.{(max u_1 u_2) (max u_1 u_2)} (sum.{u_1 u_2} α β)
            (option.{(max u_1 u_2)} (sum.{u_1 u_2} α β))
            (@option.has_mem.{(max u_1 u_2)} (sum.{u_1 u_2} α β))
            a
            (@encodable.decode_sum.{u_1 u_2} α β (@denumerable.to_encodable.{u_1} α _inst_1)
               (@denumerable.to_encodable.{u_2} β _inst_2)
               n))
         (λ
          (H :
            @has_mem.mem.{(max u_1 u_2) (max u_1 u_2)} (sum.{u_1 u_2} α β)
              (option.{(max u_1 u_2)} (sum.{u_1 u_2} α β))
              (@option.has_mem.{(max u_1 u_2)} (sum.{u_1 u_2} α β))
              a
              (@encodable.decode_sum.{u_1 u_2} α β (@denumerable.to_encodable.{u_1} α _inst_1)
                 (@denumerable.to_encodable.{u_2} β _inst_2)
                 n)),
            @eq.{1} nat
              (@encodable.encode_sum.{u_1 u_2} α β (@denumerable.to_encodable.{u_1} α _inst_1)
                 (@denumerable.to_encodable.{u_2} β _inst_2)
                 a)
              (nat.bit (nat.bodd n) (nat.div2 n))))
⊢ @Exists.{(max u_1 u_2)+1} (sum.{u_1 u_2} α β)
    (λ (a : sum.{u_1 u_2} α β),
       @Exists.{0}
         (@has_mem.mem.{(max u_1 u_2) (max u_1 u_2)} (sum.{u_1 u_2} α β)
            (option.{(max u_1 u_2)} (sum.{u_1 u_2} α β))
            (@option.has_mem.{(max u_1 u_2)} (sum.{u_1 u_2} α β))
            a
            (@encodable.decode.{(max u_1 u_2)} (sum.{u_1 u_2} α β)
               (@encodable.sum.{u_1 u_2} α β (@denumerable.to_encodable.{u_1} α _inst_1)
                  (@denumerable.to_encodable.{u_2} β _inst_2))
               n))
         (λ
          (H :
            @has_mem.mem.{(max u_1 u_2) (max u_1 u_2)} (sum.{u_1 u_2} α β)
              (option.{(max u_1 u_2)} (sum.{u_1 u_2} α β))
              (@option.has_mem.{(max u_1 u_2)} (sum.{u_1 u_2} α β))
              a
              (@encodable.decode.{(max u_1 u_2)} (sum.{u_1 u_2} α β)
                 (@encodable.sum.{u_1 u_2} α β (@denumerable.to_encodable.{u_1} α _inst_1)
                    (@denumerable.to_encodable.{u_2} β _inst_2))
                 n)),
            @eq.{1} nat
              (@encodable.encode.{(max u_1 u_2)} (sum.{u_1 u_2} α β)
                 (@encodable.sum.{u_1 u_2} α β (@denumerable.to_encodable.{u_1} α _inst_1)
                    (@denumerable.to_encodable.{u_2} β _inst_2))
                 a)
              n))

α : Type u_1,
β : Type u_2,
_inst_1 : denumerable.{u_1} α,
_inst_2 : denumerable.{u_2} β,
n : nat
⊢ @Exists.{(max u_1 u_2)+1} (sum.{u_1 u_2} α β)
    (λ (a : sum.{u_1 u_2} α β),
       @Exists.{0}
         (@has_mem.mem.{(max u_1 u_2) (max u_1 u_2)} (sum.{u_1 u_2} α β)
            (option.{(max u_1 u_2)} (sum.{u_1 u_2} α β))
            (@option.has_mem.{(max u_1 u_2)} (sum.{u_1 u_2} α β))
            a
            (@encodable.decode_sum.{u_1 u_2} α β (@denumerable.to_encodable.{u_1} α _inst_1)
               (@denumerable.to_encodable.{u_2} β _inst_2)
               n))
         (λ
          (H :
            @has_mem.mem.{(max u_1 u_2) (max u_1 u_2)} (sum.{u_1 u_2} α β)
              (option.{(max u_1 u_2)} (sum.{u_1 u_2} α β))
              (@option.has_mem.{(max u_1 u_2)} (sum.{u_1 u_2} α β))
              a
              (@encodable.decode_sum.{u_1 u_2} α β (@denumerable.to_encodable.{u_1} α _inst_1)
                 (@denumerable.to_encodable.{u_2} β _inst_2)
                 n)),
            @eq.{1} nat
              (@encodable.encode_sum.{u_1 u_2} α β (@denumerable.to_encodable.{u_1} α _inst_1)
                 (@denumerable.to_encodable.{u_2} β _inst_2)
                 a)
              (nat.bit (nat.bodd n) (nat.div2 n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : denumerable.{u_1} α,
_inst_2 : denumerable.{u_2} β,
n : nat
⊢ @Exists.{(max u_1 u_2)+1} (sum.{u_1 u_2} α β)
    (λ (a : sum.{u_1 u_2} α β),
       @Exists.{0}
         (@has_mem.mem.{(max u_1 u_2) (max u_1 u_2)} (sum.{u_1 u_2} α β)
            (option.{(max u_1 u_2)} (sum.{u_1 u_2} α β))
            (@option.has_mem.{(max u_1 u_2)} (sum.{u_1 u_2} α β))
            a
            (@encodable.decode_sum.{u_1 u_2} α β (@denumerable.to_encodable.{u_1} α _inst_1)
               (@denumerable.to_encodable.{u_2} β _inst_2)
               n))
         (λ
          (H :
            @has_mem.mem.{(max u_1 u_2) (max u_1 u_2)} (sum.{u_1 u_2} α β)
              (option.{(max u_1 u_2)} (sum.{u_1 u_2} α β))
              (@option.has_mem.{(max u_1 u_2)} (sum.{u_1 u_2} α β))
              a
              (@encodable.decode_sum.{u_1 u_2} α β (@denumerable.to_encodable.{u_1} α _inst_1)
                 (@denumerable.to_encodable.{u_2} β _inst_2)
                 n)),
            @eq.{1} nat
              (@encodable.encode_sum.{u_1 u_2} α β (@denumerable.to_encodable.{u_1} α _inst_1)
                 (@denumerable.to_encodable.{u_2} β _inst_2)
                 a)
              (nat.bit (nat.bodd n) (nat.div2 n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80    simp [decode_sum]; cases bodd n; simp [decode_sum, bit, encode_sum]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='encodable.decode_sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='nat.bodd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='encodable.decode_sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.bit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='encodable.encode_sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/encodable.lean&#x27;, &#x27;line&#x27;: 129, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/bitwise.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/encodable.lean&#x27;, &#x27;line&#x27;: 129, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/bitwise.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/encodable.lean&#x27;, &#x27;line&#x27;: 125, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : encodable.{?l_1} α] [_inst_2 : encodable.{?l_2} β], nat → option.{(max ?l_1 ?l_2)} (sum.{?l_1 ?l_2} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : encodable.{?l_1} α] [_inst_2 : encodable.{?l_2} β], nat → option.{(max ?l_1 ?l_2)} (sum.{?l_1 ?l_2} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='bool → nat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : encodable.{?l_1} α] [_inst_2 : encodable.{?l_2} β], sum.{?l_1 ?l_2} α β → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : denumerable.{u_1} α,
_inst_2 : denumerable.{u_2} β,
n : nat
⊢ @Exists.{(max u_1 u_2)+1} (sum.{u_1 u_2} α β)
    (λ (a : sum.{u_1 u_2} α β),
       @Exists.{0}
         (@has_mem.mem.{(max u_1 u_2) (max u_1 u_2)} (sum.{u_1 u_2} α β)
            (option.{(max u_1 u_2)} (sum.{u_1 u_2} α β))
            (@option.has_mem.{(max u_1 u_2)} (sum.{u_1 u_2} α β))
            a
            (@encodable.decode_sum.{u_1 u_2} α β (@denumerable.to_encodable.{u_1} α _inst_1)
               (@denumerable.to_encodable.{u_2} β _inst_2)
               n))
         (λ
          (H :
            @has_mem.mem.{(max u_1 u_2) (max u_1 u_2)} (sum.{u_1 u_2} α β)
              (option.{(max u_1 u_2)} (sum.{u_1 u_2} α β))
              (@option.has_mem.{(max u_1 u_2)} (sum.{u_1 u_2} α β))
              a
              (@encodable.decode_sum.{u_1 u_2} α β (@denumerable.to_encodable.{u_1} α _inst_1)
                 (@denumerable.to_encodable.{u_2} β _inst_2)
                 n)),
            @eq.{1} nat
              (@encodable.encode_sum.{u_1 u_2} α β (@denumerable.to_encodable.{u_1} α _inst_1)
                 (@denumerable.to_encodable.{u_2} β _inst_2)
                 a)
              (nat.bit (nat.bodd n) (nat.div2 n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81  end⟩</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83  section sigma</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84  variables {γ : α → Type*} [∀ a, denumerable (γ a)]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='denumerable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='A denumerable type is one which is (constructively) bijective with ℕ.
 Although we already have a name for this property, namely `α ≃ ℕ`,
 we are here interested in using it as a typeclass.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86  instance sigma : denumerable (sigma γ) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='denumerable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='sigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, (α → Type v) → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='A denumerable type is one which is (constructively) bijective with ℕ.
 Although we already have a name for this property, namely `α ≃ ℕ`,
 we are here interested in using it as a typeclass.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87  ⟨λ n, by simp [decode_sigma]; exact ⟨_, _, ⟨rfl, heq.rfl⟩, by simp⟩⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='encodable.decode_sigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='heq.rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/encodable.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 203, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {γ : α → Type ?l_2} [_inst_1 : encodable.{?l_1} α] [_inst_2 : Π (a : α), encodable.{?l_2} (γ a)], nat → option.{(max ?l_1 ?l_2)} (@sigma.{?l_1 ?l_2} α γ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{u_1+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_3} {a : α}, @heq.{u_3+1} α a α a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='lime'><a title='α : Type u_1,
_inst_1 : denumerable.{u_1} α,
γ : α → Type u_3,
_inst_3 : Π (a : α), denumerable.{u_3} (γ a),
n : nat
⊢ @Exists.{(max u_1 u_3)+1} (@sigma.{u_1 u_3} α γ)
    (λ (a : @sigma.{u_1 u_3} α γ),
       @Exists.{0}
         (@has_mem.mem.{(max u_1 u_3) (max u_1 u_3)} (@sigma.{u_1 u_3} α γ)
            (option.{(max u_1 u_3)} (@sigma.{u_1 u_3} α γ))
            (@option.has_mem.{(max u_1 u_3)} (@sigma.{u_1 u_3} α γ))
            a
            (@encodable.decode.{(max u_1 u_3)} (@sigma.{u_1 u_3} α γ)
               (@encodable.sigma.{u_1 u_3} α γ (@denumerable.to_encodable.{u_1} α _inst_1)
                  (λ (a : α), @denumerable.to_encodable.{u_3} (γ a) (_inst_3 a)))
               n))
         (λ
          (H :
            @has_mem.mem.{(max u_1 u_3) (max u_1 u_3)} (@sigma.{u_1 u_3} α γ)
              (option.{(max u_1 u_3)} (@sigma.{u_1 u_3} α γ))
              (@option.has_mem.{(max u_1 u_3)} (@sigma.{u_1 u_3} α γ))
              a
              (@encodable.decode.{(max u_1 u_3)} (@sigma.{u_1 u_3} α γ)
                 (@encodable.sigma.{u_1 u_3} α γ (@denumerable.to_encodable.{u_1} α _inst_1)
                    (λ (a : α), @denumerable.to_encodable.{u_3} (γ a) (_inst_3 a)))
                 n)),
            @eq.{1} nat
              (@encodable.encode.{(max u_1 u_3)} (@sigma.{u_1 u_3} α γ)
                 (@encodable.sigma.{u_1 u_3} α γ (@denumerable.to_encodable.{u_1} α _inst_1)
                    (λ (a : α), @denumerable.to_encodable.{u_3} (γ a) (_inst_3 a)))
                 a)
              n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : denumerable.{u_1} α,
γ : α → Type u_3,
_inst_3 : Π (a : α), denumerable.{u_3} (γ a),
n : nat
⊢ @eq.{1} nat
    (nat.mkpair
       (@encodable.encode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1)
          (@denumerable.of_nat.{u_1} α _inst_1 (@prod.fst.{0 0} nat nat (nat.unpair n))))
       (@encodable.encode.{u_3} (γ (@denumerable.of_nat.{u_1} α _inst_1 (@prod.fst.{0 0} nat nat (nat.unpair n))))
          (@denumerable.to_encodable.{u_3}
             (γ (@denumerable.of_nat.{u_1} α _inst_1 (@prod.fst.{0 0} nat nat (nat.unpair n))))
             (_inst_3 (@denumerable.of_nat.{u_1} α _inst_1 (@prod.fst.{0 0} nat nat (nat.unpair n)))))
          (@denumerable.of_nat.{u_3}
             (γ (@denumerable.of_nat.{u_1} α _inst_1 (@prod.fst.{0 0} nat nat (nat.unpair n))))
             (_inst_3 (@denumerable.of_nat.{u_1} α _inst_1 (@prod.fst.{0 0} nat nat (nat.unpair n))))
             (@prod.snd.{0 0} nat nat (nat.unpair n)))))
    n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : denumerable.{u_1} α,
γ : α → Type u_3,
_inst_3 : Π (a : α), denumerable.{u_3} (γ a),
n : nat
⊢ @Exists.{(max u_1 u_3)+1} (@sigma.{u_1 u_3} α γ)
    (λ (a : @sigma.{u_1 u_3} α γ),
       @Exists.{0}
         (@has_mem.mem.{(max u_1 u_3) (max u_1 u_3)} (@sigma.{u_1 u_3} α γ)
            (option.{(max u_1 u_3)} (@sigma.{u_1 u_3} α γ))
            (@option.has_mem.{(max u_1 u_3)} (@sigma.{u_1 u_3} α γ))
            a
            (@encodable.decode.{(max u_1 u_3)} (@sigma.{u_1 u_3} α γ)
               (@encodable.sigma.{u_1 u_3} α γ (@denumerable.to_encodable.{u_1} α _inst_1)
                  (λ (a : α), @denumerable.to_encodable.{u_3} (γ a) (_inst_3 a)))
               n))
         (λ
          (H :
            @has_mem.mem.{(max u_1 u_3) (max u_1 u_3)} (@sigma.{u_1 u_3} α γ)
              (option.{(max u_1 u_3)} (@sigma.{u_1 u_3} α γ))
              (@option.has_mem.{(max u_1 u_3)} (@sigma.{u_1 u_3} α γ))
              a
              (@encodable.decode.{(max u_1 u_3)} (@sigma.{u_1 u_3} α γ)
                 (@encodable.sigma.{u_1 u_3} α γ (@denumerable.to_encodable.{u_1} α _inst_1)
                    (λ (a : α), @denumerable.to_encodable.{u_3} (γ a) (_inst_3 a)))
                 n)),
            @eq.{1} nat
              (@encodable.encode.{(max u_1 u_3)} (@sigma.{u_1 u_3} α γ)
                 (@encodable.sigma.{u_1 u_3} α γ (@denumerable.to_encodable.{u_1} α _inst_1)
                    (λ (a : α), @denumerable.to_encodable.{u_3} (γ a) (_inst_3 a)))
                 a)
              n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89  @[simp] theorem sigma_of_nat_val (n : ℕ) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90    of_nat (sigma γ) n = ⟨of_nat α (unpair n).1, of_nat (γ _) (unpair n).2⟩ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='denumerable.of_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='sigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='denumerable.of_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.unpair'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='denumerable.of_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='nat.unpair'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/pairing.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/pairing.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [f : denumerable.{u_1} α], nat → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, (α → Type v) → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u_1 u_3)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [f : denumerable.{u_1} α], nat → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → prod.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type}, prod.{0 0} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) [f : denumerable.{u_1} α], nat → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='nat → prod.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type}, prod.{0 0} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='Unpairing function for the natural numbers.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='Unpairing function for the natural numbers.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91  option.some.inj $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='option.some.inj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (max u_1 u_3)} {val val_1 : α}, @eq.{(max u_1 u_3)+1} (option.{(max u_1 u_3)} α) (@option.some.{(max u_1 u_3)} α val) (@option.some.{(max u_1 u_3)} α val_1) → @eq.{(max u_1 u_3)+1} α val val_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92  by rw [← decode_eq_of_nat, decode_sigma_val]; simp; refl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='denumerable.decode_eq_of_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='encodable.decode_sigma_val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 36, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/encodable.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (α : Type (max u_1 u_3)) [_inst_3 : denumerable.{(max u_1 u_3)} α] (n : nat), @eq.{(max u_1 u_3)+1} (option.{(max u_1 u_3)} α) (@encodable.decode.{(max u_1 u_3)} α (@denumerable.to_encodable.{(max u_1 u_3)} α _inst_3) n) (@option.some.{(max u_1 u_3)} α (@denumerable.of_nat.{(max u_1 u_3)} α _inst_3 n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {γ : α → Type u_3} [_inst_1 : encodable.{u_1} α] [_inst_2 : Π (a : α), encodable.{u_3} (γ a)] (n : nat), @eq.{(max u_1 u_3)+1} (option.{(max u_1 u_3)} (@sigma.{u_1 u_3} α γ)) (@encodable.decode.{(max u_1 u_3)} (@sigma.{u_1 u_3} α γ) (@encodable.sigma.{u_1 u_3} α γ _inst_1 (λ (a : α), _inst_2 a)) n) (@option.bind.{u_1 (max u_1 u_3)} α (@sigma.{u_1 u_3} α γ) (@encodable.decode.{u_1} α _inst_1 (@prod.fst.{0 0} nat nat (nat.unpair n))) (λ (a : α), @option.map.{u_3 (max u_1 u_3)} (γ a) (@sigma.{u_1 u_3} α γ) (@sigma.mk.{u_1 u_3} α γ a) (@encodable.decode.{u_3} (γ a) (_inst_2 a) (@prod.snd.{0 0} nat nat (nat.unpair n)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u_1,
_inst_1 : denumerable.{u_1} α,
γ : α → Type u_3,
_inst_3 : Π (a : α), denumerable.{u_3} (γ a),
n : nat
⊢ @eq.{(max u_1 u_3)+1} (option.{(max u_1 u_3)} (@sigma.{u_1 u_3} α γ))
    (@option.some.{(max u_1 u_3)} (@sigma.{u_1 u_3} α γ)
       (@denumerable.of_nat.{(max u_1 u_3)} (@sigma.{u_1 u_3} α γ)
          (@denumerable.sigma.{u_1 u_3} α _inst_1 γ (λ (a : α), _inst_3 a))
          n))
    (@option.some.{(max u_1 u_3)} (@sigma.{u_1 u_3} α γ)
       (@sigma.mk.{u_1 u_3} α γ (@denumerable.of_nat.{u_1} α _inst_1 (@prod.fst.{0 0} nat nat (nat.unpair n)))
          (@denumerable.of_nat.{u_3}
             (γ (@denumerable.of_nat.{u_1} α _inst_1 (@prod.fst.{0 0} nat nat (nat.unpair n))))
             (_inst_3 (@denumerable.of_nat.{u_1} α _inst_1 (@prod.fst.{0 0} nat nat (nat.unpair n))))
             (@prod.snd.{0 0} nat nat (nat.unpair n)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : denumerable.{u_1} α,
γ : α → Type u_3,
_inst_3 : Π (a : α), denumerable.{u_3} (γ a),
n : nat
⊢ @eq.{(max u_1 u_3)+1} (option.{(max u_1 u_3)} (@sigma.{u_1 u_3} α γ))
    (@encodable.decode.{(max u_1 u_3)} (@sigma.{u_1 u_3} α γ)
       (@denumerable.to_encodable.{(max u_1 u_3)} (@sigma.{u_1 u_3} α γ)
          (@denumerable.sigma.{u_1 u_3} α _inst_1 γ (λ (a : α), _inst_3 a)))
       n)
    (@option.some.{(max u_1 u_3)} (@sigma.{u_1 u_3} α γ)
       (@sigma.mk.{u_1 u_3} α γ (@denumerable.of_nat.{u_1} α _inst_1 (@prod.fst.{0 0} nat nat (nat.unpair n)))
          (@denumerable.of_nat.{u_3}
             (γ (@denumerable.of_nat.{u_1} α _inst_1 (@prod.fst.{0 0} nat nat (nat.unpair n))))
             (_inst_3 (@denumerable.of_nat.{u_1} α _inst_1 (@prod.fst.{0 0} nat nat (nat.unpair n))))
             (@prod.snd.{0 0} nat nat (nat.unpair n)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : denumerable.{u_1} α,
γ : α → Type u_3,
_inst_3 : Π (a : α), denumerable.{u_3} (γ a),
n : nat
⊢ @eq.{(max u_1 u_3)+1} (option.{(max u_1 u_3)} (@sigma.{u_1 u_3} α γ))
    (@option.bind.{u_1 (max u_1 u_3)} α (@sigma.{u_1 u_3} α γ)
       (@encodable.decode.{u_1} α (@denumerable.to_encodable.{u_1} α _inst_1)
          (@prod.fst.{0 0} nat nat (nat.unpair n)))
       (λ (a : α),
          @option.map.{u_3 (max u_1 u_3)} (γ a) (@sigma.{u_1 u_3} α γ) (@sigma.mk.{u_1 u_3} α γ a)
            (@encodable.decode.{u_3} (γ a) (@denumerable.to_encodable.{u_3} (γ a) ((λ (a : α), _inst_3 a) a))
               (@prod.snd.{0 0} nat nat (nat.unpair n)))))
    (@option.some.{(max u_1 u_3)} (@sigma.{u_1 u_3} α γ)
       (@sigma.mk.{u_1 u_3} α γ (@denumerable.of_nat.{u_1} α _inst_1 (@prod.fst.{0 0} nat nat (nat.unpair n)))
          (@denumerable.of_nat.{u_3}
             (γ (@denumerable.of_nat.{u_1} α _inst_1 (@prod.fst.{0 0} nat nat (nat.unpair n))))
             (_inst_3 (@denumerable.of_nat.{u_1} α _inst_1 (@prod.fst.{0 0} nat nat (nat.unpair n))))
             (@prod.snd.{0 0} nat nat (nat.unpair n)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : denumerable.{u_1} α,
γ : α → Type u_3,
_inst_3 : Π (a : α), denumerable.{u_3} (γ a),
n : nat
⊢ @eq.{(max u_1 u_3)+1} (option.{(max u_1 u_3)} (@sigma.{u_1 u_3} α γ))
    (@option.some.{(max u_1 u_3)} (@sigma.{u_1 u_3} α γ)
       (@denumerable.of_nat.{(max u_1 u_3)} (@sigma.{u_1 u_3} α γ)
          (@denumerable.sigma.{u_1 u_3} α _inst_1 γ (λ (a : α), _inst_3 a))
          n))
    (@option.some.{(max u_1 u_3)} (@sigma.{u_1 u_3} α γ)
       (@sigma.mk.{u_1 u_3} α γ (@denumerable.of_nat.{u_1} α _inst_1 (@prod.fst.{0 0} nat nat (nat.unpair n)))
          (@denumerable.of_nat.{u_3}
             (γ (@denumerable.of_nat.{u_1} α _inst_1 (@prod.fst.{0 0} nat nat (nat.unpair n))))
             (_inst_3 (@denumerable.of_nat.{u_1} α _inst_1 (@prod.fst.{0 0} nat nat (nat.unpair n))))
             (@prod.snd.{0 0} nat nat (nat.unpair n)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : denumerable.{u_1} α,
γ : α → Type u_3,
_inst_3 : Π (a : α), denumerable.{u_3} (γ a),
n : nat
⊢ @eq.{(max u_1 u_3)+1} (option.{(max u_1 u_3)} (@sigma.{u_1 u_3} α γ))
    (@option.some.{(max u_1 u_3)} (@sigma.{u_1 u_3} α γ)
       (@denumerable.of_nat.{(max u_1 u_3)} (@sigma.{u_1 u_3} α γ)
          (@denumerable.sigma.{u_1 u_3} α _inst_1 γ (λ (a : α), _inst_3 a))
          n))
    (@option.some.{(max u_1 u_3)} (@sigma.{u_1 u_3} α γ)
       (@sigma.mk.{u_1 u_3} α γ (@denumerable.of_nat.{u_1} α _inst_1 (@prod.fst.{0 0} nat nat (nat.unpair n)))
          (@denumerable.of_nat.{u_3}
             (γ (@denumerable.of_nat.{u_1} α _inst_1 (@prod.fst.{0 0} nat nat (nat.unpair n))))
             (_inst_3 (@denumerable.of_nat.{u_1} α _inst_1 (@prod.fst.{0 0} nat nat (nat.unpair n))))
             (@prod.snd.{0 0} nat nat (nat.unpair n)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94  end sigma</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96  instance prod : denumerable (α × β) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='denumerable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_2 → Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='A denumerable type is one which is (constructively) bijective with ℕ.
 Although we already have a name for this property, namely `α ≃ ℕ`,
 we are here interested in using it as a typeclass.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97  of_equiv _ (equiv.sigma_equiv_prod α β).symm</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='denumerable.of_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='equiv.sigma_equiv_prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 457, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type u_1) {β : Type u_2} [_inst_3 : denumerable.{u_1} α], equiv.{u_2+1 u_1+1} β α → denumerable.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u_1) (β : Type u_2), equiv.{(max (u_1+1) (u_2+1)) (max (u_1+1) (u_2+1))} (@sigma.{u_1 u_2} α (λ (_x : α), β)) (prod.{u_1 u_2} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type (max u_1 u_2)}, equiv.{(max (u_1+1) (u_2+1)) (max (u_1+1) (u_2+1))} α β → equiv.{(max (u_1+1) (u_2+1)) (max (u_1+1) (u_2+1))} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99  @[simp] theorem prod_of_nat_val (n : ℕ) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100    of_nat (α × β) n = (of_nat α (unpair n).1, of_nat β (unpair n).2) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='denumerable.of_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='denumerable.of_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.unpair'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='denumerable.of_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.unpair'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/pairing.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/pairing.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [f : denumerable.{u_1} α], nat → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_2 → Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u_1 u_2)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, α → β → prod.{u_1 u_2} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type u_1) [f : denumerable.{u_1} α], nat → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → prod.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type}, prod.{0 0} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) [f : denumerable.{u_1} α], nat → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → prod.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type}, prod.{0 0} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='Unpairing function for the natural numbers.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='Unpairing function for the natural numbers.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101  by simp; refl</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : denumerable.{u_1} α,
_inst_2 : denumerable.{u_2} β,
n : nat
⊢ @eq.{(max u_1 u_2)+1} (prod.{u_1 u_2} α β)
    (@denumerable.of_nat.{(max u_1 u_2)} (prod.{u_1 u_2} α β) (@denumerable.prod.{u_1 u_2} α β _inst_1 _inst_2) n)
    (@prod.mk.{u_1 u_2} α β (@denumerable.of_nat.{u_1} α _inst_1 (@prod.fst.{0 0} nat nat (nat.unpair n)))
       (@denumerable.of_nat.{u_2} β _inst_2 (@prod.snd.{0 0} nat nat (nat.unpair n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : denumerable.{u_1} α,
_inst_2 : denumerable.{u_2} β,
n : nat
⊢ @eq.{(max u_1 u_2)+1} (prod.{u_1 u_2} α β)
    (@denumerable.of_nat.{(max u_1 u_2)} (prod.{u_1 u_2} α β) (@denumerable.prod.{u_1 u_2} α β _inst_1 _inst_2) n)
    (@prod.mk.{u_1 u_2} α β (@denumerable.of_nat.{u_1} α _inst_1 (@prod.fst.{0 0} nat nat (nat.unpair n)))
       (@denumerable.of_nat.{u_2} β _inst_2 (@prod.snd.{0 0} nat nat (nat.unpair n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103  @[simp] theorem prod_nat_of_nat : of_nat (ℕ × ℕ) = unpair :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='denumerable.of_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat.unpair'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/pairing.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='green'><a title='Π (α : Type u_1) [f : denumerable.{u_1} α], nat → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type → Type → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → prod.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='orange'><a title='Unpairing function for the natural numbers.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104  by funext; simp</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1489, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Apply function extensionality and introduce new hypotheses.
The tactic `funext` will keep applying new the `funext` lemma until the goal target is not reducible to
```lean
  |-  ((fun x, ...) = (fun x, ...))
```
The variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='⊢ @eq.{1} (nat → prod.{0 0} nat nat)
    (@denumerable.of_nat.{0} (prod.{0 0} nat nat) (@denumerable.prod.{0 0} nat nat denumerable.nat denumerable.nat))
    nat.unpair'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @eq.{1} (nat → prod.{0 0} nat nat)
    (@denumerable.of_nat.{0} (prod.{0 0} nat nat) (@denumerable.prod.{0 0} nat nat denumerable.nat denumerable.nat))
    nat.unpair'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106  instance int : denumerable ℤ := denumerable.mk&#x27; equiv.int_equiv_nat</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='denumerable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='denumerable.mk&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.int_equiv_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/nat.lean&#x27;, &#x27;line&#x27;: 29, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1}, equiv.{u_1+1 1} α nat → denumerable.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.{1 1} int nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='A denumerable type is one which is (constructively) bijective with ℕ.
 Although we already have a name for this property, namely `α ≃ ℕ`,
 we are here interested in using it as a typeclass.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108  instance pnat : denumerable ℕ+ := denumerable.mk&#x27; equiv.pnat_equiv_nat</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='denumerable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pnat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='denumerable.mk&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.pnat_equiv_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pnat/basic.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/nat.lean&#x27;, &#x27;line&#x27;: 37, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1}, equiv.{u_1+1 1} α nat → denumerable.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.{1 1} pnat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='A denumerable type is one which is (constructively) bijective with ℕ.
 Although we already have a name for this property, namely `α ≃ ℕ`,
 we are here interested in using it as a typeclass.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`ℕ+` is the type of positive natural numbers. It is defined as a subtype,
 and the VM representation of `ℕ+` is the same as `ℕ` because the proof
 is not stored.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110  instance ulift : denumerable (ulift α) := of_equiv _ equiv.ulift</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='denumerable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ulift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='denumerable.of_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='equiv.ulift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 993, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type s → Type (max s r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u_1) {β : Type u_2} [_inst_3 : denumerable.{u_1} α], equiv.{u_2+1 u_1+1} β α → denumerable.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, equiv.{(max u u_1)+1 u+1} (ulift.{u_1 u} α) α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='A denumerable type is one which is (constructively) bijective with ℕ.
 Although we already have a name for this property, namely `α ≃ ℕ`,
 we are here interested in using it as a typeclass.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Universe lifting operation'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112  instance plift : denumerable (plift α) := of_equiv _ equiv.plift</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='denumerable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='plift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='denumerable.of_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='equiv.plift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 1005, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 220, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Sort u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u_1) {β : Type u_2} [_inst_3 : denumerable.{u_1} α], equiv.{u_2+1 u_1+1} β α → denumerable.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Sort u}, equiv.{u+1 u} (plift.{u} α) α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='A denumerable type is one which is (constructively) bijective with ℕ.
 Although we already have a name for this property, namely `α ≃ ℕ`,
 we are here interested in using it as a typeclass.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Universe lifting operation from Sort to Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114  def pair : α × α ≃ α := equiv₂ _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='denumerable.equiv₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 68, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u_1) (β : Type u_2) [_inst_3 : denumerable.{u_1} α] [_inst_4 : denumerable.{u_2} β], equiv.{u_1+1 u_2+1} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`α ≃ β` is the type of functions from `α → β` with a two-sided inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116  end</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117  end denumerable</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119  namespace nat.subtype</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120  open function encodable lattice</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122  variables {s : set ℕ} [decidable_pred s] [infinite s]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='decidable_pred'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='infinite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 268, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 796, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@has_lt.lt.{0} (@subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)) (@preorder.to_has_lt.{0} (@subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)) (@subtype.preorder.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))) (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) n (@and.right (@has_lt.lt.{0} nat nat.has_lt n (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))) (@lattice.has_bot.bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@lattice.order_bot.to_has_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@lattice.semilattice_sup_bot.to_order_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@lattice.nat.subtype.semilattice_sup_bot s (λ (a : nat), _inst_1 a) (nat.subtype.of_nat._main._proof_1 s _inst_2))))))) (s n) h)) (@lattice.has_bot.bot.{0} (@subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)) (@lattice.order_bot.to_has_bot.{0} (@subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)) (@lattice.semilattice_sup_bot.to_order_bot.{0} (@subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)) (@lattice.nat.subtype.semilattice_sup_bot s (λ (a : nat), _inst_1 a) (@infinite.nonempty.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) _inst_2)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type}, (α → Prop) → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124  lemma exists_succ (x : s) : ∃ n, x.1 + n + 1 ∈ s :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {p : α → Prop}, @subtype.{1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α γ : Type} [c : has_mem.{0 0} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125  classical.by_contradiction $ λ h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='classical.by_contradiction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/classical.lean&#x27;, &#x27;line&#x27;: 160, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {p : Prop}, (not p → false) → p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='not (@Exists.{1} nat (λ (n : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x) n) (@has_one.one.{0} nat nat.has_one)) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126  have ∀ (a : ℕ) (ha : a ∈ s), a &lt; x.val.succ,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='nat.succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type} [c : has_mem.{0 0} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_lt.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {p : α → Prop}, @subtype.{1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127    from λ a ha, lt_of_not_ge (λ hax, h ⟨a - (x.1 + 1),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lt_of_not_ge'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type} [_inst_1 : linear_order.{0} α] {a b : α}, not (@ge.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α _inst_1))) a b) → @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α _inst_1))) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@ge.{0} nat (@preorder.to_has_le.{0} nat (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order))) a (nat.succ (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='not (@Exists.{1} nat (λ (n : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x) n) (@has_one.one.{0} nat nat.has_one)) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {p : α → Prop}, @subtype.{1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128      by rwa [add_right_comm, nat.add_sub_cancel&#x27; hax]⟩),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='add_right_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.add_sub_cancel&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 226, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 178, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : add_comm_semigroup.{0} α] (a b c : α), @eq.{1} α (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_comm_semigroup.to_add_semigroup.{0} α _inst_1)) (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_comm_semigroup.to_add_semigroup.{0} α _inst_1)) a b) c) (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_comm_semigroup.to_add_semigroup.{0} α _inst_1)) (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_comm_semigroup.to_add_semigroup.{0} α _inst_1)) a c) b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n m : nat}, @has_le.le.{0} nat nat.has_le m n → @eq.{1} nat (@has_add.add.{0} nat nat.has_add m (@has_sub.sub.{0} nat nat.has_sub n m)) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ge.{0} nat (@preorder.to_has_le.{0} nat (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order))) a (nat.succ (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
x : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s,
h :
  not
    (@Exists.{1} nat
       (λ (n : nat),
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat)
            (@has_add.add.{0} nat nat.has_add
               (@has_add.add.{0} nat nat.has_add
                  (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                     x)
                  n)
               (@has_one.one.{0} nat nat.has_one))
            s)),
a : nat,
ha : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s,
hax :
  @ge.{0} nat
    (@preorder.to_has_le.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    a
    (nat.succ (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x))
⊢ @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat)
    (@has_add.add.{0} nat nat.has_add
       (@has_add.add.{0} nat nat.has_add
          (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x)
          (@has_sub.sub.{0} nat nat.has_sub a
             (@has_add.add.{0} nat nat.has_add
                (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x)
                (@has_one.one.{0} nat nat.has_one))))
       (@has_one.one.{0} nat nat.has_one))
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
x : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s,
h :
  not
    (@Exists.{1} nat
       (λ (n : nat),
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat)
            (@has_add.add.{0} nat nat.has_add
               (@has_add.add.{0} nat nat.has_add
                  (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                     x)
                  n)
               (@has_one.one.{0} nat nat.has_one))
            s)),
a : nat,
ha : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s,
hax :
  @ge.{0} nat
    (@preorder.to_has_le.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    a
    (nat.succ (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x))
⊢ @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat)
    (@has_add.add.{0} nat
       (@add_semigroup.to_has_add.{0} nat (@add_comm_semigroup.to_add_semigroup.{0} nat nat.add_comm_semigroup))
       (@has_add.add.{0} nat
          (@add_semigroup.to_has_add.{0} nat (@add_comm_semigroup.to_add_semigroup.{0} nat nat.add_comm_semigroup))
          (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x)
          (@has_one.one.{0} nat nat.has_one))
       (@has_sub.sub.{0} nat nat.has_sub a
          (@has_add.add.{0} nat nat.has_add
             (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x)
             (@has_one.one.{0} nat nat.has_one))))
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
x : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s,
h :
  not
    (@Exists.{1} nat
       (λ (n : nat),
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat)
            (@has_add.add.{0} nat nat.has_add
               (@has_add.add.{0} nat nat.has_add
                  (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                     x)
                  n)
               (@has_one.one.{0} nat nat.has_one))
            s)),
a : nat,
ha : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s,
hax :
  @ge.{0} nat
    (@preorder.to_has_le.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    a
    (nat.succ (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x))
⊢ @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129  infinite.not_fintype</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='infinite.not_fintype'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 796, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [c : infinite.{0} α], fintype.{0} α → false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130    ⟨(((multiset.range x.1.succ).filter (∈ s)).pmap</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='multiset.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat.succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='multiset.filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='multiset.pmap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/multiset.lean&#x27;, &#x27;line&#x27;: 494, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/multiset.lean&#x27;, &#x27;line&#x27;: 1349, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/multiset.lean&#x27;, &#x27;line&#x27;: 997, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='nat → multiset.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {p : α → Prop}, @subtype.{1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} (p : α → Prop) [h : @decidable_pred.{1} α p], multiset.{0} α → multiset.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type} {p : α → Prop}, (Π (a : α), p a → β) → Π (s : multiset.{0} α), (∀ (a : α), @has_mem.mem.{0 0} α (multiset.{0} α) (@multiset.has_mem.{0} α) a s → p a) → multiset.{0} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`range n` is the multiset lifted from the list `range n`,
 that is, the set `{0, 1, ..., n-1}`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`filter p s` returns the elements in `s` (with the same multiplicities)
 which satisfy `p`, and removes the rest.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Lift of the list `pmap` operation. Map a partial function `f` over a multiset
 `s` whose elements are all in the domain of `f`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131        (λ (y : ℕ) (hy : y ∈ s), subtype.mk y hy)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='subtype.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type} [c : has_mem.{0 0} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type} {p : α → Prop} (val : α), p val → @subtype.{1} α p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132        (by simp [-multiset.range_succ])).to_finset,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='multiset.to_finset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 914, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [_inst_1 : decidable_eq.{1} α], multiset.{0} α → finset.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`to_finset s` removes duplicates from the multiset `s` to produce a finset.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
x : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s,
h :
  not
    (@Exists.{1} nat
       (λ (n : nat),
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat)
            (@has_add.add.{0} nat nat.has_add
               (@has_add.add.{0} nat nat.has_add
                  (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                     x)
                  n)
               (@has_one.one.{0} nat nat.has_one))
            s)),
this :
  ∀ (a : nat),
    @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
    @has_lt.lt.{0} nat nat.has_lt a
      (nat.succ
         (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x))
⊢ ∀ (a : nat),
    @has_mem.mem.{0 0} nat (multiset.{0} nat) (@multiset.has_mem.{0} nat) a
      (@multiset.filter.{0} nat (λ (_x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) _x s)
         (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
         (multiset.range
            (nat.succ
               (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                  x)))) →
    @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133      by simpa [subtype.ext, multiset.mem_filter, -multiset.range_succ]⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='subtype.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='multiset.mem_filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/subtype.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/multiset.lean&#x27;, &#x27;line&#x27;: 1378, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Sort ?l_1} {p : α → Prop} {a1 a2 : @subtype.{?l_1} α (λ (x : α), p x)}, iff (@eq.{(max 1 ?l_1)} (@subtype.{?l_1} α (λ (x : α), p x)) a1 a2) (@eq.{?l_1} α (@subtype.val.{?l_1} α (λ (x : α), p x) a1) (@subtype.val.{?l_1} α (λ (x : α), p x) a2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {p : α → Prop} [_inst_1 : @decidable_pred.{?l_1+1} α p] {a : α} {s : multiset.{?l_1} α}, iff (@has_mem.mem.{?l_1 ?l_1} α (multiset.{?l_1} α) (@multiset.has_mem.{?l_1} α) a (@multiset.filter.{?l_1} α p (λ (a : α), _inst_1 a) s)) (and (@has_mem.mem.{?l_1 ?l_1} α (multiset.{?l_1} α) (@multiset.has_mem.{?l_1} α) a s) (p a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
x : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s,
h :
  not
    (@Exists.{1} nat
       (λ (n : nat),
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat)
            (@has_add.add.{0} nat nat.has_add
               (@has_add.add.{0} nat nat.has_add
                  (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                     x)
                  n)
               (@has_one.one.{0} nat nat.has_one))
            s)),
this :
  ∀ (a : nat),
    @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
    @has_lt.lt.{0} nat nat.has_lt a
      (nat.succ
         (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x))
⊢ ∀ (x_1 : @subtype.{1} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)),
    @has_mem.mem.{0 0}
      (@subtype.{1} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s))
      (finset.{0} (@subtype.{1} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)))
      (@finset.has_mem.{0}
         (@subtype.{1} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)))
      x_1
      (@multiset.to_finset.{0}
         (@subtype.{1} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s))
         (λ (a b : @subtype.{1} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)),
            @subtype.decidable_eq.{0} nat
              (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
              (λ (a b : nat), nat.decidable_eq a b)
              a
              b)
         (@multiset.pmap.{0 0} nat
            (@subtype.{1} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s))
            (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
            (λ (y : nat) (hy : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s),
               @subtype.mk.{1} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s) y hy)
            (@multiset.filter.{0} nat (λ (_x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) _x s)
               (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
               (multiset.range
                  (nat.succ
                     (@subtype.val.{1} nat
                        (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                        x))))
            (@eq.mpr.{0}
               (∀ (a : nat),
                  @has_mem.mem.{0 0} nat (multiset.{0} nat) (@multiset.has_mem.{0} nat) a
                    (@multiset.filter.{0} nat
                       (λ (_x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) _x s)
                       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                       (multiset.range
                          (nat.succ
                             (@subtype.val.{1} nat
                                (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                                x)))) →
                  @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
               true
               (@id.{0}
                  (@eq.{1} Prop
                     (∀ (a : nat),
                        @has_mem.mem.{0 0} nat (multiset.{0} nat) (@multiset.has_mem.{0} nat) a
                          (@multiset.filter.{0} nat
                             (λ (_x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) _x s)
                             (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                             (multiset.range
                                (nat.succ
                                   (@subtype.val.{1} nat
                                      (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                                      x)))) →
                        @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                     true)
                  (@eq.trans.{1} Prop
                     (∀ (x_1 : nat),
                        (λ (a : nat),
                           @has_mem.mem.{0 0} nat (multiset.{0} nat) (@multiset.has_mem.{0} nat) a
                             (@multiset.filter.{0} nat
                                (λ (_x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) _x s)
                                (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                (multiset.range
                                   (nat.succ
                                      (@subtype.val.{1} nat
                                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                                         x)))) →
                           @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                          x_1)
                     (∀ (x : nat), (λ (a : nat), true) x)
                     true
                     (@forall_congr_eq.{1} nat
                        (λ (a : nat),
                           @has_mem.mem.{0 0} nat (multiset.{0} nat) (@multiset.has_mem.{0} nat) a
                             (@multiset.filter.{0} nat
                                (λ (_x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) _x s)
                                (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                (multiset.range
                                   (nat.succ
                                      (@subtype.val.{1} nat
                                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                                         x)))) →
                           @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (λ (a : nat), true)
                        (λ (a : nat),
                           @eq.trans.{1} Prop
                             (@has_mem.mem.{0 0} nat (multiset.{0} nat) (@multiset.has_mem.{0} nat) a
                                (@multiset.filter.{0} nat
                                   (λ (_x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) _x s)
                                   (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                   (multiset.range
                                      (nat.succ
                                         (@subtype.val.{1} nat
                                            (λ (x : nat),
                                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                                            x)))) →
                              @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                             (@has_lt.lt.{0} nat nat.has_lt a
                                (nat.succ
                                   (@subtype.val.{1} nat
                                      (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                                      x)) →
                              true)
                             true
                             (@eq.trans.{1} Prop
                                (@has_mem.mem.{0 0} nat (multiset.{0} nat) (@multiset.has_mem.{0} nat) a
                                   (@multiset.filter.{0} nat
                                      (λ (_x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) _x s)
                                      (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                      (multiset.range
                                         (nat.succ
                                            (@subtype.val.{1} nat
                                               (λ (x : nat),
                                                  @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                                               x)))) →
                                 @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                (@has_lt.lt.{0} nat nat.has_lt a
                                   (nat.succ
                                      (@subtype.val.{1} nat
                                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                                         x)) →
                                 @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                                 @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                (@has_lt.lt.{0} nat nat.has_lt a
                                   (nat.succ
                                      (@subtype.val.{1} nat
                                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                                         x)) →
                                 true)
                                (@eq.trans.{1} Prop
                                   (@has_mem.mem.{0 0} nat (multiset.{0} nat) (@multiset.has_mem.{0} nat) a
                                      (@multiset.filter.{0} nat
                                         (λ (_x : nat),
                                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) _x s)
                                         (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                         (multiset.range
                                            (nat.succ
                                               (@subtype.val.{1} nat
                                                  (λ (x : nat),
                                                     @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                                                  x)))) →
                                    @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                   (and
                                      (@has_lt.lt.{0} nat nat.has_lt a
                                         (nat.succ
                                            (@subtype.val.{1} nat
                                               (λ (x : nat),
                                                  @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                                               x)))
                                      (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                                    @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                   (@has_lt.lt.{0} nat nat.has_lt a
                                      (nat.succ
                                         (@subtype.val.{1} nat
                                            (λ (x : nat),
                                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                                            x)) →
                                    @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                                    @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                   (@imp_congr_eq
                                      (@has_mem.mem.{0 0} nat (multiset.{0} nat) (@multiset.has_mem.{0} nat) a
                                         (@multiset.filter.{0} nat
                                            (λ (_x : nat),
                                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) _x s)
                                            (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                            (multiset.range
                                               (nat.succ
                                                  (@subtype.val.{1} nat
                                                     (λ (x : nat),
                                                        @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                                                     x)))))
                                      (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                      (and
                                         (@has_lt.lt.{0} nat nat.has_lt a
                                            (nat.succ
                                               (@subtype.val.{1} nat
                                                  (λ (x : nat),
                                                     @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                                                  x)))
                                         (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                                      (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                      (@eq.trans.{1} Prop
                                         (@has_mem.mem.{0 0} nat (multiset.{0} nat) (@multiset.has_mem.{0} nat) a
                                            (@multiset.filter.{0} nat
                                               (λ (_x : nat),
                                                  @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) _x s)
                                               (λ (a : nat),
                                                  (λ (a : nat),
                                                     @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                                    a)
                                               (multiset.range
                                                  (nat.succ
                                                     (@subtype.val.{1} nat
                                                        (λ (x : nat),
                                                           @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                                                             s)
                                                        x)))))
                                         (and
                                            (@has_mem.mem.{0 0} nat (multiset.{0} nat) (@multiset.has_mem.{0} nat) a
                                               (multiset.range
                                                  (nat.succ
                                                     (@subtype.val.{1} nat
                                                        (λ (x : nat),
                                                           @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                                                             s)
                                                        x))))
                                            ((λ (_x : nat),
                                                @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) _x s)
                                               a))
                                         (and
                                            (@has_lt.lt.{0} nat nat.has_lt a
                                               (nat.succ
                                                  (@subtype.val.{1} nat
                                                     (λ (x : nat),
                                                        @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                                                     x)))
                                            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                                         (@propext
                                            (@has_mem.mem.{0 0} nat (multiset.{0} nat) (@multiset.has_mem.{0} nat) a
                                               (@multiset.filter.{0} nat
                                                  (λ (_x : nat),
                                                     @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) _x s)
                                                  (λ (a : nat),
                                                     (λ (a : nat),
                                                        @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                                       a)
                                                  (multiset.range
                                                     (nat.succ
                                                        (@subtype.val.{1} nat
                                                           (λ (x : nat),
                                                              @has_mem.mem.{0 0} nat (set.{0} nat)
                                                                (@set.has_mem.{0} nat)
                                                                x
                                                                s)
                                                           x)))))
                                            (and
                                               (@has_mem.mem.{0 0} nat (multiset.{0} nat) (@multiset.has_mem.{0} nat) a
                                                  (multiset.range
                                                     (nat.succ
                                                        (@subtype.val.{1} nat
                                                           (λ (x : nat),
                                                              @has_mem.mem.{0 0} nat (set.{0} nat)
                                                                (@set.has_mem.{0} nat)
                                                                x
                                                                s)
                                                           x))))
                                               ((λ (_x : nat),
                                                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) _x s)
                                                  a))
                                            (@multiset.mem_filter.{0} nat
                                               (λ (_x : nat),
                                                  @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) _x s)
                                               (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                               a
                                               (multiset.range
                                                  (nat.succ
                                                     (@subtype.val.{1} nat
                                                        (λ (x : nat),
                                                           @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                                                             s)
                                                        x)))))
                                         ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                           (e_2 : @eq.{1} Prop b b_1),
                                             @congr.{1 1} Prop Prop (and a) (and a_1) b b_1
                                               (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 and e_1)
                                               e_2)
                                            (@has_mem.mem.{0 0} nat (multiset.{0} nat) (@multiset.has_mem.{0} nat) a
                                               (multiset.range
                                                  (nat.succ
                                                     (@subtype.val.{1} nat
                                                        (λ (x : nat),
                                                           @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                                                             s)
                                                        x))))
                                            (@has_lt.lt.{0} nat nat.has_lt a
                                               (nat.succ
                                                  (@subtype.val.{1} nat
                                                     (λ (x : nat),
                                                        @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                                                     x)))
                                            (@propext
                                               (@has_mem.mem.{0 0} nat (multiset.{0} nat) (@multiset.has_mem.{0} nat) a
                                                  (multiset.range
                                                     (nat.succ
                                                        (@subtype.val.{1} nat
                                                           (λ (x : nat),
                                                              @has_mem.mem.{0 0} nat (set.{0} nat)
                                                                (@set.has_mem.{0} nat)
                                                                x
                                                                s)
                                                           x))))
                                               (@has_lt.lt.{0} nat nat.has_lt a
                                                  (nat.succ
                                                     (@subtype.val.{1} nat
                                                        (λ (x : nat),
                                                           @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                                                             s)
                                                        x)))
                                               (@multiset.mem_range a
                                                  (nat.succ
                                                     (@subtype.val.{1} nat
                                                        (λ (x : nat),
                                                           @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                                                             s)
                                                        x))))
                                            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                            (@eq.refl.{1} Prop
                                               (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                                      (@eq.refl.{1} Prop
                                         (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))
                                   (@propext
                                      (and
                                         (@has_lt.lt.{0} nat nat.has_lt a
                                            (nat.succ
                                               (@subtype.val.{1} nat
                                                  (λ (x : nat),
                                                     @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                                                  x)))
                                         (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                                       @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                      (@has_lt.lt.{0} nat nat.has_lt a
                                         (nat.succ
                                            (@subtype.val.{1} nat
                                               (λ (x : nat),
                                                  @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                                               x)) →
                                       @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                                       @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                      (@and_imp
                                         (@has_lt.lt.{0} nat nat.has_lt a
                                            (nat.succ
                                               (@subtype.val.{1} nat
                                                  (λ (x : nat),
                                                     @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                                                  x)))
                                         (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                         (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                                (@imp_congr_eq
                                   (@has_lt.lt.{0} nat nat.has_lt a
                                      (nat.succ
                                         (@subtype.val.{1} nat
                                            (λ (x : nat),
                                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                                            x)))
                                   (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                                    @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                   (@has_lt.lt.{0} nat nat.has_lt a
                                      (nat.succ
                                         (@subtype.val.{1} nat
                                            (λ (x : nat),
                                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                                            x)))
                                   true
                                   (@eq.refl.{1} Prop
                                      (@has_lt.lt.{0} nat nat.has_lt a
                                         (nat.succ
                                            (@subtype.val.{1} nat
                                               (λ (x : nat),
                                                  @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                                               x))))
                                   (@propext
                                      (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                                       @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                      true
                                      (@imp_self (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))))
                             (@propext
                                (@has_lt.lt.{0} nat nat.has_lt a
                                   (nat.succ
                                      (@subtype.val.{1} nat
                                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                                         x)) →
                                 true)
                                true
                                (@forall_true_iff.{0}
                                   (@has_lt.lt.{0} nat nat.has_lt a
                                      (nat.succ
                                         (@subtype.val.{1} nat
                                            (λ (x : nat),
                                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                                            x)))))))
                     (@propext (nat → true) true (@forall_const.{1} true nat nat.inhabited))))
               trivial)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135  def succ (x : s) : s :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136  have h : ∃ m, x.1 + m + 1 ∈ s, from exists_succ x,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='nat.subtype.exists_succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 124, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {p : α → Prop}, @subtype.{1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α γ : Type} [c : has_mem.{0 0} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {s : set.{0} nat} [_inst_1 : @decidable_pred.{1} nat s] [_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)] (x : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s), @Exists.{1} nat (λ (n : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x) n) (@has_one.one.{0} nat nat.has_one)) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137  ⟨x.1 + nat.find h + 1, nat.find_spec h⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat.find'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='nat.find_spec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/lemmas.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/lemmas.lean&#x27;, &#x27;line&#x27;: 1029, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {p : α → Prop}, @subtype.{1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {p : nat → Prop} [_inst_1 : @decidable_pred.{1} nat p], @Exists.{1} nat (λ (n : nat), p n) → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@Exists.{1} nat (λ (m : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x) m) (@has_one.one.{0} nat nat.has_one)) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {p : nat → Prop} [_inst_1 : @decidable_pred.{1} nat p] (H : @Exists.{1} nat (λ (n : nat), p n)), p (@nat.find p _inst_1 H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@Exists.{1} nat (λ (m : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x) m) (@has_one.one.{0} nat nat.has_one)) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139  lemma succ_le_of_lt {x y : s} (h : y &lt; x) : succ y ≤ x :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='nat.subtype.succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 135, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_lt.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {s : set.{0} nat} [_inst_1 : @decidable_pred.{1} nat s] [_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)], @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s → @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140  have hx : ∃ m, y.1 + m + 1 ∈ s, from exists_succ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='nat.subtype.exists_succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 124, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {p : α → Prop}, @subtype.{1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α γ : Type} [c : has_mem.{0 0} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {s : set.{0} nat} [_inst_1 : @decidable_pred.{1} nat s] [_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)] (x : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s), @Exists.{1} nat (λ (n : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x) n) (@has_one.one.{0} nat nat.has_one)) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141  let ⟨k, hk⟩ := nat.exists_eq_add_of_lt h in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='nat.exists_eq_add_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 1317, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{1} nat (λ (k : nat), @eq.{1} nat (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x) (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y) k) (@has_one.one.{0} nat nat.has_one))) → @has_le.le.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@preorder.to_has_le.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@subtype.preorder.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))) (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2 y) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@eq.{1} nat (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x) (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y) k) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {m n : nat}, @has_lt.lt.{0} nat nat.has_lt m n → @Exists.{1} nat (λ (k : nat), @eq.{1} nat n (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add m k) (@has_one.one.{0} nat nat.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@subtype.preorder.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))) y x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142  have nat.find hx ≤ k, from nat.find_min&#x27; _ (hk ▸ x.2),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='nat.find'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='nat.find_min&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.property'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/lemmas.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/lemmas.lean&#x27;, &#x27;line&#x27;: 1033, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {p : nat → Prop} [_inst_1 : @decidable_pred.{1} nat p], @Exists.{1} nat (λ (n : nat), p n) → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@Exists.{1} nat (λ (m : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y) m) (@has_one.one.{0} nat nat.has_one)) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {p : nat → Prop} [_inst_1 : @decidable_pred.{1} nat p] (H : @Exists.{1} nat (λ (n : nat), p n)) {m : nat}, p m → @has_le.le.{0} nat nat.has_le (@nat.find p _inst_1 H) m'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {α : Type} {P : α → Prop} {a b : α}, @eq.{1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {p : α → Prop} (c : @subtype.{1} α p), p (@subtype.val.{1} α p c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143  show y.1 + nat.find hx + 1 ≤ x.1,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat.find'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/lemmas.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {p : α → Prop}, @subtype.{1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {p : nat → Prop} [_inst_1 : @decidable_pred.{1} nat p], @Exists.{1} nat (λ (n : nat), p n) → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@Exists.{1} nat (λ (m : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y) m) (@has_one.one.{0} nat nat.has_one)) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {p : α → Prop}, @subtype.{1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144  by rw hk; exact add_le_add_right (add_le_add_left this _) _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='hk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='add_le_add_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='add_le_add_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ordered_group.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ordered_group.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} nat (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x) (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y) k) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : ordered_cancel_comm_monoid.{0} α] {a b : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_cancel_comm_monoid.to_partial_order.{0} α _inst_1))) a b → ∀ (c : α), @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_cancel_comm_monoid.to_partial_order.{0} α _inst_1))) (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α (@add_comm_monoid.to_add_monoid.{0} α (@ordered_cancel_comm_monoid.to_add_comm_monoid.{0} α _inst_1)))) a c) (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α (@add_comm_monoid.to_add_monoid.{0} α (@ordered_cancel_comm_monoid.to_add_comm_monoid.{0} α _inst_1)))) b c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [s : ordered_cancel_comm_monoid.{0} α] {a b : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_cancel_comm_monoid.to_partial_order.{0} α s))) a b → ∀ (c : α), @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_cancel_comm_monoid.to_partial_order.{0} α s))) (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α (@add_comm_monoid.to_add_monoid.{0} α (@ordered_cancel_comm_monoid.to_add_comm_monoid.{0} α s)))) c a) (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α (@add_comm_monoid.to_add_monoid.{0} α (@ordered_cancel_comm_monoid.to_add_comm_monoid.{0} α s)))) c b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{0} nat nat.has_le (@nat.find (λ (m : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y) m) (@has_one.one.{0} nat nat.has_one)) s) (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y) a) (@has_one.one.{0} nat nat.has_one))) hx) k'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
x y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s,
h :
  @has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@subtype.preorder.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
          (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
    y
    x,
hx :
  @Exists.{1} nat
    (λ (m : nat),
       @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat)
         (@has_add.add.{0} nat nat.has_add
            (@has_add.add.{0} nat nat.has_add
               (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y)
               m)
            (@has_one.one.{0} nat nat.has_one))
         s),
_let_match :
  @Exists.{1} nat
    (λ (k : nat),
       @eq.{1} nat
         (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x)
         (@has_add.add.{0} nat nat.has_add
            (@has_add.add.{0} nat nat.has_add
               (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y)
               k)
            (@has_one.one.{0} nat nat.has_one))) →
  @has_le.le.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (@preorder.to_has_le.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@subtype.preorder.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
          (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
    (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2 y)
    x,
k : nat,
hk :
  @eq.{1} nat (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x)
    (@has_add.add.{0} nat nat.has_add
       (@has_add.add.{0} nat nat.has_add
          (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y)
          k)
       (@has_one.one.{0} nat nat.has_one)),
this :
  @has_le.le.{0} nat nat.has_le
    (@nat.find
       (λ (m : nat),
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat)
            (@has_add.add.{0} nat nat.has_add
               (@has_add.add.{0} nat nat.has_add
                  (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                     y)
                  m)
               (@has_one.one.{0} nat nat.has_one))
            s)
       (λ (a : nat),
          @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a)
            (@has_add.add.{0} nat nat.has_add
               (@has_add.add.{0} nat nat.has_add
                  (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                     y)
                  a)
               (@has_one.one.{0} nat nat.has_one)))
       hx)
    k
⊢ @has_le.le.{0} nat nat.has_le
    (@has_add.add.{0} nat nat.has_add
       (@has_add.add.{0} nat nat.has_add
          (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y)
          (@nat.find
             (λ (m : nat),
                @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat)
                  (@has_add.add.{0} nat nat.has_add
                     (@has_add.add.{0} nat nat.has_add
                        (@subtype.val.{1} nat
                           (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                           y)
                        m)
                     (@has_one.one.{0} nat nat.has_one))
                  s)
             (λ (a : nat),
                @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a)
                  (@has_add.add.{0} nat nat.has_add
                     (@has_add.add.{0} nat nat.has_add
                        (@subtype.val.{1} nat
                           (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                           y)
                        a)
                     (@has_one.one.{0} nat nat.has_one)))
             hx))
       (@has_one.one.{0} nat nat.has_one))
    (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
x y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s,
h :
  @has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@subtype.preorder.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
          (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
    y
    x,
hx :
  @Exists.{1} nat
    (λ (m : nat),
       @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat)
         (@has_add.add.{0} nat nat.has_add
            (@has_add.add.{0} nat nat.has_add
               (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y)
               m)
            (@has_one.one.{0} nat nat.has_one))
         s),
_let_match :
  @Exists.{1} nat
    (λ (k : nat),
       @eq.{1} nat
         (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x)
         (@has_add.add.{0} nat nat.has_add
            (@has_add.add.{0} nat nat.has_add
               (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y)
               k)
            (@has_one.one.{0} nat nat.has_one))) →
  @has_le.le.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (@preorder.to_has_le.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@subtype.preorder.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
          (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
    (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2 y)
    x,
k : nat,
hk :
  @eq.{1} nat (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x)
    (@has_add.add.{0} nat nat.has_add
       (@has_add.add.{0} nat nat.has_add
          (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y)
          k)
       (@has_one.one.{0} nat nat.has_one)),
this :
  @has_le.le.{0} nat nat.has_le
    (@nat.find
       (λ (m : nat),
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat)
            (@has_add.add.{0} nat nat.has_add
               (@has_add.add.{0} nat nat.has_add
                  (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                     y)
                  m)
               (@has_one.one.{0} nat nat.has_one))
            s)
       (λ (a : nat),
          @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a)
            (@has_add.add.{0} nat nat.has_add
               (@has_add.add.{0} nat nat.has_add
                  (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                     y)
                  a)
               (@has_one.one.{0} nat nat.has_one)))
       hx)
    k
⊢ @has_le.le.{0} nat nat.has_le
    (@has_add.add.{0} nat nat.has_add
       (@has_add.add.{0} nat nat.has_add
          (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y)
          (@nat.find
             (λ (m : nat),
                @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat)
                  (@has_add.add.{0} nat nat.has_add
                     (@has_add.add.{0} nat nat.has_add
                        (@subtype.val.{1} nat
                           (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                           y)
                        m)
                     (@has_one.one.{0} nat nat.has_one))
                  s)
             (λ (a : nat),
                @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a)
                  (@has_add.add.{0} nat nat.has_add
                     (@has_add.add.{0} nat nat.has_add
                        (@subtype.val.{1} nat
                           (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
                           y)
                        a)
                     (@has_one.one.{0} nat nat.has_one)))
             hx))
       (@has_one.one.{0} nat nat.has_one))
    (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146  lemma le_succ_of_forall_lt_le {x y : s} (h : ∀ z &lt; x, z ≤ y) : x ≤ succ y :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat.subtype.succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 135, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {s : set.{0} nat} [_inst_1 : @decidable_pred.{1} nat s] [_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)], @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s → @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147  have hx : ∃ m, y.1 + m + 1 ∈ s, from exists_succ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='nat.subtype.exists_succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 124, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {p : α → Prop}, @subtype.{1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α γ : Type} [c : has_mem.{0 0} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {s : set.{0} nat} [_inst_1 : @decidable_pred.{1} nat s] [_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)] (x : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s), @Exists.{1} nat (λ (n : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x) n) (@has_one.one.{0} nat nat.has_one)) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148  show x.1 ≤ y.1 + nat.find hx + 1,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat.find'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/lemmas.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {p : α → Prop}, @subtype.{1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {p : α → Prop}, @subtype.{1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {p : nat → Prop} [_inst_1 : @decidable_pred.{1} nat p], @Exists.{1} nat (λ (n : nat), p n) → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@Exists.{1} nat (λ (m : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y) m) (@has_one.one.{0} nat nat.has_one)) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149  from le_of_not_gt $ λ hxy,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='le_of_not_gt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='hxy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type} [_inst_1 : linear_order.{0} α] {a b : α}, not (@gt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α _inst_1))) a b) → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α _inst_1))) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@gt.{0} nat (@preorder.to_has_lt.{0} nat (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order))) (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x) (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y) (@nat.find (λ (m : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y) m) (@has_one.one.{0} nat nat.has_one)) s) (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y) a) (@has_one.one.{0} nat nat.has_one))) hx)) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150  have y.1 + nat.find hx + 1 ≤ y.1 := h ⟨_, nat.find_spec hx⟩ hxy,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat.find'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='nat.find_spec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hxy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/lemmas.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/lemmas.lean&#x27;, &#x27;line&#x27;: 1029, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {p : α → Prop}, @subtype.{1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {p : nat → Prop} [_inst_1 : @decidable_pred.{1} nat p], @Exists.{1} nat (λ (n : nat), p n) → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@Exists.{1} nat (λ (m : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y) m) (@has_one.one.{0} nat nat.has_one)) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {p : α → Prop}, @subtype.{1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ (z : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s), @has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@subtype.preorder.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))) z x → @has_le.le.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@preorder.to_has_le.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@subtype.preorder.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))) z y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {p : nat → Prop} [_inst_1 : @decidable_pred.{1} nat p] (H : @Exists.{1} nat (λ (n : nat), p n)), p (@nat.find p _inst_1 H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@Exists.{1} nat (λ (m : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y) m) (@has_one.one.{0} nat nat.has_one)) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@gt.{0} nat (@preorder.to_has_lt.{0} nat (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order))) (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x) (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y) (@nat.find (λ (m : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y) m) (@has_one.one.{0} nat nat.has_one)) s) (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y) a) (@has_one.one.{0} nat nat.has_one))) hx)) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151  not_lt_of_le this $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='not_lt_of_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/order.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b → not (@has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{0} nat nat.has_le (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y) (@nat.find (λ (m : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y) m) (@has_one.one.{0} nat nat.has_one)) s) (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y) a) (@has_one.one.{0} nat nat.has_one))) hx)) (@has_one.one.{0} nat nat.has_one)) (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152    calc y.1 ≤ y.1 + nat.find hx : le_add_of_nonneg_right (nat.zero_le _)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat.find'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='le_add_of_nonneg_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.zero_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/lemmas.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ordered_group.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 75, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {p : α → Prop}, @subtype.{1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {p : α → Prop}, @subtype.{1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {p : nat → Prop} [_inst_1 : @decidable_pred.{1} nat p], @Exists.{1} nat (λ (n : nat), p n) → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@Exists.{1} nat (λ (m : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y) m) (@has_one.one.{0} nat nat.has_one)) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type} [_inst_1 : ordered_cancel_comm_monoid.{0} α] {a b : α}, @ge.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_cancel_comm_monoid.to_partial_order.{0} α _inst_1))) b (@has_zero.zero.{0} α (@add_monoid.to_has_zero.{0} α (@add_comm_monoid.to_add_monoid.{0} α (@ordered_cancel_comm_monoid.to_add_comm_monoid.{0} α _inst_1)))) → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_cancel_comm_monoid.to_partial_order.{0} α _inst_1))) a (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α (@add_comm_monoid.to_add_monoid.{0} α (@ordered_cancel_comm_monoid.to_add_comm_monoid.{0} α _inst_1)))) a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ (n : nat), @has_le.le.{0} nat nat.has_le (@has_zero.zero.{0} nat nat.has_zero) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153    ... &lt; y.1 + nat.find hx + 1 : nat.lt_succ_self _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat.find'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='nat.lt_succ_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/lemmas.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/lemmas.lean&#x27;, &#x27;line&#x27;: 165, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {p : α → Prop}, @subtype.{1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {p : nat → Prop} [_inst_1 : @decidable_pred.{1} nat p], @Exists.{1} nat (λ (n : nat), p n) → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@Exists.{1} nat (λ (m : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y) m) (@has_one.one.{0} nat nat.has_one)) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ (n : nat), @has_lt.lt.{0} nat nat.has_lt n (nat.succ n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155  lemma lt_succ_self (x : s) : x &lt; succ x :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat.subtype.succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 135, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_lt.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {s : set.{0} nat} [_inst_1 : @decidable_pred.{1} nat s] [_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)], @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s → @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156  calc x.1 ≤ x.1 + _ : le_add_right (le_refl _)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='le_add_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='le_refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ordered_group.lean&#x27;, &#x27;line&#x27;: 375, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {p : α → Prop}, @subtype.{1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {p : α → Prop}, @subtype.{1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type} [_inst_1 : canonically_ordered_monoid.{0} α] {a b c : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} α _inst_1)))) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} α _inst_1)))) a (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α (@add_comm_monoid.to_add_monoid.{0} α (@ordered_comm_monoid.to_add_comm_monoid.{0} α (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} α _inst_1))))) b c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] (a : α), @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157  ... &lt; succ x : nat.lt_succ_self (x.1 + _)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='nat.subtype.succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='nat.lt_succ_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 135, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/lemmas.lean&#x27;, &#x27;line&#x27;: 165, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {s : set.{0} nat} [_inst_1 : @decidable_pred.{1} nat s] [_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)], @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s → @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ (n : nat), @has_lt.lt.{0} nat nat.has_lt n (nat.succ n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {p : α → Prop}, @subtype.{1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159  lemma lt_succ_iff_le {x y : s} : x &lt; succ y ↔ x ≤ y :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat.subtype.succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 135, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_lt.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {s : set.{0} nat} [_inst_1 : @decidable_pred.{1} nat s] [_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)], @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s → @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160  ⟨λ h, le_of_not_gt (λ h&#x27;, not_le_of_gt h (succ_le_of_lt h&#x27;)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='le_of_not_gt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='h&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='not_le_of_gt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.subtype.succ_le_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 118, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@subtype.preorder.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))) x (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2 y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type} [_inst_1 : linear_order.{0} α] {a b : α}, not (@gt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α _inst_1))) a b) → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α _inst_1))) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@gt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@partial_order.to_preorder.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@linear_order.to_partial_order.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@subtype.linear_order.{0} nat nat.linear_order (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b : α}, @gt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a b → not (@has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@subtype.preorder.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))) x (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2 y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {s : set.{0} nat} [_inst_1 : @decidable_pred.{1} nat s] [_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)] {x y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s}, @has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@subtype.preorder.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))) y x → @has_le.le.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@preorder.to_has_le.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@subtype.preorder.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))) (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2 y) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@gt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@partial_order.to_preorder.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@linear_order.to_partial_order.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@subtype.linear_order.{0} nat nat.linear_order (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161    λ h, lt_of_le_of_lt h (lt_succ_self _)⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lt_of_le_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.subtype.lt_succ_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 107, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 155, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@has_le.le.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@preorder.to_has_le.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@subtype.preorder.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b c : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b → @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) b c → @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@preorder.to_has_le.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@subtype.preorder.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {s : set.{0} nat} [_inst_1 : @decidable_pred.{1} nat s] [_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)] (x : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s), @has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@subtype.preorder.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))) x (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2 x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163  def of_nat (s : set ℕ) [decidable_pred s] [infinite s] : ℕ → s</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='decidable_pred'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='infinite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='of_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 268, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 796, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type}, (α → Prop) → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>164  | 0     := ⊥</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π (α : Type) [c : lattice.has_bot.{0} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>165  | (n+1) := succ (of_nat n)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='nat.subtype.succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='of_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 135, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {s : set.{0} nat} [_inst_1 : @decidable_pred.{1} nat s] [_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)], @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s → @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>166  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>167  lemma of_nat_surjective_aux : ∀ {x : ℕ} (hx : x ∈ s), ∃ n, of_nat s n = ⟨x, hx⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='of_nat_surjective_aux'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat.subtype.of_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 163, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='∀ {x : nat} (hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s), @Exists.{1} nat (λ (n : nat), @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n) (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type} [c : has_mem.{0 0} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (s : set.{0} nat) [_inst_3 : @decidable_pred.{1} nat s] [_inst_4 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)], nat → @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>168  | x := λ hx, let t : list s := ((list.range x).filter (λ y, y ∈ s)).pmap</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='list.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='list.filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.pmap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/basic.lean&#x27;, &#x27;line&#x27;: 231, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/basic.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 1756, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='nat → list.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type} (p : α → Prop) [_inst_1 : @decidable_pred.{1} α p], list.{0} α → list.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type} [c : has_mem.{0 0} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type} {p : α → Prop}, (Π (a : α), p a → β) → Π (l : list.{0} α), (∀ (a : α), @has_mem.mem.{0 0} α (list.{0} α) (@list.has_mem.{0} α) a l → p a) → list.{0} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                   </code><font color='orange'><a title='Partial map. If `f : Π a, p a → β` is a partial function defined on
 `a : α` satisfying `p`, then `pmap f l h` is essentially the same as `map f l`
 but is defined only when all members of `l` satisfy `p`, using the proof
 to apply `f`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>169    (λ (y : ℕ) (hy : y ∈ s), ⟨y, hy⟩) (by simp) in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type} [c : has_mem.{0 0} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
of_nat_surjective_aux :
  ∀ {x : nat} (hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s),
    @Exists.{1} nat
      (λ (n : nat),
         @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
           (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
           (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
x : nat,
hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s
⊢ ∀ (a : nat),
    @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
      (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
         (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
         (list.range x)) →
    @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>170  have hmt : ∀ {y : s}, y ∈ t ↔ y &lt; ⟨x, hx⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type} [c : has_mem.{0 0} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_lt.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>171    by simp [list.mem_filter, subtype.ext, t]; intros; refl,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='list.mem_filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='subtype.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 2025, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/subtype.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {p : α → Prop} [_inst_1 : @decidable_pred.{?l_1+1} α p] {a : α} {l : list.{?l_1} α}, iff (@has_mem.mem.{?l_1 ?l_1} α (list.{?l_1} α) (@list.has_mem.{?l_1} α) a (@list.filter.{?l_1} α p (λ (a : α), _inst_1 a) l)) (and (@has_mem.mem.{?l_1 ?l_1} α (list.{?l_1} α) (@list.has_mem.{?l_1} α) a l) (p a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Sort ?l_1} {p : α → Prop} {a1 a2 : @subtype.{?l_1} α (λ (x : α), p x)}, iff (@eq.{(max 1 ?l_1)} (@subtype.{?l_1} α (λ (x : α), p x)) a1 a2) (@eq.{?l_1} α (@subtype.val.{?l_1} α (λ (x : α), p x) a1) (@subtype.val.{?l_1} α (λ (x : α), p x) a2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
of_nat_surjective_aux :
  ∀ {x : nat} (hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s),
    @Exists.{1} nat
      (λ (n : nat),
         @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
           (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
           (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
x : nat,
hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s,
t : list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) :=
  @list.pmap.{0 0} nat (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
    (λ (y : nat) (hy : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s),
       @subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y hy)
    (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
       (list.range x))
    (@eq.mpr.{0}
       (∀ (a : nat),
          @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
            (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
               (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
               (list.range x)) →
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
       true
       (@id.{0}
          (@eq.{1} Prop
             (∀ (a : nat),
                @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                  (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                     (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                     (list.range x)) →
                @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
             true)
          (@eq.trans.{1} Prop
             (∀ (x_1 : nat),
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                  x_1)
             (∀ (x : nat), (λ (a : nat), true) x)
             true
             (@forall_congr_eq.{1} nat
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                (λ (a : nat), true)
                (λ (a : nat),
                   @eq.trans.{1} Prop
                     (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                        (@list.filter.{0} nat
                           (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                           (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                           (list.range x)) →
                      @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                     (@has_lt.lt.{0} nat nat.has_lt a x → true)
                     true
                     (@eq.trans.{1} Prop
                        (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                           (@list.filter.{0} nat
                              (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                              (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                              (list.range x)) →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x → true)
                        (@eq.trans.{1} Prop
                           (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                              (@list.filter.{0} nat
                                 (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                 (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                 (list.range x)) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (and (@has_lt.lt.{0} nat nat.has_lt a x)
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@imp_congr_eq
                              (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                 (@list.filter.{0} nat
                                    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                    (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                    (list.range x)))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@eq.trans.{1} Prop
                                 (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                    (@list.filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat),
                                          (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                       (list.range x)))
                                 (and (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s) a))
                                 (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                                 (@propext
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                       (@list.filter.{0} nat
                                          (λ (y : nat),
                                             @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          (λ (a : nat),
                                             (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                          (list.range x)))
                                    (and
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          a))
                                    (@list.mem_filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                       a
                                       (list.range x)))
                                 ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                   (e_2 : @eq.{1} Prop b b_1),
                                     @congr.{1 1} Prop Prop (and a) (and a_1) b b_1
                                       (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 and e_1)
                                       e_2)
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@propext
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       (@has_lt.lt.{0} nat nat.has_lt a x)
                                       (@list.mem_range a x))
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@eq.refl.{1} Prop
                                       (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                              (@eq.refl.{1} Prop (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))
                           (@propext
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@has_lt.lt.{0} nat nat.has_lt a x →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@and_imp (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                        (@imp_congr_eq (@has_lt.lt.{0} nat nat.has_lt a x)
                           (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x)
                           true
                           (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt a x))
                           (@propext
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              true
                              (@imp_self (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))))
                     (@propext (@has_lt.lt.{0} nat nat.has_lt a x → true) true
                        (@forall_true_iff.{0} (@has_lt.lt.{0} nat nat.has_lt a x)))))
             (@propext (nat → true) true (@forall_const.{1} true nat nat.inhabited))))
       trivial)
⊢ ∀ {y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s},
    iff
      (@has_mem.mem.{0 0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@list.has_mem.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         y
         t)
      (@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (@subtype.preorder.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@ordered_comm_monoid.to_partial_order.{0} nat
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                        (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
               (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
         y
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>172  have wf : ∀ m : s, list.maximum t = m → m.1 &lt; x,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.maximum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/min_max.lean&#x27;, &#x27;line&#x27;: 200, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [_inst_2 : decidable_linear_order.{0} α], list.{0} α → with_bot.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {p : α → Prop}, @subtype.{1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_lt.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title=' `maximum l` returns an `with_bot α`, the largest element of `l` for nonempty lists, and `⊥` for
`[]`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>173    from λ m hmax, by simpa [hmt] using list.maximum_mem hmax,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hmax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='list.maximum_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hmax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/min_max.lean&#x27;, &#x27;line&#x27;: 214, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)) (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@subtype.decidable_linear_order.{0} nat (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring) (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)) t) (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)) (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)) (@with_bot.has_coe_t.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))) m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='iff (@has_mem.mem.{0 0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)) (@list.has_mem.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)) ?m_1 t) (@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@subtype.preorder.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))) ?m_1 (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_2 : decidable_linear_order.{0} α] {l : list.{0} α} {m : α}, @eq.{1} (with_bot.{0} α) (@list.maximum.{0} α _inst_2 l) (@coe.{1 1} α (with_bot.{0} α) (@coe_to_lift.{1 1} α (with_bot.{0} α) (@with_bot.has_coe_t.{0} α)) m) → @has_mem.mem.{0 0} α (list.{0} α) (@list.has_mem.{0} α) m l'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)) (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@subtype.decidable_linear_order.{0} nat (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring) (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)) t) (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)) (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)) (@with_bot.has_coe_t.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))) m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
of_nat_surjective_aux :
  ∀ {x : nat} (hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s),
    @Exists.{1} nat
      (λ (n : nat),
         @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
           (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
           (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
x : nat,
hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s,
t : list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) :=
  @list.pmap.{0 0} nat (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
    (λ (y : nat) (hy : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s),
       @subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y hy)
    (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
       (list.range x))
    (@eq.mpr.{0}
       (∀ (a : nat),
          @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
            (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
               (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
               (list.range x)) →
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
       true
       (@id.{0}
          (@eq.{1} Prop
             (∀ (a : nat),
                @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                  (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                     (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                     (list.range x)) →
                @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
             true)
          (@eq.trans.{1} Prop
             (∀ (x_1 : nat),
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                  x_1)
             (∀ (x : nat), (λ (a : nat), true) x)
             true
             (@forall_congr_eq.{1} nat
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                (λ (a : nat), true)
                (λ (a : nat),
                   @eq.trans.{1} Prop
                     (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                        (@list.filter.{0} nat
                           (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                           (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                           (list.range x)) →
                      @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                     (@has_lt.lt.{0} nat nat.has_lt a x → true)
                     true
                     (@eq.trans.{1} Prop
                        (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                           (@list.filter.{0} nat
                              (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                              (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                              (list.range x)) →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x → true)
                        (@eq.trans.{1} Prop
                           (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                              (@list.filter.{0} nat
                                 (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                 (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                 (list.range x)) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (and (@has_lt.lt.{0} nat nat.has_lt a x)
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@imp_congr_eq
                              (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                 (@list.filter.{0} nat
                                    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                    (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                    (list.range x)))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@eq.trans.{1} Prop
                                 (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                    (@list.filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat),
                                          (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                       (list.range x)))
                                 (and (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s) a))
                                 (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                                 (@propext
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                       (@list.filter.{0} nat
                                          (λ (y : nat),
                                             @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          (λ (a : nat),
                                             (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                          (list.range x)))
                                    (and
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          a))
                                    (@list.mem_filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                       a
                                       (list.range x)))
                                 ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                   (e_2 : @eq.{1} Prop b b_1),
                                     @congr.{1 1} Prop Prop (and a) (and a_1) b b_1
                                       (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 and e_1)
                                       e_2)
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@propext
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       (@has_lt.lt.{0} nat nat.has_lt a x)
                                       (@list.mem_range a x))
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@eq.refl.{1} Prop
                                       (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                              (@eq.refl.{1} Prop (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))
                           (@propext
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@has_lt.lt.{0} nat nat.has_lt a x →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@and_imp (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                        (@imp_congr_eq (@has_lt.lt.{0} nat nat.has_lt a x)
                           (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x)
                           true
                           (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt a x))
                           (@propext
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              true
                              (@imp_self (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))))
                     (@propext (@has_lt.lt.{0} nat nat.has_lt a x → true) true
                        (@forall_true_iff.{0} (@has_lt.lt.{0} nat nat.has_lt a x)))))
             (@propext (nat → true) true (@forall_const.{1} true nat nat.inhabited))))
       trivial),
hmt :
  ∀ {y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s},
    iff
      (@has_mem.mem.{0 0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@list.has_mem.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         y
         t)
      (@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (@subtype.preorder.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@ordered_comm_monoid.to_partial_order.{0} nat
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                        (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
               (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
         y
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s,
hmax :
  @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
    (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@subtype.decidable_linear_order.{0} nat
          (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
          (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
       t)
    (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
       (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
          (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
          (@with_bot.has_coe_t.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)))
       m)
⊢ @has_lt.lt.{0} nat nat.has_lt
    (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>174  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
of_nat_surjective_aux :
  ∀ {x : nat} (hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s),
    @Exists.{1} nat
      (λ (n : nat),
         @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
           (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
           (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
x : nat,
hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s,
t : list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) :=
  @list.pmap.{0 0} nat (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
    (λ (y : nat) (hy : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s),
       @subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y hy)
    (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
       (list.range x))
    (@eq.mpr.{0}
       (∀ (a : nat),
          @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
            (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
               (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
               (list.range x)) →
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
       true
       (@id.{0}
          (@eq.{1} Prop
             (∀ (a : nat),
                @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                  (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                     (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                     (list.range x)) →
                @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
             true)
          (@eq.trans.{1} Prop
             (∀ (x_1 : nat),
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                  x_1)
             (∀ (x : nat), (λ (a : nat), true) x)
             true
             (@forall_congr_eq.{1} nat
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                (λ (a : nat), true)
                (λ (a : nat),
                   @eq.trans.{1} Prop
                     (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                        (@list.filter.{0} nat
                           (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                           (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                           (list.range x)) →
                      @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                     (@has_lt.lt.{0} nat nat.has_lt a x → true)
                     true
                     (@eq.trans.{1} Prop
                        (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                           (@list.filter.{0} nat
                              (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                              (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                              (list.range x)) →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x → true)
                        (@eq.trans.{1} Prop
                           (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                              (@list.filter.{0} nat
                                 (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                 (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                 (list.range x)) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (and (@has_lt.lt.{0} nat nat.has_lt a x)
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@imp_congr_eq
                              (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                 (@list.filter.{0} nat
                                    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                    (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                    (list.range x)))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@eq.trans.{1} Prop
                                 (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                    (@list.filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat),
                                          (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                       (list.range x)))
                                 (and (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s) a))
                                 (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                                 (@propext
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                       (@list.filter.{0} nat
                                          (λ (y : nat),
                                             @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          (λ (a : nat),
                                             (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                          (list.range x)))
                                    (and
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          a))
                                    (@list.mem_filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                       a
                                       (list.range x)))
                                 ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                   (e_2 : @eq.{1} Prop b b_1),
                                     @congr.{1 1} Prop Prop (and a) (and a_1) b b_1
                                       (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 and e_1)
                                       e_2)
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@propext
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       (@has_lt.lt.{0} nat nat.has_lt a x)
                                       (@list.mem_range a x))
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@eq.refl.{1} Prop
                                       (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                              (@eq.refl.{1} Prop (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))
                           (@propext
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@has_lt.lt.{0} nat nat.has_lt a x →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@and_imp (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                        (@imp_congr_eq (@has_lt.lt.{0} nat nat.has_lt a x)
                           (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x)
                           true
                           (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt a x))
                           (@propext
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              true
                              (@imp_self (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))))
                     (@propext (@has_lt.lt.{0} nat nat.has_lt a x → true) true
                        (@forall_true_iff.{0} (@has_lt.lt.{0} nat nat.has_lt a x)))))
             (@propext (nat → true) true (@forall_const.{1} true nat nat.inhabited))))
       trivial),
hmt :
  ∀ {y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s},
    iff
      (@has_mem.mem.{0 0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@list.has_mem.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         y
         t)
      (@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (@subtype.preorder.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@ordered_comm_monoid.to_partial_order.{0} nat
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                        (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
               (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
         y
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
wf :
  ∀ (m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
    @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
      (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@subtype.decidable_linear_order.{0} nat
            (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
            (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
         t)
      (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
            (@with_bot.has_coe_t.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)))
         m) →
    @has_lt.lt.{0} nat nat.has_lt
      (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
      x
⊢ @Exists.{1} nat
    (λ (n : nat),
       @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>175    cases hmax : list.maximum t with m,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='list.maximum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/min_max.lean&#x27;, &#x27;line&#x27;: 200, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [_inst_2 : decidable_linear_order.{0} α], list.{0} α → with_bot.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `maximum l` returns an `with_bot α`, the largest element of `l` for nonempty lists, and `⊥` for
`[]`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
of_nat_surjective_aux :
  ∀ {x : nat} (hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s),
    @Exists.{1} nat
      (λ (n : nat),
         @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
           (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
           (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
x : nat,
hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s,
t : list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) :=
  @list.pmap.{0 0} nat (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
    (λ (y : nat) (hy : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s),
       @subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y hy)
    (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
       (list.range x))
    (@eq.mpr.{0}
       (∀ (a : nat),
          @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
            (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
               (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
               (list.range x)) →
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
       true
       (@id.{0}
          (@eq.{1} Prop
             (∀ (a : nat),
                @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                  (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                     (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                     (list.range x)) →
                @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
             true)
          (@eq.trans.{1} Prop
             (∀ (x_1 : nat),
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                  x_1)
             (∀ (x : nat), (λ (a : nat), true) x)
             true
             (@forall_congr_eq.{1} nat
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                (λ (a : nat), true)
                (λ (a : nat),
                   @eq.trans.{1} Prop
                     (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                        (@list.filter.{0} nat
                           (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                           (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                           (list.range x)) →
                      @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                     (@has_lt.lt.{0} nat nat.has_lt a x → true)
                     true
                     (@eq.trans.{1} Prop
                        (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                           (@list.filter.{0} nat
                              (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                              (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                              (list.range x)) →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x → true)
                        (@eq.trans.{1} Prop
                           (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                              (@list.filter.{0} nat
                                 (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                 (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                 (list.range x)) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (and (@has_lt.lt.{0} nat nat.has_lt a x)
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@imp_congr_eq
                              (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                 (@list.filter.{0} nat
                                    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                    (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                    (list.range x)))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@eq.trans.{1} Prop
                                 (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                    (@list.filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat),
                                          (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                       (list.range x)))
                                 (and (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s) a))
                                 (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                                 (@propext
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                       (@list.filter.{0} nat
                                          (λ (y : nat),
                                             @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          (λ (a : nat),
                                             (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                          (list.range x)))
                                    (and
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          a))
                                    (@list.mem_filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                       a
                                       (list.range x)))
                                 ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                   (e_2 : @eq.{1} Prop b b_1),
                                     @congr.{1 1} Prop Prop (and a) (and a_1) b b_1
                                       (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 and e_1)
                                       e_2)
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@propext
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       (@has_lt.lt.{0} nat nat.has_lt a x)
                                       (@list.mem_range a x))
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@eq.refl.{1} Prop
                                       (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                              (@eq.refl.{1} Prop (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))
                           (@propext
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@has_lt.lt.{0} nat nat.has_lt a x →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@and_imp (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                        (@imp_congr_eq (@has_lt.lt.{0} nat nat.has_lt a x)
                           (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x)
                           true
                           (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt a x))
                           (@propext
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              true
                              (@imp_self (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))))
                     (@propext (@has_lt.lt.{0} nat nat.has_lt a x → true) true
                        (@forall_true_iff.{0} (@has_lt.lt.{0} nat nat.has_lt a x)))))
             (@propext (nat → true) true (@forall_const.{1} true nat nat.inhabited))))
       trivial),
hmt :
  ∀ {y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s},
    iff
      (@has_mem.mem.{0 0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@list.has_mem.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         y
         t)
      (@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (@subtype.preorder.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@ordered_comm_monoid.to_partial_order.{0} nat
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                        (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
               (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
         y
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
wf :
  ∀ (m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
    @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
      (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@subtype.decidable_linear_order.{0} nat
            (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
            (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
         t)
      (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
            (@with_bot.has_coe_t.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)))
         m) →
    @has_lt.lt.{0} nat nat.has_lt
      (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
      x
⊢ @Exists.{1} nat
    (λ (n : nat),
       @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case option.none
s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
of_nat_surjective_aux :
  ∀ {x : nat} (hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s),
    @Exists.{1} nat
      (λ (n : nat),
         @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
           (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
           (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
x : nat,
hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s,
t : list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) :=
  @list.pmap.{0 0} nat (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
    (λ (y : nat) (hy : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s),
       @subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y hy)
    (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
       (list.range x))
    (@eq.mpr.{0}
       (∀ (a : nat),
          @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
            (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
               (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
               (list.range x)) →
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
       true
       (@id.{0}
          (@eq.{1} Prop
             (∀ (a : nat),
                @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                  (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                     (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                     (list.range x)) →
                @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
             true)
          (@eq.trans.{1} Prop
             (∀ (x_1 : nat),
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                  x_1)
             (∀ (x : nat), (λ (a : nat), true) x)
             true
             (@forall_congr_eq.{1} nat
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                (λ (a : nat), true)
                (λ (a : nat),
                   @eq.trans.{1} Prop
                     (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                        (@list.filter.{0} nat
                           (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                           (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                           (list.range x)) →
                      @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                     (@has_lt.lt.{0} nat nat.has_lt a x → true)
                     true
                     (@eq.trans.{1} Prop
                        (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                           (@list.filter.{0} nat
                              (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                              (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                              (list.range x)) →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x → true)
                        (@eq.trans.{1} Prop
                           (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                              (@list.filter.{0} nat
                                 (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                 (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                 (list.range x)) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (and (@has_lt.lt.{0} nat nat.has_lt a x)
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@imp_congr_eq
                              (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                 (@list.filter.{0} nat
                                    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                    (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                    (list.range x)))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@eq.trans.{1} Prop
                                 (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                    (@list.filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat),
                                          (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                       (list.range x)))
                                 (and (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s) a))
                                 (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                                 (@propext
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                       (@list.filter.{0} nat
                                          (λ (y : nat),
                                             @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          (λ (a : nat),
                                             (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                          (list.range x)))
                                    (and
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          a))
                                    (@list.mem_filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                       a
                                       (list.range x)))
                                 ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                   (e_2 : @eq.{1} Prop b b_1),
                                     @congr.{1 1} Prop Prop (and a) (and a_1) b b_1
                                       (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 and e_1)
                                       e_2)
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@propext
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       (@has_lt.lt.{0} nat nat.has_lt a x)
                                       (@list.mem_range a x))
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@eq.refl.{1} Prop
                                       (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                              (@eq.refl.{1} Prop (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))
                           (@propext
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@has_lt.lt.{0} nat nat.has_lt a x →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@and_imp (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                        (@imp_congr_eq (@has_lt.lt.{0} nat nat.has_lt a x)
                           (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x)
                           true
                           (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt a x))
                           (@propext
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              true
                              (@imp_self (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))))
                     (@propext (@has_lt.lt.{0} nat nat.has_lt a x → true) true
                        (@forall_true_iff.{0} (@has_lt.lt.{0} nat nat.has_lt a x)))))
             (@propext (nat → true) true (@forall_const.{1} true nat nat.inhabited))))
       trivial),
hmt :
  ∀ {y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s},
    iff
      (@has_mem.mem.{0 0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@list.has_mem.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         y
         t)
      (@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (@subtype.preorder.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@ordered_comm_monoid.to_partial_order.{0} nat
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                        (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
               (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
         y
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
wf :
  ∀ (m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
    @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
      (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@subtype.decidable_linear_order.{0} nat
            (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
            (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
         t)
      (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
            (@with_bot.has_coe_t.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)))
         m) →
    @has_lt.lt.{0} nat nat.has_lt
      (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
      x,
hmax :
  @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
    (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@subtype.decidable_linear_order.{0} nat
          (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
          (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
       t)
    (@option.none.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
⊢ @Exists.{1} nat
    (λ (n : nat),
       @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx))

case option.some
s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
of_nat_surjective_aux :
  ∀ {x : nat} (hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s),
    @Exists.{1} nat
      (λ (n : nat),
         @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
           (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
           (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
x : nat,
hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s,
t : list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) :=
  @list.pmap.{0 0} nat (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
    (λ (y : nat) (hy : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s),
       @subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y hy)
    (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
       (list.range x))
    (@eq.mpr.{0}
       (∀ (a : nat),
          @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
            (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
               (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
               (list.range x)) →
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
       true
       (@id.{0}
          (@eq.{1} Prop
             (∀ (a : nat),
                @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                  (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                     (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                     (list.range x)) →
                @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
             true)
          (@eq.trans.{1} Prop
             (∀ (x_1 : nat),
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                  x_1)
             (∀ (x : nat), (λ (a : nat), true) x)
             true
             (@forall_congr_eq.{1} nat
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                (λ (a : nat), true)
                (λ (a : nat),
                   @eq.trans.{1} Prop
                     (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                        (@list.filter.{0} nat
                           (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                           (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                           (list.range x)) →
                      @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                     (@has_lt.lt.{0} nat nat.has_lt a x → true)
                     true
                     (@eq.trans.{1} Prop
                        (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                           (@list.filter.{0} nat
                              (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                              (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                              (list.range x)) →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x → true)
                        (@eq.trans.{1} Prop
                           (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                              (@list.filter.{0} nat
                                 (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                 (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                 (list.range x)) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (and (@has_lt.lt.{0} nat nat.has_lt a x)
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@imp_congr_eq
                              (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                 (@list.filter.{0} nat
                                    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                    (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                    (list.range x)))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@eq.trans.{1} Prop
                                 (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                    (@list.filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat),
                                          (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                       (list.range x)))
                                 (and (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s) a))
                                 (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                                 (@propext
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                       (@list.filter.{0} nat
                                          (λ (y : nat),
                                             @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          (λ (a : nat),
                                             (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                          (list.range x)))
                                    (and
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          a))
                                    (@list.mem_filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                       a
                                       (list.range x)))
                                 ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                   (e_2 : @eq.{1} Prop b b_1),
                                     @congr.{1 1} Prop Prop (and a) (and a_1) b b_1
                                       (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 and e_1)
                                       e_2)
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@propext
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       (@has_lt.lt.{0} nat nat.has_lt a x)
                                       (@list.mem_range a x))
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@eq.refl.{1} Prop
                                       (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                              (@eq.refl.{1} Prop (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))
                           (@propext
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@has_lt.lt.{0} nat nat.has_lt a x →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@and_imp (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                        (@imp_congr_eq (@has_lt.lt.{0} nat nat.has_lt a x)
                           (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x)
                           true
                           (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt a x))
                           (@propext
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              true
                              (@imp_self (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))))
                     (@propext (@has_lt.lt.{0} nat nat.has_lt a x → true) true
                        (@forall_true_iff.{0} (@has_lt.lt.{0} nat nat.has_lt a x)))))
             (@propext (nat → true) true (@forall_const.{1} true nat nat.inhabited))))
       trivial),
hmt :
  ∀ {y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s},
    iff
      (@has_mem.mem.{0 0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@list.has_mem.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         y
         t)
      (@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (@subtype.preorder.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@ordered_comm_monoid.to_partial_order.{0} nat
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                        (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
               (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
         y
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
wf :
  ∀ (m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
    @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
      (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@subtype.decidable_linear_order.{0} nat
            (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
            (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
         t)
      (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
            (@with_bot.has_coe_t.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)))
         m) →
    @has_lt.lt.{0} nat nat.has_lt
      (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
      x,
m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s,
hmax :
  @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
    (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@subtype.decidable_linear_order.{0} nat
          (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
          (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
       t)
    (@option.some.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) m)
⊢ @Exists.{1} nat
    (λ (n : nat),
       @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>176    { exact ⟨0, le_antisymm (@bot_le s _ _)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='le_antisymm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='lattice.bot_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 102, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : partial_order.{0} α] {a b : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α _inst_1)) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α _inst_1)) b a → @eq.{1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type} [_inst_1 : lattice.order_bot.{0} α] {a : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.order_bot.to_partial_order.{0} α _inst_1))) (@lattice.has_bot.bot.{0} α (@lattice.order_bot.to_has_bot.{0} α _inst_1)) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case option.none
s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
of_nat_surjective_aux :
  ∀ {x : nat} (hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s),
    @Exists.{1} nat
      (λ (n : nat),
         @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
           (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
           (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
x : nat,
hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s,
t : list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) :=
  @list.pmap.{0 0} nat (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
    (λ (y : nat) (hy : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s),
       @subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y hy)
    (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
       (list.range x))
    (@eq.mpr.{0}
       (∀ (a : nat),
          @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
            (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
               (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
               (list.range x)) →
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
       true
       (@id.{0}
          (@eq.{1} Prop
             (∀ (a : nat),
                @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                  (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                     (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                     (list.range x)) →
                @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
             true)
          (@eq.trans.{1} Prop
             (∀ (x_1 : nat),
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                  x_1)
             (∀ (x : nat), (λ (a : nat), true) x)
             true
             (@forall_congr_eq.{1} nat
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                (λ (a : nat), true)
                (λ (a : nat),
                   @eq.trans.{1} Prop
                     (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                        (@list.filter.{0} nat
                           (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                           (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                           (list.range x)) →
                      @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                     (@has_lt.lt.{0} nat nat.has_lt a x → true)
                     true
                     (@eq.trans.{1} Prop
                        (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                           (@list.filter.{0} nat
                              (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                              (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                              (list.range x)) →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x → true)
                        (@eq.trans.{1} Prop
                           (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                              (@list.filter.{0} nat
                                 (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                 (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                 (list.range x)) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (and (@has_lt.lt.{0} nat nat.has_lt a x)
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@imp_congr_eq
                              (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                 (@list.filter.{0} nat
                                    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                    (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                    (list.range x)))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@eq.trans.{1} Prop
                                 (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                    (@list.filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat),
                                          (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                       (list.range x)))
                                 (and (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s) a))
                                 (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                                 (@propext
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                       (@list.filter.{0} nat
                                          (λ (y : nat),
                                             @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          (λ (a : nat),
                                             (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                          (list.range x)))
                                    (and
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          a))
                                    (@list.mem_filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                       a
                                       (list.range x)))
                                 ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                   (e_2 : @eq.{1} Prop b b_1),
                                     @congr.{1 1} Prop Prop (and a) (and a_1) b b_1
                                       (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 and e_1)
                                       e_2)
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@propext
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       (@has_lt.lt.{0} nat nat.has_lt a x)
                                       (@list.mem_range a x))
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@eq.refl.{1} Prop
                                       (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                              (@eq.refl.{1} Prop (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))
                           (@propext
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@has_lt.lt.{0} nat nat.has_lt a x →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@and_imp (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                        (@imp_congr_eq (@has_lt.lt.{0} nat nat.has_lt a x)
                           (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x)
                           true
                           (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt a x))
                           (@propext
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              true
                              (@imp_self (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))))
                     (@propext (@has_lt.lt.{0} nat nat.has_lt a x → true) true
                        (@forall_true_iff.{0} (@has_lt.lt.{0} nat nat.has_lt a x)))))
             (@propext (nat → true) true (@forall_const.{1} true nat nat.inhabited))))
       trivial),
hmt :
  ∀ {y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s},
    iff
      (@has_mem.mem.{0 0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@list.has_mem.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         y
         t)
      (@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (@subtype.preorder.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@ordered_comm_monoid.to_partial_order.{0} nat
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                        (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
               (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
         y
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
wf :
  ∀ (m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
    @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
      (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@subtype.decidable_linear_order.{0} nat
            (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
            (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
         t)
      (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
            (@with_bot.has_coe_t.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)))
         m) →
    @has_lt.lt.{0} nat nat.has_lt
      (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
      x,
hmax :
  @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
    (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@subtype.decidable_linear_order.{0} nat
          (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
          (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
       t)
    (@option.none.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
⊢ @Exists.{1} nat
    (λ (n : nat),
       @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx))

case option.some
s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
of_nat_surjective_aux :
  ∀ {x : nat} (hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s),
    @Exists.{1} nat
      (λ (n : nat),
         @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
           (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
           (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
x : nat,
hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s,
t : list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) :=
  @list.pmap.{0 0} nat (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
    (λ (y : nat) (hy : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s),
       @subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y hy)
    (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
       (list.range x))
    (@eq.mpr.{0}
       (∀ (a : nat),
          @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
            (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
               (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
               (list.range x)) →
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
       true
       (@id.{0}
          (@eq.{1} Prop
             (∀ (a : nat),
                @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                  (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                     (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                     (list.range x)) →
                @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
             true)
          (@eq.trans.{1} Prop
             (∀ (x_1 : nat),
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                  x_1)
             (∀ (x : nat), (λ (a : nat), true) x)
             true
             (@forall_congr_eq.{1} nat
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                (λ (a : nat), true)
                (λ (a : nat),
                   @eq.trans.{1} Prop
                     (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                        (@list.filter.{0} nat
                           (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                           (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                           (list.range x)) →
                      @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                     (@has_lt.lt.{0} nat nat.has_lt a x → true)
                     true
                     (@eq.trans.{1} Prop
                        (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                           (@list.filter.{0} nat
                              (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                              (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                              (list.range x)) →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x → true)
                        (@eq.trans.{1} Prop
                           (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                              (@list.filter.{0} nat
                                 (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                 (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                 (list.range x)) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (and (@has_lt.lt.{0} nat nat.has_lt a x)
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@imp_congr_eq
                              (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                 (@list.filter.{0} nat
                                    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                    (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                    (list.range x)))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@eq.trans.{1} Prop
                                 (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                    (@list.filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat),
                                          (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                       (list.range x)))
                                 (and (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s) a))
                                 (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                                 (@propext
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                       (@list.filter.{0} nat
                                          (λ (y : nat),
                                             @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          (λ (a : nat),
                                             (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                          (list.range x)))
                                    (and
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          a))
                                    (@list.mem_filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                       a
                                       (list.range x)))
                                 ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                   (e_2 : @eq.{1} Prop b b_1),
                                     @congr.{1 1} Prop Prop (and a) (and a_1) b b_1
                                       (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 and e_1)
                                       e_2)
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@propext
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       (@has_lt.lt.{0} nat nat.has_lt a x)
                                       (@list.mem_range a x))
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@eq.refl.{1} Prop
                                       (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                              (@eq.refl.{1} Prop (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))
                           (@propext
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@has_lt.lt.{0} nat nat.has_lt a x →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@and_imp (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                        (@imp_congr_eq (@has_lt.lt.{0} nat nat.has_lt a x)
                           (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x)
                           true
                           (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt a x))
                           (@propext
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              true
                              (@imp_self (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))))
                     (@propext (@has_lt.lt.{0} nat nat.has_lt a x → true) true
                        (@forall_true_iff.{0} (@has_lt.lt.{0} nat nat.has_lt a x)))))
             (@propext (nat → true) true (@forall_const.{1} true nat nat.inhabited))))
       trivial),
hmt :
  ∀ {y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s},
    iff
      (@has_mem.mem.{0 0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@list.has_mem.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         y
         t)
      (@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (@subtype.preorder.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@ordered_comm_monoid.to_partial_order.{0} nat
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                        (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
               (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
         y
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
wf :
  ∀ (m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
    @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
      (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@subtype.decidable_linear_order.{0} nat
            (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
            (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
         t)
      (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
            (@with_bot.has_coe_t.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)))
         m) →
    @has_lt.lt.{0} nat nat.has_lt
      (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
      x,
m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s,
hmax :
  @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
    (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@subtype.decidable_linear_order.{0} nat
          (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
          (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
       t)
    (@option.some.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) m)
⊢ @Exists.{1} nat
    (λ (n : nat),
       @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.none
s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
of_nat_surjective_aux :
  ∀ {x : nat} (hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s),
    @Exists.{1} nat
      (λ (n : nat),
         @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
           (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
           (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
x : nat,
hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s,
t : list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) :=
  @list.pmap.{0 0} nat (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
    (λ (y : nat) (hy : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s),
       @subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y hy)
    (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
       (list.range x))
    (@eq.mpr.{0}
       (∀ (a : nat),
          @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
            (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
               (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
               (list.range x)) →
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
       true
       (@id.{0}
          (@eq.{1} Prop
             (∀ (a : nat),
                @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                  (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                     (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                     (list.range x)) →
                @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
             true)
          (@eq.trans.{1} Prop
             (∀ (x_1 : nat),
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                  x_1)
             (∀ (x : nat), (λ (a : nat), true) x)
             true
             (@forall_congr_eq.{1} nat
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                (λ (a : nat), true)
                (λ (a : nat),
                   @eq.trans.{1} Prop
                     (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                        (@list.filter.{0} nat
                           (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                           (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                           (list.range x)) →
                      @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                     (@has_lt.lt.{0} nat nat.has_lt a x → true)
                     true
                     (@eq.trans.{1} Prop
                        (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                           (@list.filter.{0} nat
                              (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                              (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                              (list.range x)) →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x → true)
                        (@eq.trans.{1} Prop
                           (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                              (@list.filter.{0} nat
                                 (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                 (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                 (list.range x)) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (and (@has_lt.lt.{0} nat nat.has_lt a x)
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@imp_congr_eq
                              (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                 (@list.filter.{0} nat
                                    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                    (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                    (list.range x)))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@eq.trans.{1} Prop
                                 (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                    (@list.filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat),
                                          (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                       (list.range x)))
                                 (and (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s) a))
                                 (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                                 (@propext
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                       (@list.filter.{0} nat
                                          (λ (y : nat),
                                             @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          (λ (a : nat),
                                             (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                          (list.range x)))
                                    (and
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          a))
                                    (@list.mem_filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                       a
                                       (list.range x)))
                                 ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                   (e_2 : @eq.{1} Prop b b_1),
                                     @congr.{1 1} Prop Prop (and a) (and a_1) b b_1
                                       (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 and e_1)
                                       e_2)
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@propext
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       (@has_lt.lt.{0} nat nat.has_lt a x)
                                       (@list.mem_range a x))
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@eq.refl.{1} Prop
                                       (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                              (@eq.refl.{1} Prop (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))
                           (@propext
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@has_lt.lt.{0} nat nat.has_lt a x →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@and_imp (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                        (@imp_congr_eq (@has_lt.lt.{0} nat nat.has_lt a x)
                           (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x)
                           true
                           (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt a x))
                           (@propext
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              true
                              (@imp_self (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))))
                     (@propext (@has_lt.lt.{0} nat nat.has_lt a x → true) true
                        (@forall_true_iff.{0} (@has_lt.lt.{0} nat nat.has_lt a x)))))
             (@propext (nat → true) true (@forall_const.{1} true nat nat.inhabited))))
       trivial),
hmt :
  ∀ {y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s},
    iff
      (@has_mem.mem.{0 0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@list.has_mem.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         y
         t)
      (@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (@subtype.preorder.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@ordered_comm_monoid.to_partial_order.{0} nat
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                        (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
               (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
         y
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
wf :
  ∀ (m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
    @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
      (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@subtype.decidable_linear_order.{0} nat
            (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
            (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
         t)
      (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
            (@with_bot.has_coe_t.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)))
         m) →
    @has_lt.lt.{0} nat nat.has_lt
      (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
      x,
hmax :
  @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
    (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@subtype.decidable_linear_order.{0} nat
          (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
          (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
       t)
    (@option.none.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
⊢ @Exists.{1} nat
    (λ (n : nat),
       @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>177        (le_of_not_gt (λ h, list.not_mem_nil (⊥ : s) $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='le_of_not_gt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='list.not_mem_nil'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/lemmas.lean&#x27;, &#x27;line&#x27;: 89, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : linear_order.{0} α] {a b : α}, not (@gt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α _inst_1))) a b) → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α _inst_1))) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} (a : α), not (@has_mem.mem.{0 0} α (list.{0} α) (@list.has_mem.{0} α) a (@list.nil.{0} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type) [c : lattice.has_bot.{0} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.none
s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
of_nat_surjective_aux :
  ∀ {x : nat} (hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s),
    @Exists.{1} nat
      (λ (n : nat),
         @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
           (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
           (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
x : nat,
hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s,
t : list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) :=
  @list.pmap.{0 0} nat (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
    (λ (y : nat) (hy : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s),
       @subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y hy)
    (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
       (list.range x))
    (@eq.mpr.{0}
       (∀ (a : nat),
          @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
            (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
               (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
               (list.range x)) →
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
       true
       (@id.{0}
          (@eq.{1} Prop
             (∀ (a : nat),
                @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                  (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                     (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                     (list.range x)) →
                @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
             true)
          (@eq.trans.{1} Prop
             (∀ (x_1 : nat),
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                  x_1)
             (∀ (x : nat), (λ (a : nat), true) x)
             true
             (@forall_congr_eq.{1} nat
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                (λ (a : nat), true)
                (λ (a : nat),
                   @eq.trans.{1} Prop
                     (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                        (@list.filter.{0} nat
                           (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                           (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                           (list.range x)) →
                      @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                     (@has_lt.lt.{0} nat nat.has_lt a x → true)
                     true
                     (@eq.trans.{1} Prop
                        (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                           (@list.filter.{0} nat
                              (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                              (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                              (list.range x)) →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x → true)
                        (@eq.trans.{1} Prop
                           (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                              (@list.filter.{0} nat
                                 (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                 (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                 (list.range x)) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (and (@has_lt.lt.{0} nat nat.has_lt a x)
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@imp_congr_eq
                              (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                 (@list.filter.{0} nat
                                    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                    (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                    (list.range x)))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@eq.trans.{1} Prop
                                 (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                    (@list.filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat),
                                          (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                       (list.range x)))
                                 (and (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s) a))
                                 (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                                 (@propext
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                       (@list.filter.{0} nat
                                          (λ (y : nat),
                                             @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          (λ (a : nat),
                                             (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                          (list.range x)))
                                    (and
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          a))
                                    (@list.mem_filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                       a
                                       (list.range x)))
                                 ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                   (e_2 : @eq.{1} Prop b b_1),
                                     @congr.{1 1} Prop Prop (and a) (and a_1) b b_1
                                       (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 and e_1)
                                       e_2)
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@propext
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       (@has_lt.lt.{0} nat nat.has_lt a x)
                                       (@list.mem_range a x))
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@eq.refl.{1} Prop
                                       (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                              (@eq.refl.{1} Prop (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))
                           (@propext
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@has_lt.lt.{0} nat nat.has_lt a x →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@and_imp (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                        (@imp_congr_eq (@has_lt.lt.{0} nat nat.has_lt a x)
                           (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x)
                           true
                           (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt a x))
                           (@propext
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              true
                              (@imp_self (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))))
                     (@propext (@has_lt.lt.{0} nat nat.has_lt a x → true) true
                        (@forall_true_iff.{0} (@has_lt.lt.{0} nat nat.has_lt a x)))))
             (@propext (nat → true) true (@forall_const.{1} true nat nat.inhabited))))
       trivial),
hmt :
  ∀ {y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s},
    iff
      (@has_mem.mem.{0 0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@list.has_mem.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         y
         t)
      (@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (@subtype.preorder.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@ordered_comm_monoid.to_partial_order.{0} nat
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                        (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
               (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
         y
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
wf :
  ∀ (m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
    @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
      (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@subtype.decidable_linear_order.{0} nat
            (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
            (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
         t)
      (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
            (@with_bot.has_coe_t.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)))
         m) →
    @has_lt.lt.{0} nat nat.has_lt
      (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
      x,
hmax :
  @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
    (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@subtype.decidable_linear_order.{0} nat
          (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
          (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
       t)
    (@option.none.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
⊢ @Exists.{1} nat
    (λ (n : nat),
       @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>178          by rw [← list.maximum_eq_none.1 hmax, hmt]; exact h))⟩ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='list.maximum_eq_none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hmax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/min_max.lean&#x27;, &#x27;line&#x27;: 218, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_2 : decidable_linear_order.{0} α] {l : list.{0} α}, iff (@eq.{1} (with_bot.{0} α) (@list.maximum.{0} α _inst_2 l) (@option.none.{0} α)) (@eq.{1} (list.{0} α) l (@list.nil.{0} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)) (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@subtype.decidable_linear_order.{0} nat (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring) (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)) t) (@option.none.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='iff (@has_mem.mem.{0 0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)) (@list.has_mem.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)) (@lattice.has_bot.bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@lattice.order_bot.to_has_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@lattice.semilattice_sup_bot.to_order_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@lattice.nat.subtype.semilattice_sup_bot s (λ (a : nat), _inst_1 a) (@infinite.nonempty.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) _inst_2))))) t) (@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@subtype.preorder.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))) (@lattice.has_bot.bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@lattice.order_bot.to_has_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@lattice.semilattice_sup_bot.to_order_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@lattice.nat.subtype.semilattice_sup_bot s (λ (a : nat), _inst_1 a) (@infinite.nonempty.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) _inst_2))))) (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@gt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@partial_order.to_preorder.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@linear_order.to_partial_order.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@subtype.linear_order.{0} nat nat.linear_order (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))) (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx) (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 (@has_zero.zero.{0} nat nat.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.none
s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
of_nat_surjective_aux :
  ∀ {x : nat} (hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s),
    @Exists.{1} nat
      (λ (n : nat),
         @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
           (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
           (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
x : nat,
hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s,
t : list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) :=
  @list.pmap.{0 0} nat (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
    (λ (y : nat) (hy : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s),
       @subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y hy)
    (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
       (list.range x))
    (@eq.mpr.{0}
       (∀ (a : nat),
          @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
            (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
               (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
               (list.range x)) →
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
       true
       (@id.{0}
          (@eq.{1} Prop
             (∀ (a : nat),
                @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                  (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                     (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                     (list.range x)) →
                @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
             true)
          (@eq.trans.{1} Prop
             (∀ (x_1 : nat),
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                  x_1)
             (∀ (x : nat), (λ (a : nat), true) x)
             true
             (@forall_congr_eq.{1} nat
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                (λ (a : nat), true)
                (λ (a : nat),
                   @eq.trans.{1} Prop
                     (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                        (@list.filter.{0} nat
                           (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                           (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                           (list.range x)) →
                      @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                     (@has_lt.lt.{0} nat nat.has_lt a x → true)
                     true
                     (@eq.trans.{1} Prop
                        (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                           (@list.filter.{0} nat
                              (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                              (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                              (list.range x)) →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x → true)
                        (@eq.trans.{1} Prop
                           (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                              (@list.filter.{0} nat
                                 (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                 (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                 (list.range x)) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (and (@has_lt.lt.{0} nat nat.has_lt a x)
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@imp_congr_eq
                              (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                 (@list.filter.{0} nat
                                    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                    (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                    (list.range x)))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@eq.trans.{1} Prop
                                 (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                    (@list.filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat),
                                          (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                       (list.range x)))
                                 (and (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s) a))
                                 (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                                 (@propext
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                       (@list.filter.{0} nat
                                          (λ (y : nat),
                                             @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          (λ (a : nat),
                                             (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                          (list.range x)))
                                    (and
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          a))
                                    (@list.mem_filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                       a
                                       (list.range x)))
                                 ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                   (e_2 : @eq.{1} Prop b b_1),
                                     @congr.{1 1} Prop Prop (and a) (and a_1) b b_1
                                       (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 and e_1)
                                       e_2)
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@propext
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       (@has_lt.lt.{0} nat nat.has_lt a x)
                                       (@list.mem_range a x))
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@eq.refl.{1} Prop
                                       (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                              (@eq.refl.{1} Prop (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))
                           (@propext
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@has_lt.lt.{0} nat nat.has_lt a x →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@and_imp (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                        (@imp_congr_eq (@has_lt.lt.{0} nat nat.has_lt a x)
                           (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x)
                           true
                           (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt a x))
                           (@propext
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              true
                              (@imp_self (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))))
                     (@propext (@has_lt.lt.{0} nat nat.has_lt a x → true) true
                        (@forall_true_iff.{0} (@has_lt.lt.{0} nat nat.has_lt a x)))))
             (@propext (nat → true) true (@forall_const.{1} true nat nat.inhabited))))
       trivial),
hmt :
  ∀ {y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s},
    iff
      (@has_mem.mem.{0 0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@list.has_mem.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         y
         t)
      (@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (@subtype.preorder.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@ordered_comm_monoid.to_partial_order.{0} nat
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                        (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
               (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
         y
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
wf :
  ∀ (m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
    @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
      (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@subtype.decidable_linear_order.{0} nat
            (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
            (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
         t)
      (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
            (@with_bot.has_coe_t.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)))
         m) →
    @has_lt.lt.{0} nat nat.has_lt
      (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
      x,
hmax :
  @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
    (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@subtype.decidable_linear_order.{0} nat
          (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
          (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
       t)
    (@option.none.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
⊢ @Exists.{1} nat
    (λ (n : nat),
       @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
of_nat_surjective_aux :
  ∀ {x : nat} (hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s),
    @Exists.{1} nat
      (λ (n : nat),
         @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
           (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
           (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
x : nat,
hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s,
t : list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) :=
  @list.pmap.{0 0} nat (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
    (λ (y : nat) (hy : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s),
       @subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y hy)
    (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
       (list.range x))
    (@eq.mpr.{0}
       (∀ (a : nat),
          @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
            (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
               (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
               (list.range x)) →
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
       true
       (@id.{0}
          (@eq.{1} Prop
             (∀ (a : nat),
                @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                  (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                     (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                     (list.range x)) →
                @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
             true)
          (@eq.trans.{1} Prop
             (∀ (x_1 : nat),
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                  x_1)
             (∀ (x : nat), (λ (a : nat), true) x)
             true
             (@forall_congr_eq.{1} nat
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                (λ (a : nat), true)
                (λ (a : nat),
                   @eq.trans.{1} Prop
                     (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                        (@list.filter.{0} nat
                           (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                           (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                           (list.range x)) →
                      @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                     (@has_lt.lt.{0} nat nat.has_lt a x → true)
                     true
                     (@eq.trans.{1} Prop
                        (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                           (@list.filter.{0} nat
                              (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                              (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                              (list.range x)) →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x → true)
                        (@eq.trans.{1} Prop
                           (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                              (@list.filter.{0} nat
                                 (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                 (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                 (list.range x)) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (and (@has_lt.lt.{0} nat nat.has_lt a x)
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@imp_congr_eq
                              (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                 (@list.filter.{0} nat
                                    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                    (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                    (list.range x)))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@eq.trans.{1} Prop
                                 (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                    (@list.filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat),
                                          (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                       (list.range x)))
                                 (and (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s) a))
                                 (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                                 (@propext
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                       (@list.filter.{0} nat
                                          (λ (y : nat),
                                             @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          (λ (a : nat),
                                             (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                          (list.range x)))
                                    (and
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          a))
                                    (@list.mem_filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                       a
                                       (list.range x)))
                                 ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                   (e_2 : @eq.{1} Prop b b_1),
                                     @congr.{1 1} Prop Prop (and a) (and a_1) b b_1
                                       (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 and e_1)
                                       e_2)
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@propext
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       (@has_lt.lt.{0} nat nat.has_lt a x)
                                       (@list.mem_range a x))
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@eq.refl.{1} Prop
                                       (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                              (@eq.refl.{1} Prop (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))
                           (@propext
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@has_lt.lt.{0} nat nat.has_lt a x →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@and_imp (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                        (@imp_congr_eq (@has_lt.lt.{0} nat nat.has_lt a x)
                           (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x)
                           true
                           (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt a x))
                           (@propext
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              true
                              (@imp_self (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))))
                     (@propext (@has_lt.lt.{0} nat nat.has_lt a x → true) true
                        (@forall_true_iff.{0} (@has_lt.lt.{0} nat nat.has_lt a x)))))
             (@propext (nat → true) true (@forall_const.{1} true nat nat.inhabited))))
       trivial),
hmt :
  ∀ {y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s},
    iff
      (@has_mem.mem.{0 0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@list.has_mem.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         y
         t)
      (@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (@subtype.preorder.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@ordered_comm_monoid.to_partial_order.{0} nat
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                        (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
               (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
         y
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
wf :
  ∀ (m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
    @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
      (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@subtype.decidable_linear_order.{0} nat
            (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
            (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
         t)
      (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
            (@with_bot.has_coe_t.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)))
         m) →
    @has_lt.lt.{0} nat nat.has_lt
      (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
      x,
hmax :
  @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
    (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@subtype.decidable_linear_order.{0} nat
          (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
          (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
       t)
    (@option.none.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)),
h :
  @gt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@partial_order.to_preorder.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
          (@linear_order.to_partial_order.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
             (@subtype.linear_order.{0} nat nat.linear_order
                (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))))
    (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)
    (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 (@has_zero.zero.{0} nat nat.has_zero))
⊢ @has_mem.mem.{0 0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
    (@list.has_mem.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
    (@lattice.has_bot.bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@lattice.order_bot.to_has_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
          (@lattice.semilattice_sup_bot.to_order_bot.{0}
             (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
             (@lattice.nat.subtype.semilattice_sup_bot s (λ (a : nat), _inst_1 a)
                (@infinite.nonempty.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) _inst_2)))))
    (@list.nil.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
of_nat_surjective_aux :
  ∀ {x : nat} (hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s),
    @Exists.{1} nat
      (λ (n : nat),
         @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
           (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
           (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
x : nat,
hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s,
t : list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) :=
  @list.pmap.{0 0} nat (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
    (λ (y : nat) (hy : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s),
       @subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y hy)
    (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
       (list.range x))
    (@eq.mpr.{0}
       (∀ (a : nat),
          @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
            (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
               (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
               (list.range x)) →
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
       true
       (@id.{0}
          (@eq.{1} Prop
             (∀ (a : nat),
                @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                  (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                     (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                     (list.range x)) →
                @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
             true)
          (@eq.trans.{1} Prop
             (∀ (x_1 : nat),
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                  x_1)
             (∀ (x : nat), (λ (a : nat), true) x)
             true
             (@forall_congr_eq.{1} nat
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                (λ (a : nat), true)
                (λ (a : nat),
                   @eq.trans.{1} Prop
                     (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                        (@list.filter.{0} nat
                           (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                           (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                           (list.range x)) →
                      @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                     (@has_lt.lt.{0} nat nat.has_lt a x → true)
                     true
                     (@eq.trans.{1} Prop
                        (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                           (@list.filter.{0} nat
                              (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                              (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                              (list.range x)) →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x → true)
                        (@eq.trans.{1} Prop
                           (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                              (@list.filter.{0} nat
                                 (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                 (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                 (list.range x)) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (and (@has_lt.lt.{0} nat nat.has_lt a x)
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@imp_congr_eq
                              (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                 (@list.filter.{0} nat
                                    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                    (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                    (list.range x)))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@eq.trans.{1} Prop
                                 (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                    (@list.filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat),
                                          (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                       (list.range x)))
                                 (and (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s) a))
                                 (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                                 (@propext
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                       (@list.filter.{0} nat
                                          (λ (y : nat),
                                             @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          (λ (a : nat),
                                             (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                          (list.range x)))
                                    (and
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          a))
                                    (@list.mem_filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                       a
                                       (list.range x)))
                                 ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                   (e_2 : @eq.{1} Prop b b_1),
                                     @congr.{1 1} Prop Prop (and a) (and a_1) b b_1
                                       (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 and e_1)
                                       e_2)
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@propext
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       (@has_lt.lt.{0} nat nat.has_lt a x)
                                       (@list.mem_range a x))
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@eq.refl.{1} Prop
                                       (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                              (@eq.refl.{1} Prop (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))
                           (@propext
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@has_lt.lt.{0} nat nat.has_lt a x →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@and_imp (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                        (@imp_congr_eq (@has_lt.lt.{0} nat nat.has_lt a x)
                           (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x)
                           true
                           (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt a x))
                           (@propext
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              true
                              (@imp_self (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))))
                     (@propext (@has_lt.lt.{0} nat nat.has_lt a x → true) true
                        (@forall_true_iff.{0} (@has_lt.lt.{0} nat nat.has_lt a x)))))
             (@propext (nat → true) true (@forall_const.{1} true nat nat.inhabited))))
       trivial),
hmt :
  ∀ {y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s},
    iff
      (@has_mem.mem.{0 0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@list.has_mem.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         y
         t)
      (@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (@subtype.preorder.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@ordered_comm_monoid.to_partial_order.{0} nat
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                        (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
               (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
         y
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
wf :
  ∀ (m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
    @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
      (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@subtype.decidable_linear_order.{0} nat
            (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
            (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
         t)
      (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
            (@with_bot.has_coe_t.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)))
         m) →
    @has_lt.lt.{0} nat nat.has_lt
      (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
      x,
hmax :
  @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
    (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@subtype.decidable_linear_order.{0} nat
          (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
          (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
       t)
    (@option.none.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)),
h :
  @gt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@partial_order.to_preorder.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
          (@linear_order.to_partial_order.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
             (@subtype.linear_order.{0} nat nat.linear_order
                (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))))
    (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)
    (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 (@has_zero.zero.{0} nat nat.has_zero))
⊢ @has_mem.mem.{0 0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
    (@list.has_mem.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
    (@lattice.has_bot.bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@lattice.order_bot.to_has_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
          (@lattice.semilattice_sup_bot.to_order_bot.{0}
             (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
             (@lattice.nat.subtype.semilattice_sup_bot s (λ (a : nat), _inst_1 a)
                (@infinite.nonempty.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) _inst_2)))))
    t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
of_nat_surjective_aux :
  ∀ {x : nat} (hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s),
    @Exists.{1} nat
      (λ (n : nat),
         @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
           (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
           (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
x : nat,
hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s,
t : list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) :=
  @list.pmap.{0 0} nat (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
    (λ (y : nat) (hy : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s),
       @subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y hy)
    (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
       (list.range x))
    (@eq.mpr.{0}
       (∀ (a : nat),
          @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
            (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
               (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
               (list.range x)) →
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
       true
       (@id.{0}
          (@eq.{1} Prop
             (∀ (a : nat),
                @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                  (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                     (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                     (list.range x)) →
                @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
             true)
          (@eq.trans.{1} Prop
             (∀ (x_1 : nat),
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                  x_1)
             (∀ (x : nat), (λ (a : nat), true) x)
             true
             (@forall_congr_eq.{1} nat
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                (λ (a : nat), true)
                (λ (a : nat),
                   @eq.trans.{1} Prop
                     (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                        (@list.filter.{0} nat
                           (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                           (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                           (list.range x)) →
                      @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                     (@has_lt.lt.{0} nat nat.has_lt a x → true)
                     true
                     (@eq.trans.{1} Prop
                        (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                           (@list.filter.{0} nat
                              (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                              (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                              (list.range x)) →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x → true)
                        (@eq.trans.{1} Prop
                           (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                              (@list.filter.{0} nat
                                 (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                 (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                 (list.range x)) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (and (@has_lt.lt.{0} nat nat.has_lt a x)
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@imp_congr_eq
                              (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                 (@list.filter.{0} nat
                                    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                    (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                    (list.range x)))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@eq.trans.{1} Prop
                                 (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                    (@list.filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat),
                                          (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                       (list.range x)))
                                 (and (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s) a))
                                 (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                                 (@propext
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                       (@list.filter.{0} nat
                                          (λ (y : nat),
                                             @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          (λ (a : nat),
                                             (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                          (list.range x)))
                                    (and
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          a))
                                    (@list.mem_filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                       a
                                       (list.range x)))
                                 ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                   (e_2 : @eq.{1} Prop b b_1),
                                     @congr.{1 1} Prop Prop (and a) (and a_1) b b_1
                                       (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 and e_1)
                                       e_2)
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@propext
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       (@has_lt.lt.{0} nat nat.has_lt a x)
                                       (@list.mem_range a x))
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@eq.refl.{1} Prop
                                       (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                              (@eq.refl.{1} Prop (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))
                           (@propext
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@has_lt.lt.{0} nat nat.has_lt a x →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@and_imp (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                        (@imp_congr_eq (@has_lt.lt.{0} nat nat.has_lt a x)
                           (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x)
                           true
                           (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt a x))
                           (@propext
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              true
                              (@imp_self (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))))
                     (@propext (@has_lt.lt.{0} nat nat.has_lt a x → true) true
                        (@forall_true_iff.{0} (@has_lt.lt.{0} nat nat.has_lt a x)))))
             (@propext (nat → true) true (@forall_const.{1} true nat nat.inhabited))))
       trivial),
hmt :
  ∀ {y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s},
    iff
      (@has_mem.mem.{0 0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@list.has_mem.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         y
         t)
      (@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (@subtype.preorder.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@ordered_comm_monoid.to_partial_order.{0} nat
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                        (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
               (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
         y
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
wf :
  ∀ (m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
    @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
      (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@subtype.decidable_linear_order.{0} nat
            (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
            (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
         t)
      (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
            (@with_bot.has_coe_t.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)))
         m) →
    @has_lt.lt.{0} nat nat.has_lt
      (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
      x,
hmax :
  @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
    (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@subtype.decidable_linear_order.{0} nat
          (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
          (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
       t)
    (@option.none.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)),
h :
  @gt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@partial_order.to_preorder.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
          (@linear_order.to_partial_order.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
             (@subtype.linear_order.{0} nat nat.linear_order
                (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))))
    (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)
    (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 (@has_zero.zero.{0} nat nat.has_zero))
⊢ @has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@subtype.preorder.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
          (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
    (@lattice.has_bot.bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@lattice.order_bot.to_has_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
          (@lattice.semilattice_sup_bot.to_order_bot.{0}
             (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
             (@lattice.nat.subtype.semilattice_sup_bot s (λ (a : nat), _inst_1 a)
                (@infinite.nonempty.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) _inst_2)))))
    (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
of_nat_surjective_aux :
  ∀ {x : nat} (hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s),
    @Exists.{1} nat
      (λ (n : nat),
         @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
           (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
           (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
x : nat,
hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s,
t : list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) :=
  @list.pmap.{0 0} nat (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
    (λ (y : nat) (hy : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s),
       @subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y hy)
    (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
       (list.range x))
    (@eq.mpr.{0}
       (∀ (a : nat),
          @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
            (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
               (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
               (list.range x)) →
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
       true
       (@id.{0}
          (@eq.{1} Prop
             (∀ (a : nat),
                @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                  (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                     (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                     (list.range x)) →
                @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
             true)
          (@eq.trans.{1} Prop
             (∀ (x_1 : nat),
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                  x_1)
             (∀ (x : nat), (λ (a : nat), true) x)
             true
             (@forall_congr_eq.{1} nat
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                (λ (a : nat), true)
                (λ (a : nat),
                   @eq.trans.{1} Prop
                     (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                        (@list.filter.{0} nat
                           (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                           (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                           (list.range x)) →
                      @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                     (@has_lt.lt.{0} nat nat.has_lt a x → true)
                     true
                     (@eq.trans.{1} Prop
                        (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                           (@list.filter.{0} nat
                              (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                              (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                              (list.range x)) →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x → true)
                        (@eq.trans.{1} Prop
                           (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                              (@list.filter.{0} nat
                                 (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                 (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                 (list.range x)) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (and (@has_lt.lt.{0} nat nat.has_lt a x)
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@imp_congr_eq
                              (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                 (@list.filter.{0} nat
                                    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                    (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                    (list.range x)))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@eq.trans.{1} Prop
                                 (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                    (@list.filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat),
                                          (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                       (list.range x)))
                                 (and (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s) a))
                                 (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                                 (@propext
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                       (@list.filter.{0} nat
                                          (λ (y : nat),
                                             @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          (λ (a : nat),
                                             (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                          (list.range x)))
                                    (and
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          a))
                                    (@list.mem_filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                       a
                                       (list.range x)))
                                 ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                   (e_2 : @eq.{1} Prop b b_1),
                                     @congr.{1 1} Prop Prop (and a) (and a_1) b b_1
                                       (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 and e_1)
                                       e_2)
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@propext
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       (@has_lt.lt.{0} nat nat.has_lt a x)
                                       (@list.mem_range a x))
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@eq.refl.{1} Prop
                                       (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                              (@eq.refl.{1} Prop (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))
                           (@propext
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@has_lt.lt.{0} nat nat.has_lt a x →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@and_imp (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                        (@imp_congr_eq (@has_lt.lt.{0} nat nat.has_lt a x)
                           (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x)
                           true
                           (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt a x))
                           (@propext
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              true
                              (@imp_self (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))))
                     (@propext (@has_lt.lt.{0} nat nat.has_lt a x → true) true
                        (@forall_true_iff.{0} (@has_lt.lt.{0} nat nat.has_lt a x)))))
             (@propext (nat → true) true (@forall_const.{1} true nat nat.inhabited))))
       trivial),
hmt :
  ∀ {y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s},
    iff
      (@has_mem.mem.{0 0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@list.has_mem.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         y
         t)
      (@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (@subtype.preorder.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@ordered_comm_monoid.to_partial_order.{0} nat
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                        (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
               (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
         y
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
wf :
  ∀ (m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
    @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
      (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@subtype.decidable_linear_order.{0} nat
            (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
            (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
         t)
      (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
            (@with_bot.has_coe_t.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)))
         m) →
    @has_lt.lt.{0} nat nat.has_lt
      (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
      x,
hmax :
  @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
    (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@subtype.decidable_linear_order.{0} nat
          (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
          (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
       t)
    (@option.none.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)),
h :
  @gt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@partial_order.to_preorder.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
          (@linear_order.to_partial_order.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
             (@subtype.linear_order.{0} nat nat.linear_order
                (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))))
    (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)
    (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 (@has_zero.zero.{0} nat nat.has_zero))
⊢ @has_mem.mem.{0 0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
    (@list.has_mem.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
    (@lattice.has_bot.bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@lattice.order_bot.to_has_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
          (@lattice.semilattice_sup_bot.to_order_bot.{0}
             (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
             (@lattice.nat.subtype.semilattice_sup_bot s (λ (a : nat), _inst_1 a)
                (@infinite.nonempty.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) _inst_2)))))
    (@list.nil.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.none
s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
of_nat_surjective_aux :
  ∀ {x : nat} (hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s),
    @Exists.{1} nat
      (λ (n : nat),
         @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
           (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
           (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
x : nat,
hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s,
t : list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) :=
  @list.pmap.{0 0} nat (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
    (λ (y : nat) (hy : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s),
       @subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y hy)
    (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
       (list.range x))
    (@eq.mpr.{0}
       (∀ (a : nat),
          @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
            (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
               (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
               (list.range x)) →
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
       true
       (@id.{0}
          (@eq.{1} Prop
             (∀ (a : nat),
                @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                  (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                     (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                     (list.range x)) →
                @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
             true)
          (@eq.trans.{1} Prop
             (∀ (x_1 : nat),
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                  x_1)
             (∀ (x : nat), (λ (a : nat), true) x)
             true
             (@forall_congr_eq.{1} nat
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                (λ (a : nat), true)
                (λ (a : nat),
                   @eq.trans.{1} Prop
                     (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                        (@list.filter.{0} nat
                           (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                           (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                           (list.range x)) →
                      @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                     (@has_lt.lt.{0} nat nat.has_lt a x → true)
                     true
                     (@eq.trans.{1} Prop
                        (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                           (@list.filter.{0} nat
                              (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                              (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                              (list.range x)) →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x → true)
                        (@eq.trans.{1} Prop
                           (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                              (@list.filter.{0} nat
                                 (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                 (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                 (list.range x)) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (and (@has_lt.lt.{0} nat nat.has_lt a x)
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@imp_congr_eq
                              (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                 (@list.filter.{0} nat
                                    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                    (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                    (list.range x)))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@eq.trans.{1} Prop
                                 (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                    (@list.filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat),
                                          (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                       (list.range x)))
                                 (and (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s) a))
                                 (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                                 (@propext
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                       (@list.filter.{0} nat
                                          (λ (y : nat),
                                             @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          (λ (a : nat),
                                             (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                          (list.range x)))
                                    (and
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          a))
                                    (@list.mem_filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                       a
                                       (list.range x)))
                                 ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                   (e_2 : @eq.{1} Prop b b_1),
                                     @congr.{1 1} Prop Prop (and a) (and a_1) b b_1
                                       (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 and e_1)
                                       e_2)
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@propext
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       (@has_lt.lt.{0} nat nat.has_lt a x)
                                       (@list.mem_range a x))
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@eq.refl.{1} Prop
                                       (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                              (@eq.refl.{1} Prop (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))
                           (@propext
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@has_lt.lt.{0} nat nat.has_lt a x →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@and_imp (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                        (@imp_congr_eq (@has_lt.lt.{0} nat nat.has_lt a x)
                           (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x)
                           true
                           (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt a x))
                           (@propext
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              true
                              (@imp_self (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))))
                     (@propext (@has_lt.lt.{0} nat nat.has_lt a x → true) true
                        (@forall_true_iff.{0} (@has_lt.lt.{0} nat nat.has_lt a x)))))
             (@propext (nat → true) true (@forall_const.{1} true nat nat.inhabited))))
       trivial),
hmt :
  ∀ {y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s},
    iff
      (@has_mem.mem.{0 0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@list.has_mem.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         y
         t)
      (@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (@subtype.preorder.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@ordered_comm_monoid.to_partial_order.{0} nat
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                        (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
               (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
         y
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
wf :
  ∀ (m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
    @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
      (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@subtype.decidable_linear_order.{0} nat
            (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
            (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
         t)
      (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
            (@with_bot.has_coe_t.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)))
         m) →
    @has_lt.lt.{0} nat nat.has_lt
      (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
      x,
hmax :
  @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
    (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@subtype.decidable_linear_order.{0} nat
          (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
          (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
       t)
    (@option.none.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
⊢ @Exists.{1} nat
    (λ (n : nat),
       @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.some
s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
of_nat_surjective_aux :
  ∀ {x : nat} (hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s),
    @Exists.{1} nat
      (λ (n : nat),
         @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
           (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
           (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
x : nat,
hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s,
t : list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) :=
  @list.pmap.{0 0} nat (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
    (λ (y : nat) (hy : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s),
       @subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y hy)
    (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
       (list.range x))
    (@eq.mpr.{0}
       (∀ (a : nat),
          @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
            (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
               (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
               (list.range x)) →
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
       true
       (@id.{0}
          (@eq.{1} Prop
             (∀ (a : nat),
                @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                  (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                     (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                     (list.range x)) →
                @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
             true)
          (@eq.trans.{1} Prop
             (∀ (x_1 : nat),
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                  x_1)
             (∀ (x : nat), (λ (a : nat), true) x)
             true
             (@forall_congr_eq.{1} nat
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                (λ (a : nat), true)
                (λ (a : nat),
                   @eq.trans.{1} Prop
                     (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                        (@list.filter.{0} nat
                           (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                           (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                           (list.range x)) →
                      @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                     (@has_lt.lt.{0} nat nat.has_lt a x → true)
                     true
                     (@eq.trans.{1} Prop
                        (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                           (@list.filter.{0} nat
                              (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                              (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                              (list.range x)) →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x → true)
                        (@eq.trans.{1} Prop
                           (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                              (@list.filter.{0} nat
                                 (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                 (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                 (list.range x)) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (and (@has_lt.lt.{0} nat nat.has_lt a x)
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@imp_congr_eq
                              (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                 (@list.filter.{0} nat
                                    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                    (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                    (list.range x)))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@eq.trans.{1} Prop
                                 (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                    (@list.filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat),
                                          (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                       (list.range x)))
                                 (and (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s) a))
                                 (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                                 (@propext
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                       (@list.filter.{0} nat
                                          (λ (y : nat),
                                             @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          (λ (a : nat),
                                             (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                          (list.range x)))
                                    (and
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          a))
                                    (@list.mem_filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                       a
                                       (list.range x)))
                                 ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                   (e_2 : @eq.{1} Prop b b_1),
                                     @congr.{1 1} Prop Prop (and a) (and a_1) b b_1
                                       (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 and e_1)
                                       e_2)
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@propext
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       (@has_lt.lt.{0} nat nat.has_lt a x)
                                       (@list.mem_range a x))
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@eq.refl.{1} Prop
                                       (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                              (@eq.refl.{1} Prop (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))
                           (@propext
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@has_lt.lt.{0} nat nat.has_lt a x →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@and_imp (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                        (@imp_congr_eq (@has_lt.lt.{0} nat nat.has_lt a x)
                           (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x)
                           true
                           (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt a x))
                           (@propext
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              true
                              (@imp_self (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))))
                     (@propext (@has_lt.lt.{0} nat nat.has_lt a x → true) true
                        (@forall_true_iff.{0} (@has_lt.lt.{0} nat nat.has_lt a x)))))
             (@propext (nat → true) true (@forall_const.{1} true nat nat.inhabited))))
       trivial),
hmt :
  ∀ {y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s},
    iff
      (@has_mem.mem.{0 0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@list.has_mem.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         y
         t)
      (@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (@subtype.preorder.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@ordered_comm_monoid.to_partial_order.{0} nat
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                        (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
               (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
         y
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
wf :
  ∀ (m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
    @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
      (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@subtype.decidable_linear_order.{0} nat
            (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
            (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
         t)
      (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
            (@with_bot.has_coe_t.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)))
         m) →
    @has_lt.lt.{0} nat nat.has_lt
      (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
      x,
m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s,
hmax :
  @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
    (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@subtype.decidable_linear_order.{0} nat
          (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
          (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
       t)
    (@option.some.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) m)
⊢ @Exists.{1} nat
    (λ (n : nat),
       @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>179    { cases of_nat_surjective_aux m.2 with a ha,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='of_nat_surjective_aux'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {x : nat} (hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s), @Exists.{1} nat (λ (n : nat), @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n) (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.some
s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
of_nat_surjective_aux :
  ∀ {x : nat} (hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s),
    @Exists.{1} nat
      (λ (n : nat),
         @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
           (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
           (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
x : nat,
hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s,
t : list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) :=
  @list.pmap.{0 0} nat (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
    (λ (y : nat) (hy : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s),
       @subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y hy)
    (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
       (list.range x))
    (@eq.mpr.{0}
       (∀ (a : nat),
          @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
            (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
               (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
               (list.range x)) →
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
       true
       (@id.{0}
          (@eq.{1} Prop
             (∀ (a : nat),
                @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                  (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                     (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                     (list.range x)) →
                @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
             true)
          (@eq.trans.{1} Prop
             (∀ (x_1 : nat),
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                  x_1)
             (∀ (x : nat), (λ (a : nat), true) x)
             true
             (@forall_congr_eq.{1} nat
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                (λ (a : nat), true)
                (λ (a : nat),
                   @eq.trans.{1} Prop
                     (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                        (@list.filter.{0} nat
                           (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                           (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                           (list.range x)) →
                      @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                     (@has_lt.lt.{0} nat nat.has_lt a x → true)
                     true
                     (@eq.trans.{1} Prop
                        (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                           (@list.filter.{0} nat
                              (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                              (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                              (list.range x)) →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x → true)
                        (@eq.trans.{1} Prop
                           (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                              (@list.filter.{0} nat
                                 (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                 (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                 (list.range x)) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (and (@has_lt.lt.{0} nat nat.has_lt a x)
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@imp_congr_eq
                              (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                 (@list.filter.{0} nat
                                    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                    (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                    (list.range x)))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@eq.trans.{1} Prop
                                 (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                    (@list.filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat),
                                          (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                       (list.range x)))
                                 (and (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s) a))
                                 (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                                 (@propext
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                       (@list.filter.{0} nat
                                          (λ (y : nat),
                                             @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          (λ (a : nat),
                                             (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                          (list.range x)))
                                    (and
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          a))
                                    (@list.mem_filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                       a
                                       (list.range x)))
                                 ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                   (e_2 : @eq.{1} Prop b b_1),
                                     @congr.{1 1} Prop Prop (and a) (and a_1) b b_1
                                       (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 and e_1)
                                       e_2)
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@propext
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       (@has_lt.lt.{0} nat nat.has_lt a x)
                                       (@list.mem_range a x))
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@eq.refl.{1} Prop
                                       (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                              (@eq.refl.{1} Prop (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))
                           (@propext
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@has_lt.lt.{0} nat nat.has_lt a x →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@and_imp (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                        (@imp_congr_eq (@has_lt.lt.{0} nat nat.has_lt a x)
                           (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x)
                           true
                           (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt a x))
                           (@propext
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              true
                              (@imp_self (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))))
                     (@propext (@has_lt.lt.{0} nat nat.has_lt a x → true) true
                        (@forall_true_iff.{0} (@has_lt.lt.{0} nat nat.has_lt a x)))))
             (@propext (nat → true) true (@forall_const.{1} true nat nat.inhabited))))
       trivial),
hmt :
  ∀ {y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s},
    iff
      (@has_mem.mem.{0 0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@list.has_mem.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         y
         t)
      (@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (@subtype.preorder.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@ordered_comm_monoid.to_partial_order.{0} nat
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                        (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
               (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
         y
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
wf :
  ∀ (m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
    @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
      (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@subtype.decidable_linear_order.{0} nat
            (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
            (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
         t)
      (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
            (@with_bot.has_coe_t.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)))
         m) →
    @has_lt.lt.{0} nat nat.has_lt
      (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
      x,
m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s,
hmax :
  @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
    (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@subtype.decidable_linear_order.{0} nat
          (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
          (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
       t)
    (@option.some.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) m)
⊢ @Exists.{1} nat
    (λ (n : nat),
       @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
of_nat_surjective_aux :
  ∀ {x : nat} (hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s),
    @Exists.{1} nat
      (λ (n : nat),
         @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
           (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
           (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
x : nat,
hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s,
t : list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) :=
  @list.pmap.{0 0} nat (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
    (λ (y : nat) (hy : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s),
       @subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y hy)
    (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
       (list.range x))
    (@eq.mpr.{0}
       (∀ (a : nat),
          @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
            (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
               (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
               (list.range x)) →
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
       true
       (@id.{0}
          (@eq.{1} Prop
             (∀ (a : nat),
                @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                  (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                     (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                     (list.range x)) →
                @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
             true)
          (@eq.trans.{1} Prop
             (∀ (x_1 : nat),
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                  x_1)
             (∀ (x : nat), (λ (a : nat), true) x)
             true
             (@forall_congr_eq.{1} nat
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                (λ (a : nat), true)
                (λ (a : nat),
                   @eq.trans.{1} Prop
                     (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                        (@list.filter.{0} nat
                           (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                           (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                           (list.range x)) →
                      @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                     (@has_lt.lt.{0} nat nat.has_lt a x → true)
                     true
                     (@eq.trans.{1} Prop
                        (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                           (@list.filter.{0} nat
                              (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                              (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                              (list.range x)) →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x → true)
                        (@eq.trans.{1} Prop
                           (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                              (@list.filter.{0} nat
                                 (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                 (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                 (list.range x)) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (and (@has_lt.lt.{0} nat nat.has_lt a x)
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@imp_congr_eq
                              (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                 (@list.filter.{0} nat
                                    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                    (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                    (list.range x)))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@eq.trans.{1} Prop
                                 (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                    (@list.filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat),
                                          (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                       (list.range x)))
                                 (and (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s) a))
                                 (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                                 (@propext
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                       (@list.filter.{0} nat
                                          (λ (y : nat),
                                             @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          (λ (a : nat),
                                             (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                          (list.range x)))
                                    (and
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          a))
                                    (@list.mem_filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                       a
                                       (list.range x)))
                                 ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                   (e_2 : @eq.{1} Prop b b_1),
                                     @congr.{1 1} Prop Prop (and a) (and a_1) b b_1
                                       (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 and e_1)
                                       e_2)
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@propext
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       (@has_lt.lt.{0} nat nat.has_lt a x)
                                       (@list.mem_range a x))
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@eq.refl.{1} Prop
                                       (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                              (@eq.refl.{1} Prop (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))
                           (@propext
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@has_lt.lt.{0} nat nat.has_lt a x →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@and_imp (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                        (@imp_congr_eq (@has_lt.lt.{0} nat nat.has_lt a x)
                           (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x)
                           true
                           (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt a x))
                           (@propext
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              true
                              (@imp_self (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))))
                     (@propext (@has_lt.lt.{0} nat nat.has_lt a x → true) true
                        (@forall_true_iff.{0} (@has_lt.lt.{0} nat nat.has_lt a x)))))
             (@propext (nat → true) true (@forall_const.{1} true nat nat.inhabited))))
       trivial),
hmt :
  ∀ {y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s},
    iff
      (@has_mem.mem.{0 0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@list.has_mem.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         y
         t)
      (@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (@subtype.preorder.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@ordered_comm_monoid.to_partial_order.{0} nat
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                        (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
               (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
         y
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
wf :
  ∀ (m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
    @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
      (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@subtype.decidable_linear_order.{0} nat
            (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
            (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
         t)
      (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
            (@with_bot.has_coe_t.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)))
         m) →
    @has_lt.lt.{0} nat nat.has_lt
      (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
      x,
m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s,
hmax :
  @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
    (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@subtype.decidable_linear_order.{0} nat
          (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
          (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
       t)
    (@option.some.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) m),
a : nat,
ha :
  @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 a)
    (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
       (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
       (@subtype.property.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m))
⊢ @Exists.{1} nat
    (λ (n : nat),
       @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>180      exact ⟨a + 1, le_antisymm</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='le_antisymm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : partial_order.{0} α] {a b : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α _inst_1)) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α _inst_1)) b a → @eq.{1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
of_nat_surjective_aux :
  ∀ {x : nat} (hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s),
    @Exists.{1} nat
      (λ (n : nat),
         @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
           (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
           (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
x : nat,
hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s,
t : list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) :=
  @list.pmap.{0 0} nat (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
    (λ (y : nat) (hy : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s),
       @subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y hy)
    (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
       (list.range x))
    (@eq.mpr.{0}
       (∀ (a : nat),
          @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
            (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
               (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
               (list.range x)) →
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
       true
       (@id.{0}
          (@eq.{1} Prop
             (∀ (a : nat),
                @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                  (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                     (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                     (list.range x)) →
                @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
             true)
          (@eq.trans.{1} Prop
             (∀ (x_1 : nat),
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                  x_1)
             (∀ (x : nat), (λ (a : nat), true) x)
             true
             (@forall_congr_eq.{1} nat
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                (λ (a : nat), true)
                (λ (a : nat),
                   @eq.trans.{1} Prop
                     (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                        (@list.filter.{0} nat
                           (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                           (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                           (list.range x)) →
                      @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                     (@has_lt.lt.{0} nat nat.has_lt a x → true)
                     true
                     (@eq.trans.{1} Prop
                        (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                           (@list.filter.{0} nat
                              (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                              (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                              (list.range x)) →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x → true)
                        (@eq.trans.{1} Prop
                           (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                              (@list.filter.{0} nat
                                 (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                 (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                 (list.range x)) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (and (@has_lt.lt.{0} nat nat.has_lt a x)
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@imp_congr_eq
                              (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                 (@list.filter.{0} nat
                                    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                    (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                    (list.range x)))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@eq.trans.{1} Prop
                                 (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                    (@list.filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat),
                                          (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                       (list.range x)))
                                 (and (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s) a))
                                 (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                                 (@propext
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                       (@list.filter.{0} nat
                                          (λ (y : nat),
                                             @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          (λ (a : nat),
                                             (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                          (list.range x)))
                                    (and
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          a))
                                    (@list.mem_filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                       a
                                       (list.range x)))
                                 ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                   (e_2 : @eq.{1} Prop b b_1),
                                     @congr.{1 1} Prop Prop (and a) (and a_1) b b_1
                                       (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 and e_1)
                                       e_2)
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@propext
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       (@has_lt.lt.{0} nat nat.has_lt a x)
                                       (@list.mem_range a x))
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@eq.refl.{1} Prop
                                       (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                              (@eq.refl.{1} Prop (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))
                           (@propext
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@has_lt.lt.{0} nat nat.has_lt a x →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@and_imp (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                        (@imp_congr_eq (@has_lt.lt.{0} nat nat.has_lt a x)
                           (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x)
                           true
                           (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt a x))
                           (@propext
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              true
                              (@imp_self (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))))
                     (@propext (@has_lt.lt.{0} nat nat.has_lt a x → true) true
                        (@forall_true_iff.{0} (@has_lt.lt.{0} nat nat.has_lt a x)))))
             (@propext (nat → true) true (@forall_const.{1} true nat nat.inhabited))))
       trivial),
hmt :
  ∀ {y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s},
    iff
      (@has_mem.mem.{0 0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@list.has_mem.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         y
         t)
      (@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (@subtype.preorder.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@ordered_comm_monoid.to_partial_order.{0} nat
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                        (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
               (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
         y
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
wf :
  ∀ (m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
    @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
      (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@subtype.decidable_linear_order.{0} nat
            (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
            (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
         t)
      (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
            (@with_bot.has_coe_t.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)))
         m) →
    @has_lt.lt.{0} nat nat.has_lt
      (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
      x,
m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s,
hmax :
  @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
    (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@subtype.decidable_linear_order.{0} nat
          (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
          (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
       t)
    (@option.some.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) m),
a : nat,
ha :
  @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 a)
    (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
       (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
       (@subtype.property.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m))
⊢ @Exists.{1} nat
    (λ (n : nat),
       @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>181        (by rw of_nat; exact succ_le_of_lt (by rw ha; exact wf _ hmax)) $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='nat.subtype.of_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='nat.subtype.succ_le_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='wf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hmax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 163, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (s : set.{0} nat) [_inst_3 : @decidable_pred.{1} nat s] [_inst_4 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)], nat → @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {s : set.{0} nat} [_inst_1 : @decidable_pred.{1} nat s] [_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)] {x y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s}, @has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@subtype.preorder.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))) y x → @has_le.le.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@preorder.to_has_le.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@subtype.preorder.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))) (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2 y) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 a) (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m) (@subtype.property.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s), @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)) (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@subtype.decidable_linear_order.{0} nat (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring) (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)) t) (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)) (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)) (@with_bot.has_coe_t.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))) m) → @has_lt.lt.{0} nat nat.has_lt (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)) (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@subtype.decidable_linear_order.{0} nat (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring) (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)) t) (@option.some.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
of_nat_surjective_aux :
  ∀ {x : nat} (hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s),
    @Exists.{1} nat
      (λ (n : nat),
         @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
           (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
           (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
x : nat,
hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s,
t : list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) :=
  @list.pmap.{0 0} nat (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
    (λ (y : nat) (hy : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s),
       @subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y hy)
    (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
       (list.range x))
    (@eq.mpr.{0}
       (∀ (a : nat),
          @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
            (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
               (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
               (list.range x)) →
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
       true
       (@id.{0}
          (@eq.{1} Prop
             (∀ (a : nat),
                @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                  (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                     (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                     (list.range x)) →
                @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
             true)
          (@eq.trans.{1} Prop
             (∀ (x_1 : nat),
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                  x_1)
             (∀ (x : nat), (λ (a : nat), true) x)
             true
             (@forall_congr_eq.{1} nat
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                (λ (a : nat), true)
                (λ (a : nat),
                   @eq.trans.{1} Prop
                     (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                        (@list.filter.{0} nat
                           (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                           (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                           (list.range x)) →
                      @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                     (@has_lt.lt.{0} nat nat.has_lt a x → true)
                     true
                     (@eq.trans.{1} Prop
                        (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                           (@list.filter.{0} nat
                              (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                              (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                              (list.range x)) →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x → true)
                        (@eq.trans.{1} Prop
                           (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                              (@list.filter.{0} nat
                                 (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                 (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                 (list.range x)) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (and (@has_lt.lt.{0} nat nat.has_lt a x)
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@imp_congr_eq
                              (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                 (@list.filter.{0} nat
                                    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                    (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                    (list.range x)))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@eq.trans.{1} Prop
                                 (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                    (@list.filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat),
                                          (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                       (list.range x)))
                                 (and (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s) a))
                                 (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                                 (@propext
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                       (@list.filter.{0} nat
                                          (λ (y : nat),
                                             @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          (λ (a : nat),
                                             (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                          (list.range x)))
                                    (and
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          a))
                                    (@list.mem_filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                       a
                                       (list.range x)))
                                 ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                   (e_2 : @eq.{1} Prop b b_1),
                                     @congr.{1 1} Prop Prop (and a) (and a_1) b b_1
                                       (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 and e_1)
                                       e_2)
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@propext
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       (@has_lt.lt.{0} nat nat.has_lt a x)
                                       (@list.mem_range a x))
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@eq.refl.{1} Prop
                                       (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                              (@eq.refl.{1} Prop (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))
                           (@propext
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@has_lt.lt.{0} nat nat.has_lt a x →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@and_imp (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                        (@imp_congr_eq (@has_lt.lt.{0} nat nat.has_lt a x)
                           (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x)
                           true
                           (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt a x))
                           (@propext
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              true
                              (@imp_self (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))))
                     (@propext (@has_lt.lt.{0} nat nat.has_lt a x → true) true
                        (@forall_true_iff.{0} (@has_lt.lt.{0} nat nat.has_lt a x)))))
             (@propext (nat → true) true (@forall_const.{1} true nat nat.inhabited))))
       trivial),
hmt :
  ∀ {y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s},
    iff
      (@has_mem.mem.{0 0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@list.has_mem.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         y
         t)
      (@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (@subtype.preorder.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@ordered_comm_monoid.to_partial_order.{0} nat
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                        (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
               (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
         y
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
wf :
  ∀ (m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
    @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
      (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@subtype.decidable_linear_order.{0} nat
            (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
            (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
         t)
      (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
            (@with_bot.has_coe_t.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)))
         m) →
    @has_lt.lt.{0} nat nat.has_lt
      (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
      x,
m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s,
hmax :
  @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
    (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@subtype.decidable_linear_order.{0} nat
          (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
          (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
       t)
    (@option.some.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) m),
a : nat,
ha :
  @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 a)
    (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
       (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
       (@subtype.property.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m))
⊢ @Exists.{1} nat
    (λ (n : nat),
       @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
of_nat_surjective_aux :
  ∀ {x : nat} (hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s),
    @Exists.{1} nat
      (λ (n : nat),
         @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
           (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
           (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
x : nat,
hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s,
t : list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) :=
  @list.pmap.{0 0} nat (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
    (λ (y : nat) (hy : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s),
       @subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y hy)
    (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
       (list.range x))
    (@eq.mpr.{0}
       (∀ (a : nat),
          @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
            (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
               (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
               (list.range x)) →
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
       true
       (@id.{0}
          (@eq.{1} Prop
             (∀ (a : nat),
                @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                  (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                     (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                     (list.range x)) →
                @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
             true)
          (@eq.trans.{1} Prop
             (∀ (x_1 : nat),
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                  x_1)
             (∀ (x : nat), (λ (a : nat), true) x)
             true
             (@forall_congr_eq.{1} nat
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                (λ (a : nat), true)
                (λ (a : nat),
                   @eq.trans.{1} Prop
                     (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                        (@list.filter.{0} nat
                           (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                           (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                           (list.range x)) →
                      @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                     (@has_lt.lt.{0} nat nat.has_lt a x → true)
                     true
                     (@eq.trans.{1} Prop
                        (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                           (@list.filter.{0} nat
                              (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                              (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                              (list.range x)) →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x → true)
                        (@eq.trans.{1} Prop
                           (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                              (@list.filter.{0} nat
                                 (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                 (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                 (list.range x)) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (and (@has_lt.lt.{0} nat nat.has_lt a x)
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@imp_congr_eq
                              (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                 (@list.filter.{0} nat
                                    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                    (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                    (list.range x)))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@eq.trans.{1} Prop
                                 (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                    (@list.filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat),
                                          (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                       (list.range x)))
                                 (and (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s) a))
                                 (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                                 (@propext
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                       (@list.filter.{0} nat
                                          (λ (y : nat),
                                             @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          (λ (a : nat),
                                             (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                          (list.range x)))
                                    (and
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          a))
                                    (@list.mem_filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                       a
                                       (list.range x)))
                                 ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                   (e_2 : @eq.{1} Prop b b_1),
                                     @congr.{1 1} Prop Prop (and a) (and a_1) b b_1
                                       (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 and e_1)
                                       e_2)
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@propext
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       (@has_lt.lt.{0} nat nat.has_lt a x)
                                       (@list.mem_range a x))
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@eq.refl.{1} Prop
                                       (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                              (@eq.refl.{1} Prop (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))
                           (@propext
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@has_lt.lt.{0} nat nat.has_lt a x →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@and_imp (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                        (@imp_congr_eq (@has_lt.lt.{0} nat nat.has_lt a x)
                           (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x)
                           true
                           (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt a x))
                           (@propext
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              true
                              (@imp_self (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))))
                     (@propext (@has_lt.lt.{0} nat nat.has_lt a x → true) true
                        (@forall_true_iff.{0} (@has_lt.lt.{0} nat nat.has_lt a x)))))
             (@propext (nat → true) true (@forall_const.{1} true nat nat.inhabited))))
       trivial),
hmt :
  ∀ {y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s},
    iff
      (@has_mem.mem.{0 0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@list.has_mem.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         y
         t)
      (@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (@subtype.preorder.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@ordered_comm_monoid.to_partial_order.{0} nat
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                        (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
               (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
         y
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
wf :
  ∀ (m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
    @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
      (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@subtype.decidable_linear_order.{0} nat
            (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
            (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
         t)
      (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
            (@with_bot.has_coe_t.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)))
         m) →
    @has_lt.lt.{0} nat nat.has_lt
      (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
      x,
m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s,
hmax :
  @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
    (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@subtype.decidable_linear_order.{0} nat
          (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
          (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
       t)
    (@option.some.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) m),
a : nat,
ha :
  @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 a)
    (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
       (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
       (@subtype.property.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m))
⊢ @has_le.le.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (@preorder.to_has_le.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@partial_order.to_preorder.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
          (@subtype.partial_order.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))
             (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
    (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2
       (@has_add.add.{0} nat nat.has_add a (@has_one.one.{0} nat nat.has_one)))
    (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
of_nat_surjective_aux :
  ∀ {x : nat} (hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s),
    @Exists.{1} nat
      (λ (n : nat),
         @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
           (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
           (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
x : nat,
hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s,
t : list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) :=
  @list.pmap.{0 0} nat (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
    (λ (y : nat) (hy : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s),
       @subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y hy)
    (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
       (list.range x))
    (@eq.mpr.{0}
       (∀ (a : nat),
          @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
            (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
               (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
               (list.range x)) →
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
       true
       (@id.{0}
          (@eq.{1} Prop
             (∀ (a : nat),
                @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                  (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                     (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                     (list.range x)) →
                @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
             true)
          (@eq.trans.{1} Prop
             (∀ (x_1 : nat),
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                  x_1)
             (∀ (x : nat), (λ (a : nat), true) x)
             true
             (@forall_congr_eq.{1} nat
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                (λ (a : nat), true)
                (λ (a : nat),
                   @eq.trans.{1} Prop
                     (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                        (@list.filter.{0} nat
                           (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                           (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                           (list.range x)) →
                      @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                     (@has_lt.lt.{0} nat nat.has_lt a x → true)
                     true
                     (@eq.trans.{1} Prop
                        (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                           (@list.filter.{0} nat
                              (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                              (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                              (list.range x)) →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x → true)
                        (@eq.trans.{1} Prop
                           (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                              (@list.filter.{0} nat
                                 (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                 (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                 (list.range x)) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (and (@has_lt.lt.{0} nat nat.has_lt a x)
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@imp_congr_eq
                              (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                 (@list.filter.{0} nat
                                    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                    (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                    (list.range x)))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@eq.trans.{1} Prop
                                 (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                    (@list.filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat),
                                          (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                       (list.range x)))
                                 (and (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s) a))
                                 (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                                 (@propext
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                       (@list.filter.{0} nat
                                          (λ (y : nat),
                                             @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          (λ (a : nat),
                                             (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                          (list.range x)))
                                    (and
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          a))
                                    (@list.mem_filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                       a
                                       (list.range x)))
                                 ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                   (e_2 : @eq.{1} Prop b b_1),
                                     @congr.{1 1} Prop Prop (and a) (and a_1) b b_1
                                       (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 and e_1)
                                       e_2)
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@propext
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       (@has_lt.lt.{0} nat nat.has_lt a x)
                                       (@list.mem_range a x))
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@eq.refl.{1} Prop
                                       (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                              (@eq.refl.{1} Prop (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))
                           (@propext
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@has_lt.lt.{0} nat nat.has_lt a x →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@and_imp (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                        (@imp_congr_eq (@has_lt.lt.{0} nat nat.has_lt a x)
                           (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x)
                           true
                           (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt a x))
                           (@propext
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              true
                              (@imp_self (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))))
                     (@propext (@has_lt.lt.{0} nat nat.has_lt a x → true) true
                        (@forall_true_iff.{0} (@has_lt.lt.{0} nat nat.has_lt a x)))))
             (@propext (nat → true) true (@forall_const.{1} true nat nat.inhabited))))
       trivial),
hmt :
  ∀ {y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s},
    iff
      (@has_mem.mem.{0 0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@list.has_mem.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         y
         t)
      (@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (@subtype.preorder.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@ordered_comm_monoid.to_partial_order.{0} nat
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                        (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
               (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
         y
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
wf :
  ∀ (m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
    @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
      (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@subtype.decidable_linear_order.{0} nat
            (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
            (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
         t)
      (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
            (@with_bot.has_coe_t.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)))
         m) →
    @has_lt.lt.{0} nat nat.has_lt
      (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
      x,
m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s,
hmax :
  @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
    (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@subtype.decidable_linear_order.{0} nat
          (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
          (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
       t)
    (@option.some.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) m),
a : nat,
ha :
  @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 a)
    (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
       (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
       (@subtype.property.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m))
⊢ @has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@subtype.preorder.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
          (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
    (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 a)
    (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
of_nat_surjective_aux :
  ∀ {x : nat} (hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s),
    @Exists.{1} nat
      (λ (n : nat),
         @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
           (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
           (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
x : nat,
hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s,
t : list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) :=
  @list.pmap.{0 0} nat (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
    (λ (y : nat) (hy : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s),
       @subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y hy)
    (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
       (list.range x))
    (@eq.mpr.{0}
       (∀ (a : nat),
          @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
            (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
               (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
               (list.range x)) →
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
       true
       (@id.{0}
          (@eq.{1} Prop
             (∀ (a : nat),
                @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                  (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                     (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                     (list.range x)) →
                @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
             true)
          (@eq.trans.{1} Prop
             (∀ (x_1 : nat),
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                  x_1)
             (∀ (x : nat), (λ (a : nat), true) x)
             true
             (@forall_congr_eq.{1} nat
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                (λ (a : nat), true)
                (λ (a : nat),
                   @eq.trans.{1} Prop
                     (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                        (@list.filter.{0} nat
                           (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                           (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                           (list.range x)) →
                      @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                     (@has_lt.lt.{0} nat nat.has_lt a x → true)
                     true
                     (@eq.trans.{1} Prop
                        (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                           (@list.filter.{0} nat
                              (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                              (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                              (list.range x)) →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x → true)
                        (@eq.trans.{1} Prop
                           (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                              (@list.filter.{0} nat
                                 (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                 (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                 (list.range x)) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (and (@has_lt.lt.{0} nat nat.has_lt a x)
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@imp_congr_eq
                              (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                 (@list.filter.{0} nat
                                    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                    (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                    (list.range x)))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@eq.trans.{1} Prop
                                 (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                    (@list.filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat),
                                          (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                       (list.range x)))
                                 (and (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s) a))
                                 (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                                 (@propext
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                       (@list.filter.{0} nat
                                          (λ (y : nat),
                                             @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          (λ (a : nat),
                                             (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                          (list.range x)))
                                    (and
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          a))
                                    (@list.mem_filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                       a
                                       (list.range x)))
                                 ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                   (e_2 : @eq.{1} Prop b b_1),
                                     @congr.{1 1} Prop Prop (and a) (and a_1) b b_1
                                       (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 and e_1)
                                       e_2)
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@propext
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       (@has_lt.lt.{0} nat nat.has_lt a x)
                                       (@list.mem_range a x))
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@eq.refl.{1} Prop
                                       (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                              (@eq.refl.{1} Prop (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))
                           (@propext
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@has_lt.lt.{0} nat nat.has_lt a x →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@and_imp (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                        (@imp_congr_eq (@has_lt.lt.{0} nat nat.has_lt a x)
                           (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x)
                           true
                           (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt a x))
                           (@propext
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              true
                              (@imp_self (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))))
                     (@propext (@has_lt.lt.{0} nat nat.has_lt a x → true) true
                        (@forall_true_iff.{0} (@has_lt.lt.{0} nat nat.has_lt a x)))))
             (@propext (nat → true) true (@forall_const.{1} true nat nat.inhabited))))
       trivial),
hmt :
  ∀ {y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s},
    iff
      (@has_mem.mem.{0 0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@list.has_mem.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         y
         t)
      (@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (@subtype.preorder.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@ordered_comm_monoid.to_partial_order.{0} nat
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                        (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
               (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
         y
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
wf :
  ∀ (m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
    @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
      (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@subtype.decidable_linear_order.{0} nat
            (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
            (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
         t)
      (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
            (@with_bot.has_coe_t.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)))
         m) →
    @has_lt.lt.{0} nat nat.has_lt
      (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
      x,
m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s,
hmax :
  @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
    (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@subtype.decidable_linear_order.{0} nat
          (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
          (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
       t)
    (@option.some.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) m),
a : nat,
ha :
  @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 a)
    (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
       (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
       (@subtype.property.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m))
⊢ @has_le.le.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (@preorder.to_has_le.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@partial_order.to_preorder.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
          (@subtype.partial_order.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))
             (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
    (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2
       (@has_add.add.{0} nat nat.has_add a (@has_one.one.{0} nat nat.has_one)))
    (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
of_nat_surjective_aux :
  ∀ {x : nat} (hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s),
    @Exists.{1} nat
      (λ (n : nat),
         @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
           (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
           (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
x : nat,
hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s,
t : list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) :=
  @list.pmap.{0 0} nat (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
    (λ (y : nat) (hy : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s),
       @subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y hy)
    (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
       (list.range x))
    (@eq.mpr.{0}
       (∀ (a : nat),
          @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
            (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
               (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
               (list.range x)) →
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
       true
       (@id.{0}
          (@eq.{1} Prop
             (∀ (a : nat),
                @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                  (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                     (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                     (list.range x)) →
                @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
             true)
          (@eq.trans.{1} Prop
             (∀ (x_1 : nat),
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                  x_1)
             (∀ (x : nat), (λ (a : nat), true) x)
             true
             (@forall_congr_eq.{1} nat
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                (λ (a : nat), true)
                (λ (a : nat),
                   @eq.trans.{1} Prop
                     (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                        (@list.filter.{0} nat
                           (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                           (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                           (list.range x)) →
                      @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                     (@has_lt.lt.{0} nat nat.has_lt a x → true)
                     true
                     (@eq.trans.{1} Prop
                        (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                           (@list.filter.{0} nat
                              (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                              (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                              (list.range x)) →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x → true)
                        (@eq.trans.{1} Prop
                           (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                              (@list.filter.{0} nat
                                 (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                 (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                 (list.range x)) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (and (@has_lt.lt.{0} nat nat.has_lt a x)
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@imp_congr_eq
                              (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                 (@list.filter.{0} nat
                                    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                    (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                    (list.range x)))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@eq.trans.{1} Prop
                                 (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                    (@list.filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat),
                                          (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                       (list.range x)))
                                 (and (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s) a))
                                 (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                                 (@propext
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                       (@list.filter.{0} nat
                                          (λ (y : nat),
                                             @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          (λ (a : nat),
                                             (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                          (list.range x)))
                                    (and
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          a))
                                    (@list.mem_filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                       a
                                       (list.range x)))
                                 ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                   (e_2 : @eq.{1} Prop b b_1),
                                     @congr.{1 1} Prop Prop (and a) (and a_1) b b_1
                                       (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 and e_1)
                                       e_2)
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@propext
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       (@has_lt.lt.{0} nat nat.has_lt a x)
                                       (@list.mem_range a x))
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@eq.refl.{1} Prop
                                       (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                              (@eq.refl.{1} Prop (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))
                           (@propext
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@has_lt.lt.{0} nat nat.has_lt a x →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@and_imp (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                        (@imp_congr_eq (@has_lt.lt.{0} nat nat.has_lt a x)
                           (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x)
                           true
                           (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt a x))
                           (@propext
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              true
                              (@imp_self (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))))
                     (@propext (@has_lt.lt.{0} nat nat.has_lt a x → true) true
                        (@forall_true_iff.{0} (@has_lt.lt.{0} nat nat.has_lt a x)))))
             (@propext (nat → true) true (@forall_const.{1} true nat nat.inhabited))))
       trivial),
hmt :
  ∀ {y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s},
    iff
      (@has_mem.mem.{0 0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@list.has_mem.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         y
         t)
      (@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (@subtype.preorder.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@ordered_comm_monoid.to_partial_order.{0} nat
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                        (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
               (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
         y
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
wf :
  ∀ (m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
    @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
      (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@subtype.decidable_linear_order.{0} nat
            (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
            (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
         t)
      (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
            (@with_bot.has_coe_t.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)))
         m) →
    @has_lt.lt.{0} nat nat.has_lt
      (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
      x,
m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s,
hmax :
  @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
    (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@subtype.decidable_linear_order.{0} nat
          (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
          (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
       t)
    (@option.some.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) m),
a : nat,
ha :
  @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 a)
    (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
       (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
       (@subtype.property.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m))
⊢ @Exists.{1} nat
    (λ (n : nat),
       @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>182        by rw of_nat; exact le_succ_of_forall_lt_le</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='nat.subtype.of_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='nat.subtype.le_succ_of_forall_lt_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 163, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 146, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (s : set.{0} nat) [_inst_3 : @decidable_pred.{1} nat s] [_inst_4 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)], nat → @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {s : set.{0} nat} [_inst_1 : @decidable_pred.{1} nat s] [_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)] {x y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s}, (∀ (z : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s), @has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@subtype.preorder.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))) z x → @has_le.le.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@preorder.to_has_le.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@subtype.preorder.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))) z y) → @has_le.le.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@preorder.to_has_le.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@subtype.preorder.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))) x (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2 y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
of_nat_surjective_aux :
  ∀ {x : nat} (hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s),
    @Exists.{1} nat
      (λ (n : nat),
         @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
           (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
           (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
x : nat,
hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s,
t : list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) :=
  @list.pmap.{0 0} nat (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
    (λ (y : nat) (hy : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s),
       @subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y hy)
    (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
       (list.range x))
    (@eq.mpr.{0}
       (∀ (a : nat),
          @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
            (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
               (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
               (list.range x)) →
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
       true
       (@id.{0}
          (@eq.{1} Prop
             (∀ (a : nat),
                @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                  (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                     (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                     (list.range x)) →
                @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
             true)
          (@eq.trans.{1} Prop
             (∀ (x_1 : nat),
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                  x_1)
             (∀ (x : nat), (λ (a : nat), true) x)
             true
             (@forall_congr_eq.{1} nat
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                (λ (a : nat), true)
                (λ (a : nat),
                   @eq.trans.{1} Prop
                     (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                        (@list.filter.{0} nat
                           (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                           (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                           (list.range x)) →
                      @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                     (@has_lt.lt.{0} nat nat.has_lt a x → true)
                     true
                     (@eq.trans.{1} Prop
                        (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                           (@list.filter.{0} nat
                              (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                              (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                              (list.range x)) →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x → true)
                        (@eq.trans.{1} Prop
                           (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                              (@list.filter.{0} nat
                                 (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                 (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                 (list.range x)) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (and (@has_lt.lt.{0} nat nat.has_lt a x)
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@imp_congr_eq
                              (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                 (@list.filter.{0} nat
                                    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                    (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                    (list.range x)))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@eq.trans.{1} Prop
                                 (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                    (@list.filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat),
                                          (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                       (list.range x)))
                                 (and (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s) a))
                                 (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                                 (@propext
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                       (@list.filter.{0} nat
                                          (λ (y : nat),
                                             @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          (λ (a : nat),
                                             (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                          (list.range x)))
                                    (and
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          a))
                                    (@list.mem_filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                       a
                                       (list.range x)))
                                 ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                   (e_2 : @eq.{1} Prop b b_1),
                                     @congr.{1 1} Prop Prop (and a) (and a_1) b b_1
                                       (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 and e_1)
                                       e_2)
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@propext
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       (@has_lt.lt.{0} nat nat.has_lt a x)
                                       (@list.mem_range a x))
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@eq.refl.{1} Prop
                                       (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                              (@eq.refl.{1} Prop (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))
                           (@propext
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@has_lt.lt.{0} nat nat.has_lt a x →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@and_imp (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                        (@imp_congr_eq (@has_lt.lt.{0} nat nat.has_lt a x)
                           (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x)
                           true
                           (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt a x))
                           (@propext
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              true
                              (@imp_self (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))))
                     (@propext (@has_lt.lt.{0} nat nat.has_lt a x → true) true
                        (@forall_true_iff.{0} (@has_lt.lt.{0} nat nat.has_lt a x)))))
             (@propext (nat → true) true (@forall_const.{1} true nat nat.inhabited))))
       trivial),
hmt :
  ∀ {y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s},
    iff
      (@has_mem.mem.{0 0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@list.has_mem.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         y
         t)
      (@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (@subtype.preorder.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@ordered_comm_monoid.to_partial_order.{0} nat
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                        (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
               (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
         y
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
wf :
  ∀ (m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
    @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
      (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@subtype.decidable_linear_order.{0} nat
            (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
            (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
         t)
      (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
            (@with_bot.has_coe_t.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)))
         m) →
    @has_lt.lt.{0} nat nat.has_lt
      (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
      x,
m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s,
hmax :
  @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
    (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@subtype.decidable_linear_order.{0} nat
          (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
          (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
       t)
    (@option.some.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) m),
a : nat,
ha :
  @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 a)
    (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
       (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
       (@subtype.property.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m))
⊢ @Exists.{1} nat
    (λ (n : nat),
       @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
of_nat_surjective_aux :
  ∀ {x : nat} (hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s),
    @Exists.{1} nat
      (λ (n : nat),
         @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
           (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
           (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
x : nat,
hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s,
t : list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) :=
  @list.pmap.{0 0} nat (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
    (λ (y : nat) (hy : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s),
       @subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y hy)
    (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
       (list.range x))
    (@eq.mpr.{0}
       (∀ (a : nat),
          @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
            (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
               (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
               (list.range x)) →
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
       true
       (@id.{0}
          (@eq.{1} Prop
             (∀ (a : nat),
                @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                  (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                     (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                     (list.range x)) →
                @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
             true)
          (@eq.trans.{1} Prop
             (∀ (x_1 : nat),
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                  x_1)
             (∀ (x : nat), (λ (a : nat), true) x)
             true
             (@forall_congr_eq.{1} nat
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                (λ (a : nat), true)
                (λ (a : nat),
                   @eq.trans.{1} Prop
                     (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                        (@list.filter.{0} nat
                           (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                           (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                           (list.range x)) →
                      @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                     (@has_lt.lt.{0} nat nat.has_lt a x → true)
                     true
                     (@eq.trans.{1} Prop
                        (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                           (@list.filter.{0} nat
                              (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                              (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                              (list.range x)) →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x → true)
                        (@eq.trans.{1} Prop
                           (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                              (@list.filter.{0} nat
                                 (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                 (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                 (list.range x)) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (and (@has_lt.lt.{0} nat nat.has_lt a x)
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@imp_congr_eq
                              (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                 (@list.filter.{0} nat
                                    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                    (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                    (list.range x)))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@eq.trans.{1} Prop
                                 (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                    (@list.filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat),
                                          (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                       (list.range x)))
                                 (and (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s) a))
                                 (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                                 (@propext
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                       (@list.filter.{0} nat
                                          (λ (y : nat),
                                             @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          (λ (a : nat),
                                             (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                          (list.range x)))
                                    (and
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          a))
                                    (@list.mem_filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                       a
                                       (list.range x)))
                                 ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                   (e_2 : @eq.{1} Prop b b_1),
                                     @congr.{1 1} Prop Prop (and a) (and a_1) b b_1
                                       (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 and e_1)
                                       e_2)
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@propext
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       (@has_lt.lt.{0} nat nat.has_lt a x)
                                       (@list.mem_range a x))
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@eq.refl.{1} Prop
                                       (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                              (@eq.refl.{1} Prop (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))
                           (@propext
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@has_lt.lt.{0} nat nat.has_lt a x →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@and_imp (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                        (@imp_congr_eq (@has_lt.lt.{0} nat nat.has_lt a x)
                           (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x)
                           true
                           (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt a x))
                           (@propext
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              true
                              (@imp_self (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))))
                     (@propext (@has_lt.lt.{0} nat nat.has_lt a x → true) true
                        (@forall_true_iff.{0} (@has_lt.lt.{0} nat nat.has_lt a x)))))
             (@propext (nat → true) true (@forall_const.{1} true nat nat.inhabited))))
       trivial),
hmt :
  ∀ {y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s},
    iff
      (@has_mem.mem.{0 0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@list.has_mem.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         y
         t)
      (@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (@subtype.preorder.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@ordered_comm_monoid.to_partial_order.{0} nat
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                        (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
               (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
         y
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
wf :
  ∀ (m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
    @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
      (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@subtype.decidable_linear_order.{0} nat
            (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
            (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
         t)
      (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
            (@with_bot.has_coe_t.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)))
         m) →
    @has_lt.lt.{0} nat nat.has_lt
      (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
      x,
m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s,
hmax :
  @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
    (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@subtype.decidable_linear_order.{0} nat
          (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
          (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
       t)
    (@option.some.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) m),
a : nat,
ha :
  @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 a)
    (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
       (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
       (@subtype.property.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m))
⊢ @has_le.le.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (@preorder.to_has_le.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@partial_order.to_preorder.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
          (@subtype.partial_order.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))
             (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
    (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)
    (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2
       (@has_add.add.{0} nat nat.has_add a (@has_one.one.{0} nat nat.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>183          (λ z hz, by rw ha; cases m; exact list.le_maximum_of_mem (hmt.2 hz) hmax)⟩ }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='list.le_maximum_of_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hmt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hz'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hmax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/min_max.lean&#x27;, &#x27;line&#x27;: 222, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 a) (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m) (@subtype.property.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_2 : decidable_linear_order.{0} α] {a m : α} {l : list.{0} α}, @has_mem.mem.{0 0} α (list.{0} α) (@list.has_mem.{0} α) a l → @eq.{1} (with_bot.{0} α) (@list.maximum.{0} α _inst_2 l) (@coe.{1 1} α (with_bot.{0} α) (@coe_to_lift.{1 1} α (with_bot.{0} α) (@with_bot.has_coe_t.{0} α)) m) → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.semilattice_inf.to_partial_order.{0} α (@lattice.lattice.to_semilattice_inf.{0} α (@lattice.lattice_of_decidable_linear_order.{0} α _inst_2))))) a m'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s}, iff (@has_mem.mem.{0 0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)) (@list.has_mem.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)) y t) (@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@subtype.preorder.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))) y (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@subtype.preorder.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))) z (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)) (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@subtype.decidable_linear_order.{0} nat (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring) (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)) t) (@option.some.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m_val m_property))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
of_nat_surjective_aux :
  ∀ {x : nat} (hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s),
    @Exists.{1} nat
      (λ (n : nat),
         @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
           (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
           (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
x : nat,
hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s,
t : list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) :=
  @list.pmap.{0 0} nat (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
    (λ (y : nat) (hy : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s),
       @subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y hy)
    (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
       (list.range x))
    (@eq.mpr.{0}
       (∀ (a : nat),
          @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
            (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
               (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
               (list.range x)) →
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
       true
       (@id.{0}
          (@eq.{1} Prop
             (∀ (a : nat),
                @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                  (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                     (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                     (list.range x)) →
                @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
             true)
          (@eq.trans.{1} Prop
             (∀ (x_1 : nat),
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                  x_1)
             (∀ (x : nat), (λ (a : nat), true) x)
             true
             (@forall_congr_eq.{1} nat
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                (λ (a : nat), true)
                (λ (a : nat),
                   @eq.trans.{1} Prop
                     (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                        (@list.filter.{0} nat
                           (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                           (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                           (list.range x)) →
                      @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                     (@has_lt.lt.{0} nat nat.has_lt a x → true)
                     true
                     (@eq.trans.{1} Prop
                        (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                           (@list.filter.{0} nat
                              (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                              (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                              (list.range x)) →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x → true)
                        (@eq.trans.{1} Prop
                           (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                              (@list.filter.{0} nat
                                 (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                 (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                 (list.range x)) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (and (@has_lt.lt.{0} nat nat.has_lt a x)
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@imp_congr_eq
                              (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                 (@list.filter.{0} nat
                                    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                    (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                    (list.range x)))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@eq.trans.{1} Prop
                                 (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                    (@list.filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat),
                                          (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                       (list.range x)))
                                 (and (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s) a))
                                 (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                                 (@propext
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                       (@list.filter.{0} nat
                                          (λ (y : nat),
                                             @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          (λ (a : nat),
                                             (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                          (list.range x)))
                                    (and
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          a))
                                    (@list.mem_filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                       a
                                       (list.range x)))
                                 ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                   (e_2 : @eq.{1} Prop b b_1),
                                     @congr.{1 1} Prop Prop (and a) (and a_1) b b_1
                                       (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 and e_1)
                                       e_2)
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@propext
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       (@has_lt.lt.{0} nat nat.has_lt a x)
                                       (@list.mem_range a x))
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@eq.refl.{1} Prop
                                       (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                              (@eq.refl.{1} Prop (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))
                           (@propext
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@has_lt.lt.{0} nat nat.has_lt a x →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@and_imp (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                        (@imp_congr_eq (@has_lt.lt.{0} nat nat.has_lt a x)
                           (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x)
                           true
                           (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt a x))
                           (@propext
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              true
                              (@imp_self (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))))
                     (@propext (@has_lt.lt.{0} nat nat.has_lt a x → true) true
                        (@forall_true_iff.{0} (@has_lt.lt.{0} nat nat.has_lt a x)))))
             (@propext (nat → true) true (@forall_const.{1} true nat nat.inhabited))))
       trivial),
hmt :
  ∀ {y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s},
    iff
      (@has_mem.mem.{0 0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@list.has_mem.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         y
         t)
      (@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (@subtype.preorder.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@ordered_comm_monoid.to_partial_order.{0} nat
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                        (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
               (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
         y
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
wf :
  ∀ (m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
    @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
      (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@subtype.decidable_linear_order.{0} nat
            (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
            (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
         t)
      (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
            (@with_bot.has_coe_t.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)))
         m) →
    @has_lt.lt.{0} nat nat.has_lt
      (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
      x,
m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s,
hmax :
  @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
    (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@subtype.decidable_linear_order.{0} nat
          (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
          (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
       t)
    (@option.some.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) m),
a : nat,
ha :
  @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 a)
    (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
       (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
       (@subtype.property.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m))
⊢ @has_le.le.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (@preorder.to_has_le.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@partial_order.to_preorder.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
          (@subtype.partial_order.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))
             (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
    (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)
    (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2
       (@has_add.add.{0} nat nat.has_add a (@has_one.one.{0} nat nat.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
of_nat_surjective_aux :
  ∀ {x : nat} (hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s),
    @Exists.{1} nat
      (λ (n : nat),
         @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
           (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
           (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
x : nat,
hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s,
t : list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) :=
  @list.pmap.{0 0} nat (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
    (λ (y : nat) (hy : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s),
       @subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y hy)
    (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
       (list.range x))
    (@eq.mpr.{0}
       (∀ (a : nat),
          @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
            (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
               (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
               (list.range x)) →
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
       true
       (@id.{0}
          (@eq.{1} Prop
             (∀ (a : nat),
                @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                  (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                     (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                     (list.range x)) →
                @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
             true)
          (@eq.trans.{1} Prop
             (∀ (x_1 : nat),
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                  x_1)
             (∀ (x : nat), (λ (a : nat), true) x)
             true
             (@forall_congr_eq.{1} nat
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                (λ (a : nat), true)
                (λ (a : nat),
                   @eq.trans.{1} Prop
                     (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                        (@list.filter.{0} nat
                           (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                           (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                           (list.range x)) →
                      @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                     (@has_lt.lt.{0} nat nat.has_lt a x → true)
                     true
                     (@eq.trans.{1} Prop
                        (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                           (@list.filter.{0} nat
                              (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                              (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                              (list.range x)) →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x → true)
                        (@eq.trans.{1} Prop
                           (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                              (@list.filter.{0} nat
                                 (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                 (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                 (list.range x)) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (and (@has_lt.lt.{0} nat nat.has_lt a x)
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@imp_congr_eq
                              (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                 (@list.filter.{0} nat
                                    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                    (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                    (list.range x)))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@eq.trans.{1} Prop
                                 (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                    (@list.filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat),
                                          (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                       (list.range x)))
                                 (and (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s) a))
                                 (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                                 (@propext
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                       (@list.filter.{0} nat
                                          (λ (y : nat),
                                             @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          (λ (a : nat),
                                             (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                          (list.range x)))
                                    (and
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          a))
                                    (@list.mem_filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                       a
                                       (list.range x)))
                                 ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                   (e_2 : @eq.{1} Prop b b_1),
                                     @congr.{1 1} Prop Prop (and a) (and a_1) b b_1
                                       (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 and e_1)
                                       e_2)
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@propext
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       (@has_lt.lt.{0} nat nat.has_lt a x)
                                       (@list.mem_range a x))
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@eq.refl.{1} Prop
                                       (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                              (@eq.refl.{1} Prop (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))
                           (@propext
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@has_lt.lt.{0} nat nat.has_lt a x →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@and_imp (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                        (@imp_congr_eq (@has_lt.lt.{0} nat nat.has_lt a x)
                           (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x)
                           true
                           (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt a x))
                           (@propext
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              true
                              (@imp_self (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))))
                     (@propext (@has_lt.lt.{0} nat nat.has_lt a x → true) true
                        (@forall_true_iff.{0} (@has_lt.lt.{0} nat nat.has_lt a x)))))
             (@propext (nat → true) true (@forall_const.{1} true nat nat.inhabited))))
       trivial),
hmt :
  ∀ {y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s},
    iff
      (@has_mem.mem.{0 0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@list.has_mem.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         y
         t)
      (@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (@subtype.preorder.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@ordered_comm_monoid.to_partial_order.{0} nat
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                        (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
               (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
         y
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
wf :
  ∀ (m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
    @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
      (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@subtype.decidable_linear_order.{0} nat
            (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
            (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
         t)
      (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
            (@with_bot.has_coe_t.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)))
         m) →
    @has_lt.lt.{0} nat nat.has_lt
      (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
      x,
m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s,
hmax :
  @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
    (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@subtype.decidable_linear_order.{0} nat
          (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
          (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
       t)
    (@option.some.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) m),
a : nat,
ha :
  @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 a)
    (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
       (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
       (@subtype.property.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)),
z : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s,
hz :
  @has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@subtype.preorder.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
          (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
    z
    (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)
⊢ @has_le.le.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (@preorder.to_has_le.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@subtype.preorder.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
          (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
    z
    (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
of_nat_surjective_aux :
  ∀ {x : nat} (hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s),
    @Exists.{1} nat
      (λ (n : nat),
         @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
           (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
           (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
x : nat,
hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s,
t : list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) :=
  @list.pmap.{0 0} nat (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
    (λ (y : nat) (hy : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s),
       @subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y hy)
    (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
       (list.range x))
    (@eq.mpr.{0}
       (∀ (a : nat),
          @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
            (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
               (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
               (list.range x)) →
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
       true
       (@id.{0}
          (@eq.{1} Prop
             (∀ (a : nat),
                @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                  (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                     (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                     (list.range x)) →
                @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
             true)
          (@eq.trans.{1} Prop
             (∀ (x_1 : nat),
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                  x_1)
             (∀ (x : nat), (λ (a : nat), true) x)
             true
             (@forall_congr_eq.{1} nat
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                (λ (a : nat), true)
                (λ (a : nat),
                   @eq.trans.{1} Prop
                     (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                        (@list.filter.{0} nat
                           (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                           (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                           (list.range x)) →
                      @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                     (@has_lt.lt.{0} nat nat.has_lt a x → true)
                     true
                     (@eq.trans.{1} Prop
                        (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                           (@list.filter.{0} nat
                              (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                              (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                              (list.range x)) →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x → true)
                        (@eq.trans.{1} Prop
                           (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                              (@list.filter.{0} nat
                                 (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                 (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                 (list.range x)) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (and (@has_lt.lt.{0} nat nat.has_lt a x)
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@imp_congr_eq
                              (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                 (@list.filter.{0} nat
                                    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                    (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                    (list.range x)))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@eq.trans.{1} Prop
                                 (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                    (@list.filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat),
                                          (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                       (list.range x)))
                                 (and (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s) a))
                                 (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                                 (@propext
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                       (@list.filter.{0} nat
                                          (λ (y : nat),
                                             @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          (λ (a : nat),
                                             (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                          (list.range x)))
                                    (and
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          a))
                                    (@list.mem_filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                       a
                                       (list.range x)))
                                 ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                   (e_2 : @eq.{1} Prop b b_1),
                                     @congr.{1 1} Prop Prop (and a) (and a_1) b b_1
                                       (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 and e_1)
                                       e_2)
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@propext
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       (@has_lt.lt.{0} nat nat.has_lt a x)
                                       (@list.mem_range a x))
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@eq.refl.{1} Prop
                                       (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                              (@eq.refl.{1} Prop (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))
                           (@propext
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@has_lt.lt.{0} nat nat.has_lt a x →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@and_imp (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                        (@imp_congr_eq (@has_lt.lt.{0} nat nat.has_lt a x)
                           (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x)
                           true
                           (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt a x))
                           (@propext
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              true
                              (@imp_self (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))))
                     (@propext (@has_lt.lt.{0} nat nat.has_lt a x → true) true
                        (@forall_true_iff.{0} (@has_lt.lt.{0} nat nat.has_lt a x)))))
             (@propext (nat → true) true (@forall_const.{1} true nat nat.inhabited))))
       trivial),
hmt :
  ∀ {y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s},
    iff
      (@has_mem.mem.{0 0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@list.has_mem.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         y
         t)
      (@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (@subtype.preorder.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@ordered_comm_monoid.to_partial_order.{0} nat
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                        (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
               (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
         y
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
wf :
  ∀ (m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
    @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
      (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@subtype.decidable_linear_order.{0} nat
            (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
            (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
         t)
      (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
            (@with_bot.has_coe_t.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)))
         m) →
    @has_lt.lt.{0} nat nat.has_lt
      (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
      x,
m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s,
hmax :
  @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
    (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@subtype.decidable_linear_order.{0} nat
          (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
          (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
       t)
    (@option.some.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) m),
a : nat,
ha :
  @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 a)
    (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
       (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
       (@subtype.property.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m))
⊢ @has_le.le.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (@preorder.to_has_le.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@partial_order.to_preorder.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
          (@subtype.partial_order.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))
             (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
    (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)
    (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2
       (@has_add.add.{0} nat nat.has_add a (@has_one.one.{0} nat nat.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
of_nat_surjective_aux :
  ∀ {x : nat} (hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s),
    @Exists.{1} nat
      (λ (n : nat),
         @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
           (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
           (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
x : nat,
hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s,
t : list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) :=
  @list.pmap.{0 0} nat (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
    (λ (y : nat) (hy : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s),
       @subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) y hy)
    (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
       (list.range x))
    (@eq.mpr.{0}
       (∀ (a : nat),
          @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
            (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
               (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
               (list.range x)) →
          @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
       true
       (@id.{0}
          (@eq.{1} Prop
             (∀ (a : nat),
                @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                  (@list.filter.{0} nat (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                     (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                     (list.range x)) →
                @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
             true)
          (@eq.trans.{1} Prop
             (∀ (x_1 : nat),
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                  x_1)
             (∀ (x : nat), (λ (a : nat), true) x)
             true
             (@forall_congr_eq.{1} nat
                (λ (a : nat),
                   @has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                     (@list.filter.{0} nat
                        (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                        (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                        (list.range x)) →
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                (λ (a : nat), true)
                (λ (a : nat),
                   @eq.trans.{1} Prop
                     (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                        (@list.filter.{0} nat
                           (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                           (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                           (list.range x)) →
                      @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                     (@has_lt.lt.{0} nat nat.has_lt a x → true)
                     true
                     (@eq.trans.{1} Prop
                        (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                           (@list.filter.{0} nat
                              (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                              (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                              (list.range x)) →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                         @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                        (@has_lt.lt.{0} nat nat.has_lt a x → true)
                        (@eq.trans.{1} Prop
                           (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                              (@list.filter.{0} nat
                                 (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                 (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                 (list.range x)) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (and (@has_lt.lt.{0} nat nat.has_lt a x)
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@imp_congr_eq
                              (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                 (@list.filter.{0} nat
                                    (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                    (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                    (list.range x)))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@eq.trans.{1} Prop
                                 (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                    (@list.filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat),
                                          (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                       (list.range x)))
                                 (and (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s) a))
                                 (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))
                                 (@propext
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a
                                       (@list.filter.{0} nat
                                          (λ (y : nat),
                                             @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          (λ (a : nat),
                                             (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a) a)
                                          (list.range x)))
                                    (and
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       ((λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                          a))
                                    (@list.mem_filter.{0} nat
                                       (λ (y : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) y s)
                                       (λ (a : nat), @set.decidable_mem.{0} nat s (λ (a : nat), _inst_1 a) a)
                                       a
                                       (list.range x)))
                                 ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                   (e_2 : @eq.{1} Prop b b_1),
                                     @congr.{1 1} Prop Prop (and a) (and a_1) b b_1
                                       (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 and e_1)
                                       e_2)
                                    (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                    (@has_lt.lt.{0} nat nat.has_lt a x)
                                    (@propext
                                       (@has_mem.mem.{0 0} nat (list.{0} nat) (@list.has_mem.{0} nat) a (list.range x))
                                       (@has_lt.lt.{0} nat nat.has_lt a x)
                                       (@list.mem_range a x))
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                    (@eq.refl.{1} Prop
                                       (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                              (@eq.refl.{1} Prop (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))
                           (@propext
                              (and (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s) →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@has_lt.lt.{0} nat nat.has_lt a x →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              (@and_imp (@has_lt.lt.{0} nat nat.has_lt a x)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                                 (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s))))
                        (@imp_congr_eq (@has_lt.lt.{0} nat nat.has_lt a x)
                           (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                           (@has_lt.lt.{0} nat nat.has_lt a x)
                           true
                           (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt a x))
                           (@propext
                              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s →
                               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)
                              true
                              (@imp_self (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a s)))))
                     (@propext (@has_lt.lt.{0} nat nat.has_lt a x → true) true
                        (@forall_true_iff.{0} (@has_lt.lt.{0} nat nat.has_lt a x)))))
             (@propext (nat → true) true (@forall_const.{1} true nat nat.inhabited))))
       trivial),
hmt :
  ∀ {y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s},
    iff
      (@has_mem.mem.{0 0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (list.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@list.has_mem.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         y
         t)
      (@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (@subtype.preorder.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@ordered_comm_monoid.to_partial_order.{0} nat
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                        (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
               (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))
         y
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx)),
wf :
  ∀ (m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
    @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
      (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@subtype.decidable_linear_order.{0} nat
            (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
            (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
         t)
      (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
         (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
            (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
            (@with_bot.has_coe_t.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)))
         m) →
    @has_lt.lt.{0} nat nat.has_lt
      (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
      x,
m : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s,
hmax :
  @eq.{1} (with_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s))
    (@list.maximum.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
       (@subtype.decidable_linear_order.{0} nat
          (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} nat nat.decidable_linear_ordered_semiring)
          (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))
       t)
    (@option.some.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) m),
a : nat,
ha :
  @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
    (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 a)
    (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)
       (@subtype.val.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m)
       (@subtype.property.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) m))
⊢ @Exists.{1} nat
    (λ (n : nat),
       @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
         (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)
         (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>184  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>185  using_well_founded {dec_tac := `[tauto]}</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/tauto.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='`tauto` breaks down assumptions of the form `_ ∧ _`, `_ ∨ _`, `_ ↔ _` and `∃ _, _`
and splits a goal of the form `_ ∧ _`, `_ ↔ _` or `∃ _, _` until it can be discharged
using `reflexivity` or `solve_by_elim`.
This is a finishing tactic: it either closes the goal of raises an error.
The variant `tauto!` uses the law of excluded middle.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='teal'><a title='tauto'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='grey'><a title='[&#x27;!?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>186  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>187  lemma of_nat_surjective : surjective (of_nat s) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='function.surjective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.subtype.of_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 69, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 163, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Π {α : Sort u₁} {β : Sort u₂}, (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (s : set.{0} nat) [_inst_3 : @decidable_pred.{1} nat s] [_inst_4 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)], nat → @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>188  λ ⟨x, hx⟩, of_nat_surjective_aux hx</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='nat.subtype.of_nat_surjective_aux'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 167, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {s : set.{0} nat} [_inst_1 : @decidable_pred.{1} nat s] [_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)] {x : nat} (hx : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s), @Exists.{1} nat (λ (n : nat), @eq.{1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n) (@subtype.mk.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s) x hx))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>189  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>190  private def to_fun_aux (x : s) : ℕ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>191  (list.range x).countp s</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.countp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/basic.lean&#x27;, &#x27;line&#x27;: 231, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/defs.lean&#x27;, &#x27;line&#x27;: 191, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → list.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} (p : α → Prop) [_inst_1 : @decidable_pred.{1} α p], list.{0} α → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`countp p l` is the number of elements of `l` that satisfy `p`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>192  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>193  private lemma to_fun_aux_eq (x : s) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>194    to_fun_aux x = ((finset.range x).filter s).card :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_private.2712538897.to_fun_aux'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='finset.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='finset.filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='finset.card'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 190, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 847, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 705, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 1174, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {s : set.{0} nat} [_inst_1 : @decidable_pred.{1} nat s] [_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)], @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='nat → finset.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} (p : α → Prop) [_inst_3 : @decidable_pred.{1} α p], finset.{0} α → finset.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, finset.{0} α → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`range n` is the set of natural numbers less than `n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`filter p s` is the set of elements of `s` that satisfy `p`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`card s` is the cardinality (number of elements) of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>195  by rw [to_fun_aux, list.countp_eq_length_filter]; refl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='_private.2712538897.to_fun_aux'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.countp_eq_length_filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 190, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 2079, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {s : set.{0} nat} [_inst_1 : @decidable_pred.{1} nat s] [_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)], @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {p : α → Prop} [_inst_1 : @decidable_pred.{1} α p] (l : list.{0} α), @eq.{1} nat (@list.countp.{0} α p (λ (a : α), _inst_1 a) l) (@list.length.{0} α (@list.filter.{0} α p (λ (a : α), _inst_1 a) l))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
x : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s
⊢ @eq.{1} nat (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 x)
    (@finset.card.{0} nat
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
x : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s
⊢ @eq.{1} nat
    (@list.countp.{0} nat s (λ (a : nat), _inst_1 a)
       (list.range
          (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_subtype.{1} nat
                      (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
             x)))
    (@finset.card.{0} nat
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
x : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s
⊢ @eq.{1} nat
    (@list.length.{0} nat
       (@list.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (list.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                x))))
    (@finset.card.{0} nat
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
x : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s
⊢ @eq.{1} nat (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 x)
    (@finset.card.{0} nat
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>196  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
x : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s
⊢ @eq.{1} nat (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 x)
    (@finset.card.{0} nat
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>197  open finset</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>198  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>199  private lemma right_inverse_aux : ∀ n, to_fun_aux (of_nat s n) = n</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_private.2712538897.to_fun_aux'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.subtype.of_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='red'><a title='{&#x27;line&#x27;: 190, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 163, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {s : set.{0} nat} [_inst_1 : @decidable_pred.{1} nat s] [_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)], @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (s : set.{0} nat) [_inst_3 : @decidable_pred.{1} nat s] [_inst_4 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)], nat → @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>200  | 0 := begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
right_inverse_aux :
  ∀ (n : nat),
    @eq.{1} nat
      (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
      n
⊢ @eq.{1} nat
    (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2
       (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 (@has_zero.zero.{0} nat nat.has_zero)))
    (@has_zero.zero.{0} nat nat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>201    rw [to_fun_aux_eq, card_eq_zero, eq_empty_iff_forall_not_mem],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='_private.250789319.to_fun_aux_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.card_eq_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.eq_empty_iff_forall_not_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 193, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 1180, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 151, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {s : set.{0} nat} [_inst_1 : @decidable_pred.{1} nat s] [_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)] (x : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s), @eq.{1} nat (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 x) (@finset.card.{0} nat (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a) (finset.range (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))) x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {s : finset.{0} α}, iff (@eq.{1} nat (@finset.card.{0} α s) (@has_zero.zero.{0} nat nat.has_zero)) (@eq.{1} (finset.{0} α) s (@has_emptyc.emptyc.{0} (finset.{0} α) (@finset.has_emptyc.{0} α)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {s : finset.{0} α}, iff (@eq.{1} (finset.{0} α) s (@has_emptyc.emptyc.{0} (finset.{0} α) (@finset.has_emptyc.{0} α))) (∀ (x : α), not (@has_mem.mem.{0 0} α (finset.{0} α) (@finset.has_mem.{0} α) x s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
right_inverse_aux :
  ∀ (n : nat),
    @eq.{1} nat
      (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
      n
⊢ @eq.{1} nat
    (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2
       (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 (@has_zero.zero.{0} nat nat.has_zero)))
    (@has_zero.zero.{0} nat nat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
right_inverse_aux :
  ∀ (n : nat),
    @eq.{1} nat
      (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
      n
⊢ @eq.{1} nat
    (@finset.card.{0} nat
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 (@has_zero.zero.{0} nat nat.has_zero))))))
    (@has_zero.zero.{0} nat nat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
right_inverse_aux :
  ∀ (n : nat),
    @eq.{1} nat
      (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
      n
⊢ @eq.{1} (finset.{0} nat)
    (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
       (finset.range
          (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_subtype.{1} nat
                      (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
             (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 (@has_zero.zero.{0} nat nat.has_zero)))))
    (@has_emptyc.emptyc.{0} (finset.{0} nat) (@finset.has_emptyc.{0} nat))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
right_inverse_aux :
  ∀ (n : nat),
    @eq.{1} nat
      (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
      n
⊢ ∀ (x : nat),
    not
      (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) x
         (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
            (finset.range
               (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                  (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                     (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                        (@coe_subtype.{1} nat
                           (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                  (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 (@has_zero.zero.{0} nat nat.has_zero))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>202    assume n,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
right_inverse_aux :
  ∀ (n : nat),
    @eq.{1} nat
      (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
      n
⊢ ∀ (x : nat),
    not
      (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) x
         (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
            (finset.range
               (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                  (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                     (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                        (@coe_subtype.{1} nat
                           (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                  (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 (@has_zero.zero.{0} nat nat.has_zero))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
right_inverse_aux :
  ∀ (n : nat),
    @eq.{1} nat
      (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
      n,
n : nat
⊢ not
    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) n
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 (@has_zero.zero.{0} nat nat.has_zero))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>203    rw [mem_filter, of_nat, mem_range],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='finset.mem_filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.subtype.of_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.mem_range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 710, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 163, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 851, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {p : α → Prop} [_inst_1 : @decidable_pred.{1} α p] {s : finset.{0} α} {a : α}, iff (@has_mem.mem.{0 0} α (finset.{0} α) (@finset.has_mem.{0} α) a (@finset.filter.{0} α p (λ (a : α), _inst_1 a) s)) (and (@has_mem.mem.{0 0} α (finset.{0} α) (@finset.has_mem.{0} α) a s) (p a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (s : set.{0} nat) [_inst_3 : @decidable_pred.{1} nat s] [_inst_4 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)], nat → @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n m : nat}, iff (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) m (finset.range n)) (@has_lt.lt.{0} nat nat.has_lt m n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
right_inverse_aux :
  ∀ (n : nat),
    @eq.{1} nat
      (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
      n,
n : nat
⊢ not
    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) n
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 (@has_zero.zero.{0} nat nat.has_zero))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
right_inverse_aux :
  ∀ (n : nat),
    @eq.{1} nat
      (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
      n,
n : nat
⊢ not
    (and
       (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) n
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 (@has_zero.zero.{0} nat nat.has_zero)))))
       (s n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
right_inverse_aux :
  ∀ (n : nat),
    @eq.{1} nat
      (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
      n,
n : nat
⊢ not
    (and
       (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) n
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@lattice.has_bot.bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
                   (@lattice.order_bot.to_has_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
                      (@lattice.semilattice_sup_bot.to_order_bot.{0}
                         (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
                         (@lattice.nat.subtype.semilattice_sup_bot s (λ (a : nat), _inst_1 a)
                            (@nat.subtype.of_nat._main._proof_1 s _inst_2))))))))
       (s n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
right_inverse_aux :
  ∀ (n : nat),
    @eq.{1} nat
      (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
      n,
n : nat
⊢ not
    (and
       (@has_lt.lt.{0} nat nat.has_lt n
          (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_subtype.{1} nat
                      (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
             (@lattice.has_bot.bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
                (@lattice.order_bot.to_has_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
                   (@lattice.semilattice_sup_bot.to_order_bot.{0}
                      (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
                      (@lattice.nat.subtype.semilattice_sup_bot s (λ (a : nat), _inst_1 a)
                         (@nat.subtype.of_nat._main._proof_1 s _inst_2)))))))
       (s n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>204    assume h,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
right_inverse_aux :
  ∀ (n : nat),
    @eq.{1} nat
      (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
      n,
n : nat
⊢ not
    (and
       (@has_lt.lt.{0} nat nat.has_lt n
          (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_subtype.{1} nat
                      (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
             (@lattice.has_bot.bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
                (@lattice.order_bot.to_has_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
                   (@lattice.semilattice_sup_bot.to_order_bot.{0}
                      (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
                      (@lattice.nat.subtype.semilattice_sup_bot s (λ (a : nat), _inst_1 a)
                         (@nat.subtype.of_nat._main._proof_1 s _inst_2)))))))
       (s n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
right_inverse_aux :
  ∀ (n : nat),
    @eq.{1} nat
      (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
      n,
n : nat,
h :
  and
    (@has_lt.lt.{0} nat nat.has_lt n
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@lattice.has_bot.bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
             (@lattice.order_bot.to_has_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
                (@lattice.semilattice_sup_bot.to_order_bot.{0}
                   (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
                   (@lattice.nat.subtype.semilattice_sup_bot s (λ (a : nat), _inst_1 a)
                      (@nat.subtype.of_nat._main._proof_1 s _inst_2)))))))
    (s n)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>205    exact not_lt_of_le bot_le (show (⟨n, h.2⟩ : s) &lt; ⊥, from h.1)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='not_lt_of_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.bot_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/order.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 102, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b → not (@has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : lattice.order_bot.{0} α] {a : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.order_bot.to_partial_order.{0} α _inst_1))) (@lattice.has_bot.bot.{0} α (@lattice.order_bot.to_has_bot.{0} α _inst_1)) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_lt.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type) [c : lattice.has_bot.{0} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (@has_lt.lt.{0} nat nat.has_lt n (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))) (@lattice.has_bot.bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@lattice.order_bot.to_has_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@lattice.semilattice_sup_bot.to_order_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@lattice.nat.subtype.semilattice_sup_bot s (λ (a : nat), _inst_1 a) (@nat.subtype.of_nat._main._proof_1 s _inst_2))))))) (s n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
right_inverse_aux :
  ∀ (n : nat),
    @eq.{1} nat
      (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
      n,
n : nat,
h :
  and
    (@has_lt.lt.{0} nat nat.has_lt n
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@lattice.has_bot.bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
             (@lattice.order_bot.to_has_bot.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
                (@lattice.semilattice_sup_bot.to_order_bot.{0}
                   (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)
                   (@lattice.nat.subtype.semilattice_sup_bot s (λ (a : nat), _inst_1 a)
                      (@nat.subtype.of_nat._main._proof_1 s _inst_2)))))))
    (s n)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>206  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>207  | (n+1) := have ih : to_fun_aux (of_nat s n) = n, from right_inverse_aux n,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='_private.2712538897.to_fun_aux'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.subtype.of_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='right_inverse_aux'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;line&#x27;: 190, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 163, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Π {s : set.{0} nat} [_inst_1 : @decidable_pred.{1} nat s] [_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)], @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (s : set.{0} nat) [_inst_3 : @decidable_pred.{1} nat s] [_inst_4 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)], nat → @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ (n : nat), @eq.{1} nat (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>208  have h₁ : (of_nat s n : ℕ) ∉ (range (of_nat s n)).filter s, by simp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='nat.subtype.of_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='not'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.subtype.of_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='finset.filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 163, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 847, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 163, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 705, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π (s : set.{0} nat) [_inst_3 : @decidable_pred.{1} nat s] [_inst_4 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)], nat → @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → finset.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (s : set.{0} nat) [_inst_3 : @decidable_pred.{1} nat s] [_inst_4 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)], nat → @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type} (p : α → Prop) [_inst_3 : @decidable_pred.{1} α p], finset.{0} α → finset.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='`range n` is the set of natural numbers less than `n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`filter p s` is the set of elements of `s` that satisfy `p`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                               </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                               </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                              </code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
right_inverse_aux :
  ∀ (n : nat),
    @eq.{1} nat
      (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
      n,
n : nat,
ih :
  @eq.{1} nat
    (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
    n
⊢ not
    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat)
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>209  have h₂ : (range (succ (of_nat s n))).filter s =</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='finset.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.subtype.succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.subtype.of_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='finset.filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 847, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 135, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 163, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 705, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='nat → finset.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {s : set.{0} nat} [_inst_1 : @decidable_pred.{1} nat s] [_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)], @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s → @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (s : set.{0} nat) [_inst_3 : @decidable_pred.{1} nat s] [_inst_4 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)], nat → @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type} (p : α → Prop) [_inst_3 : @decidable_pred.{1} α p], finset.{0} α → finset.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`range n` is the set of natural numbers less than `n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='`filter p s` is the set of elements of `s` that satisfy `p`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>210      insert (of_nat s n) ((range (of_nat s n)).filter s),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='insert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.subtype.of_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='finset.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.subtype.of_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='finset.filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 389, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 163, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 847, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 163, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 705, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α γ : Type} [_inst_1 : has_insert.{0 0} α γ], α → γ → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (s : set.{0} nat) [_inst_3 : @decidable_pred.{1} nat s] [_inst_4 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)], nat → @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='nat → finset.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (s : set.{0} nat) [_inst_3 : @decidable_pred.{1} nat s] [_inst_4 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)], nat → @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type} (p : α → Prop) [_inst_3 : @decidable_pred.{1} α p], finset.{0} α → finset.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='`range n` is the set of natural numbers less than `n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`filter p s` is the set of elements of `s` that satisfy `p`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>211    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
right_inverse_aux :
  ∀ (n : nat),
    @eq.{1} nat
      (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
      n,
n : nat,
ih :
  @eq.{1} nat
    (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
    n,
h₁ :
  not
    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat)
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))
⊢ @eq.{1} (finset.{0} nat)
    (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
       (finset.range
          (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_subtype.{1} nat
                      (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
             (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))
    (@insert.{0 0} nat (finset.{0} nat) (@finset.has_insert.{0} nat (λ (a b : nat), nat.decidable_eq a b))
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>212      simp only [finset.ext, mem_insert, mem_range, mem_filter],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='finset.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.mem_insert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.mem_range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.mem_filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 220, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 851, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 710, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {s₁ s₂ : finset.{?l_1} α}, iff (@eq.{?l_1+1} (finset.{?l_1} α) s₁ s₂) (∀ (a : α), iff (@has_mem.mem.{?l_1 ?l_1} α (finset.{?l_1} α) (@finset.has_mem.{?l_1} α) a s₁) (@has_mem.mem.{?l_1 ?l_1} α (finset.{?l_1} α) (@finset.has_mem.{?l_1} α) a s₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : decidable_eq.{?l_1+1} α] {a b : α} {s : finset.{?l_1} α}, iff (@has_mem.mem.{?l_1 ?l_1} α (finset.{?l_1} α) (@finset.has_mem.{?l_1} α) a (@insert.{?l_1 ?l_1} α (finset.{?l_1} α) (@finset.has_insert.{?l_1} α (λ (a b : α), _inst_1 a b)) b s)) (or (@eq.{?l_1+1} α a b) (@has_mem.mem.{?l_1 ?l_1} α (finset.{?l_1} α) (@finset.has_mem.{?l_1} α) a s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n m : nat}, iff (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) m (finset.range n)) (@has_lt.lt.{0} nat nat.has_lt m n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {p : α → Prop} [_inst_1 : @decidable_pred.{?l_1+1} α p] {s : finset.{?l_1} α} {a : α}, iff (@has_mem.mem.{?l_1 ?l_1} α (finset.{?l_1} α) (@finset.has_mem.{?l_1} α) a (@finset.filter.{?l_1} α p (λ (a : α), _inst_1 a) s)) (and (@has_mem.mem.{?l_1 ?l_1} α (finset.{?l_1} α) (@finset.has_mem.{?l_1} α) a s) (p a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
right_inverse_aux :
  ∀ (n : nat),
    @eq.{1} nat
      (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
      n,
n : nat,
ih :
  @eq.{1} nat
    (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
    n,
h₁ :
  not
    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat)
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))
⊢ @eq.{1} (finset.{0} nat)
    (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
       (finset.range
          (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_subtype.{1} nat
                      (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
             (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))
    (@insert.{0 0} nat (finset.{0} nat) (@finset.has_insert.{0} nat (λ (a b : nat), nat.decidable_eq a b))
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
right_inverse_aux :
  ∀ (n : nat),
    @eq.{1} nat
      (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
      n,
n : nat,
ih :
  @eq.{1} nat
    (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
    n,
h₁ :
  not
    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat)
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))
⊢ ∀ (a : nat),
    iff
      (and
         (@has_lt.lt.{0} nat nat.has_lt a
            (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
               (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                  (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                     (@coe_subtype.{1} nat
                        (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
               (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2
                  (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))
         (s a))
      (or
         (@eq.{1} nat a
            (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
               (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                  (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                     (@coe_subtype.{1} nat
                        (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
               (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))
         (and
            (@has_lt.lt.{0} nat nat.has_lt a
               (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                  (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                     (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                        (@coe_subtype.{1} nat
                           (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                  (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))
            (s a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>213      assume m,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
right_inverse_aux :
  ∀ (n : nat),
    @eq.{1} nat
      (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
      n,
n : nat,
ih :
  @eq.{1} nat
    (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
    n,
h₁ :
  not
    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat)
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))
⊢ ∀ (a : nat),
    iff
      (and
         (@has_lt.lt.{0} nat nat.has_lt a
            (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
               (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                  (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                     (@coe_subtype.{1} nat
                        (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
               (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2
                  (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))
         (s a))
      (or
         (@eq.{1} nat a
            (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
               (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                  (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                     (@coe_subtype.{1} nat
                        (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
               (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))
         (and
            (@has_lt.lt.{0} nat nat.has_lt a
               (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                  (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                     (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                        (@coe_subtype.{1} nat
                           (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                  (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))
            (s a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
right_inverse_aux :
  ∀ (n : nat),
    @eq.{1} nat
      (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
      n,
n : nat,
ih :
  @eq.{1} nat
    (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
    n,
h₁ :
  not
    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat)
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))),
m : nat
⊢ iff
    (and
       (@has_lt.lt.{0} nat nat.has_lt m
          (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_subtype.{1} nat
                      (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
             (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))
       (s m))
    (or
       (@eq.{1} nat m
          (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_subtype.{1} nat
                      (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
             (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))
       (and
          (@has_lt.lt.{0} nat nat.has_lt m
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))
          (s m)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>214      exact ⟨λ h, by simp only [h.2, and_true]; exact or.symm</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='and_true'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='or.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 401, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 216, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (@has_lt.lt.{0} nat nat.has_lt m (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))) (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))) (s m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a : Prop), iff (and a true) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, or a b → or b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
right_inverse_aux :
  ∀ (n : nat),
    @eq.{1} nat
      (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
      n,
n : nat,
ih :
  @eq.{1} nat
    (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
    n,
h₁ :
  not
    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat)
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))),
m : nat
⊢ iff
    (and
       (@has_lt.lt.{0} nat nat.has_lt m
          (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_subtype.{1} nat
                      (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
             (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))
       (s m))
    (or
       (@eq.{1} nat m
          (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_subtype.{1} nat
                      (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
             (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))
       (and
          (@has_lt.lt.{0} nat nat.has_lt m
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))
          (s m)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
right_inverse_aux :
  ∀ (n : nat),
    @eq.{1} nat
      (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
      n,
n : nat,
ih :
  @eq.{1} nat
    (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
    n,
h₁ :
  not
    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat)
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))),
m : nat,
h :
  and
    (@has_lt.lt.{0} nat nat.has_lt m
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2
             (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))
    (s m)
⊢ or
    (@eq.{1} nat m
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))
    (and
       (@has_lt.lt.{0} nat nat.has_lt m
          (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_subtype.{1} nat
                      (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
             (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))
       (s m))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>215          (lt_or_eq_of_le ((@lt_succ_iff_le _ _ _ ⟨m, h.2⟩ _).1 h.1)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='lt_or_eq_of_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='nat.subtype.lt_succ_iff_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 124, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 159, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : partial_order.{0} α] {a b : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α _inst_1)) a b → or (@has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α _inst_1)) a b) (@eq.{1} α a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {s : set.{0} nat} [_inst_1 : @decidable_pred.{1} nat s] [_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)] {x y : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s}, iff (@has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@subtype.preorder.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))) x (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2 y)) (@has_le.le.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@preorder.to_has_le.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@subtype.preorder.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (@has_lt.lt.{0} nat nat.has_lt m (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))) (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))) (s m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
right_inverse_aux :
  ∀ (n : nat),
    @eq.{1} nat
      (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
      n,
n : nat,
ih :
  @eq.{1} nat
    (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
    n,
h₁ :
  not
    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat)
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))),
m : nat,
h :
  and
    (@has_lt.lt.{0} nat nat.has_lt m
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2
             (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))
    (s m)
⊢ or
    (@eq.{1} nat m
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))
    (and
       (@has_lt.lt.{0} nat nat.has_lt m
          (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_subtype.{1} nat
                      (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
             (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))
       (s m))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
right_inverse_aux :
  ∀ (n : nat),
    @eq.{1} nat
      (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
      n,
n : nat,
ih :
  @eq.{1} nat
    (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
    n,
h₁ :
  not
    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat)
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))),
m : nat
⊢ iff
    (and
       (@has_lt.lt.{0} nat nat.has_lt m
          (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_subtype.{1} nat
                      (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
             (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))
       (s m))
    (or
       (@eq.{1} nat m
          (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_subtype.{1} nat
                      (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
             (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))
       (and
          (@has_lt.lt.{0} nat nat.has_lt m
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))
          (s m)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>216        λ h, h.elim (λ h, h.symm ▸ ⟨lt_succ_self _, subtype.property _⟩)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='or.elim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='subtype.property'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 202, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {a b c : Prop}, or a b → (a → c) → (b → c) → c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} {a b : α}, @eq.{1} α a b → @eq.{1} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {P : α → Prop} {a b : α}, @eq.{1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {p : α → Prop} (c : @subtype.{1} α p), p (@subtype.val.{1} α p c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
right_inverse_aux :
  ∀ (n : nat),
    @eq.{1} nat
      (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
      n,
n : nat,
ih :
  @eq.{1} nat
    (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
    n,
h₁ :
  not
    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat)
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))),
m : nat
⊢ iff
    (and
       (@has_lt.lt.{0} nat nat.has_lt m
          (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_subtype.{1} nat
                      (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
             (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))
       (s m))
    (or
       (@eq.{1} nat m
          (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_subtype.{1} nat
                      (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
             (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))
       (and
          (@has_lt.lt.{0} nat nat.has_lt m
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))
          (s m)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>217          (λ h, ⟨lt_of_le_of_lt (le_of_lt h.1) (lt_succ_self _), h.2⟩)⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='lt_of_le_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='le_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='nat.subtype.lt_succ_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 107, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 99, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 155, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b c : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b → @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) b c → @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b : α}, @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {s : set.{0} nat} [_inst_1 : @decidable_pred.{1} nat s] [_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)] (x : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s), @has_lt.lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@preorder.to_has_lt.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@subtype.preorder.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))) x (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2 x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
right_inverse_aux :
  ∀ (n : nat),
    @eq.{1} nat
      (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
      n,
n : nat,
ih :
  @eq.{1} nat
    (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
    n,
h₁ :
  not
    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat)
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))),
m : nat
⊢ iff
    (and
       (@has_lt.lt.{0} nat nat.has_lt m
          (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_subtype.{1} nat
                      (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
             (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))
       (s m))
    (or
       (@eq.{1} nat m
          (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_subtype.{1} nat
                      (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
             (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))
       (and
          (@has_lt.lt.{0} nat nat.has_lt m
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))
          (s m)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>218    end,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
right_inverse_aux :
  ∀ (n : nat),
    @eq.{1} nat
      (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
      n,
n : nat,
ih :
  @eq.{1} nat
    (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
    n,
h₁ :
  not
    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat)
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))),
m : nat
⊢ iff
    (and
       (@has_lt.lt.{0} nat nat.has_lt m
          (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_subtype.{1} nat
                      (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
             (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))
       (s m))
    (or
       (@eq.{1} nat m
          (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_subtype.{1} nat
                      (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
             (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))
       (and
          (@has_lt.lt.{0} nat nat.has_lt m
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))
          (s m)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>219  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
right_inverse_aux :
  ∀ (n : nat),
    @eq.{1} nat
      (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
      n,
n : nat,
ih :
  @eq.{1} nat
    (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
    n,
h₁ :
  not
    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat)
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))),
h₂ :
  @eq.{1} (finset.{0} nat)
    (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
       (finset.range
          (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_subtype.{1} nat
                      (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
             (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))
    (@insert.{0 0} nat (finset.{0} nat) (@finset.has_insert.{0} nat (λ (a b : nat), nat.decidable_eq a b))
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))
⊢ @eq.{1} nat
    (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2
       (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2
          (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))))
    (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>220    clear_aux_decl,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 638, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`clear_aux_decl` clears every `aux_decl` in the local context for the current goal.
This includes the induction hypothesis when using the equation compiler and
`_let_match` and `_fun_match`.

It is useful when using a tactic such as `finish`, `simp *` or `subst` that may use these
auxiliary declarations, and produce an error saying the recursion is not well founded.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='clear_aux_decl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
right_inverse_aux :
  ∀ (n : nat),
    @eq.{1} nat
      (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
      n,
n : nat,
ih :
  @eq.{1} nat
    (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
    n,
h₁ :
  not
    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat)
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))),
h₂ :
  @eq.{1} (finset.{0} nat)
    (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
       (finset.range
          (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_subtype.{1} nat
                      (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
             (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))
    (@insert.{0 0} nat (finset.{0} nat) (@finset.has_insert.{0} nat (λ (a b : nat), nat.decidable_eq a b))
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))
⊢ @eq.{1} nat
    (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2
       (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2
          (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))))
    (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
n : nat,
ih :
  @eq.{1} nat
    (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
    n,
h₁ :
  not
    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat)
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))),
h₂ :
  @eq.{1} (finset.{0} nat)
    (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
       (finset.range
          (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_subtype.{1} nat
                      (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
             (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))
    (@insert.{0 0} nat (finset.{0} nat) (@finset.has_insert.{0} nat (λ (a b : nat), nat.decidable_eq a b))
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))
⊢ @eq.{1} nat
    (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2
       (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2
          (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))))
    (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>221    simp only [to_fun_aux_eq, of_nat, range_succ] at *,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='_private.250789319.to_fun_aux_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.subtype.of_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.range_succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 193, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 163, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 857, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {s : set.{0} nat} [_inst_1 : @decidable_pred.{1} nat s] [_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)] (x : @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s), @eq.{1} nat (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 x) (@finset.card.{0} nat (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a) (finset.range (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))) x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (s : set.{0} nat) [_inst_3 : @decidable_pred.{1} nat s] [_inst_4 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)], nat → @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : nat}, @eq.{1} (finset.{0} nat) (finset.range (nat.succ n)) (@insert.{0 0} nat (finset.{0} nat) (@finset.has_insert.{0} nat (λ (a b : nat), nat.decidable_eq a b)) n (finset.range n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
n : nat,
ih :
  @eq.{1} nat
    (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
    n,
h₁ :
  not
    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat)
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))),
h₂ :
  @eq.{1} (finset.{0} nat)
    (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
       (finset.range
          (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_subtype.{1} nat
                      (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
             (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))
    (@insert.{0 0} nat (finset.{0} nat) (@finset.has_insert.{0} nat (λ (a b : nat), nat.decidable_eq a b))
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))
⊢ @eq.{1} nat
    (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2
       (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2
          (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))))
    (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
n : nat,
h₁ :
  not
    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat)
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))),
h₂ :
  @eq.{1} (finset.{0} nat)
    (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
       (finset.range
          (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_subtype.{1} nat
                      (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
             (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))
    (@insert.{0 0} nat (finset.{0} nat) (@finset.has_insert.{0} nat (λ (a b : nat), nat.decidable_eq a b))
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))),
ih :
  @eq.{1} nat
    (@finset.card.{0} nat
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))
    n
⊢ @eq.{1} nat
    (@finset.card.{0} nat
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2
                   (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))))
    (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>222    conv {to_rhs, rw [← ih, ← card_insert_of_not_mem h₁, ← h₂] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='finset.card_insert_of_not_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='h₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 68, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 1192, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} nat (@finset.card.{0} nat (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a) (finset.range (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))) (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : decidable_eq.{1} α] {a : α} {s : finset.{0} α}, not (@has_mem.mem.{0 0} α (finset.{0} α) (@finset.has_mem.{0} α) a s) → @eq.{1} nat (@finset.card.{0} α (@insert.{0 0} α (finset.{0} α) (@finset.has_insert.{0} α (λ (a b : α), _inst_1 a b)) a s)) (@has_add.add.{0} nat nat.has_add (@finset.card.{0} α s) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))) (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)) (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a) (finset.range (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))) (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} (finset.{0} nat) (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a) (finset.range (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))) (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))) (@insert.{0 0} nat (finset.{0} nat) (@finset.has_insert.{0} nat (λ (a b : nat), nat.decidable_eq a b)) (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))) (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)) (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a) (finset.range (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s)))) (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='to_rhs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
n : nat,
h₁ :
  not
    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat)
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))),
h₂ :
  @eq.{1} (finset.{0} nat)
    (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
       (finset.range
          (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_subtype.{1} nat
                      (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
             (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))
    (@insert.{0 0} nat (finset.{0} nat) (@finset.has_insert.{0} nat (λ (a b : nat), nat.decidable_eq a b))
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))),
ih :
  @eq.{1} nat
    (@finset.card.{0} nat
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))
    n
⊢ @eq.{1} nat
    (@finset.card.{0} nat
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2
                   (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))))
    (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
n : nat,
h₁ :
  not
    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat)
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))),
h₂ :
  @eq.{1} (finset.{0} nat)
    (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
       (finset.range
          (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_subtype.{1} nat
                      (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
             (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))
    (@insert.{0 0} nat (finset.{0} nat) (@finset.has_insert.{0} nat (λ (a b : nat), nat.decidable_eq a b))
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))),
ih :
  @eq.{1} nat
    (@finset.card.{0} nat
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))
    n
| @eq.{1} nat
    (@finset.card.{0} nat
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2
                   (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))))
    (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
n : nat,
h₁ :
  not
    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat)
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))),
h₂ :
  @eq.{1} (finset.{0} nat)
    (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
       (finset.range
          (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_subtype.{1} nat
                      (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
             (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))
    (@insert.{0 0} nat (finset.{0} nat) (@finset.has_insert.{0} nat (λ (a b : nat), nat.decidable_eq a b))
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))),
ih :
  @eq.{1} nat
    (@finset.card.{0} nat
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))
    n
| @has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
n : nat,
h₁ :
  not
    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat)
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))),
h₂ :
  @eq.{1} (finset.{0} nat)
    (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
       (finset.range
          (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_subtype.{1} nat
                      (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
             (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))
    (@insert.{0 0} nat (finset.{0} nat) (@finset.has_insert.{0} nat (λ (a b : nat), nat.decidable_eq a b))
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))),
ih :
  @eq.{1} nat
    (@finset.card.{0} nat
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))
    n
| @has_add.add.{0} nat nat.has_add
    (@finset.card.{0} nat
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))
    (@has_one.one.{0} nat nat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
n : nat,
h₁ :
  not
    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat)
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))),
h₂ :
  @eq.{1} (finset.{0} nat)
    (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
       (finset.range
          (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_subtype.{1} nat
                      (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
             (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))
    (@insert.{0 0} nat (finset.{0} nat) (@finset.has_insert.{0} nat (λ (a b : nat), nat.decidable_eq a b))
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))),
ih :
  @eq.{1} nat
    (@finset.card.{0} nat
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))
    n
| @finset.card.{0} nat
    (@insert.{0 0} nat (finset.{0} nat)
       (@finset.has_insert.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b))
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
n : nat,
h₁ :
  not
    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat)
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))),
h₂ :
  @eq.{1} (finset.{0} nat)
    (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
       (finset.range
          (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_subtype.{1} nat
                      (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
             (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))
    (@insert.{0 0} nat (finset.{0} nat) (@finset.has_insert.{0} nat (λ (a b : nat), nat.decidable_eq a b))
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))),
ih :
  @eq.{1} nat
    (@finset.card.{0} nat
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))
    n
| @has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} nat,
_inst_1 : @decidable_pred.{1} nat s,
_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s),
n : nat,
h₁ :
  not
    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat)
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))),
h₂ :
  @eq.{1} (finset.{0} nat)
    (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
       (finset.range
          (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_subtype.{1} nat
                      (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
             (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))
    (@insert.{0 0} nat (finset.{0} nat) (@finset.has_insert.{0} nat (λ (a b : nat), nat.decidable_eq a b))
       (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
          (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_subtype.{1} nat (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
          (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n))))),
ih :
  @eq.{1} nat
    (@finset.card.{0} nat
       (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
          (finset.range
             (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                      (@coe_subtype.{1} nat
                         (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))
    n
| @finset.card.{0} nat
    (@finset.filter.{0} nat s (λ (a : nat), _inst_1 a)
       (finset.range
          (@coe.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
             (@coe_to_lift.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                (@coe_base.{1 1} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) nat
                   (@coe_subtype.{1} nat
                      (λ (x : nat), @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x s))))
             (@nat.subtype.succ s (λ (a : nat), _inst_1 a) _inst_2
                (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>223  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>224  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>225  def denumerable (s : set ℕ) [decidable_pred s] [infinite s] : denumerable s :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='decidable_pred'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='infinite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='denumerable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 268, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 796, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type}, (α → Prop) → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                              </code><font color='orange'><a title='A denumerable type is one which is (constructively) bijective with ℕ.
 Although we already have a name for this property, namely `α ≃ ℕ`,
 we are here interested in using it as a typeclass.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>226  denumerable.of_equiv ℕ</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='denumerable.of_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type u_1) {β : Type u_2} [_inst_3 : denumerable.{u_1} α], equiv.{u_2+1 u_1+1} β α → denumerable.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>227  { to_fun := to_fun_aux,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='_private.2712538897.to_fun_aux'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;line&#x27;: 190, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Π {s : set.{0} nat} [_inst_1 : @decidable_pred.{1} nat s] [_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)], @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>228    inv_fun := of_nat s,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='nat.subtype.of_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 163, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Π (s : set.{0} nat) [_inst_3 : @decidable_pred.{1} nat s] [_inst_4 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)], nat → @coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>229    left_inv := left_inverse_of_surjective_of_right_inverse</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='function.left_inverse_of_surjective_of_right_inverse'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 110, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='∀ {α : Sort u₁} {β : Sort u₂} {f : α → β} {g : β → α}, @function.surjective.{u₁ u₂} α β f → @function.right_inverse.{u₂ u₁} β α f g → @function.left_inverse.{u₂ u₁} β α f g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>230      of_nat_surjective right_inverse_aux,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='nat.subtype.of_nat_surjective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_private.3116591591.right_inverse_aux'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 187, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 199, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {s : set.{0} nat} [_inst_1 : @decidable_pred.{1} nat s] [_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)], @function.surjective.{1 1} nat (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s) (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {s : set.{0} nat} [_inst_1 : @decidable_pred.{1} nat s] [_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)] (n : nat), @eq.{1} nat (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>231    right_inv := right_inverse_aux }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='_private.3116591591.right_inverse_aux'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;line&#x27;: 199, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='∀ {s : set.{0} nat} [_inst_1 : @decidable_pred.{1} nat s] [_inst_2 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)] (n : nat), @eq.{1} nat (@to_fun_aux s (λ (a : nat), _inst_1 a) _inst_2 (@nat.subtype.of_nat s (λ (a : nat), _inst_1 a) _inst_2 n)) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>232  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>233  end nat.subtype</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>234  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>235  namespace denumerable</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>236  open encodable</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>237  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>238  def of_encodable_of_infinite (α : Type*) [encodable α] [infinite α] : denumerable α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='blue'><a title='encodable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='infinite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='denumerable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/encodable.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 796, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_1 → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='orange'><a title='An encodable type is a &quot;constructively countable&quot; type. This is where
 we have an explicit injection `encode : α → nat` and a partial inverse
 `decode : nat → option α`. This makes the range of `encode` decidable,
 although it is not decidable if `α` is finite or not.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='A denumerable type is one which is (constructively) bijective with ℕ.
 Although we already have a name for this property, namely `α ≃ ℕ`,
 we are here interested in using it as a typeclass.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>239  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type ?l_1,
_inst_1 : encodable.{?l_1} α,
_inst_2 : infinite.{?l_1} α
⊢ denumerable.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>240    letI := @decidable_range_encode α _;</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='encodable.decidable_range_encode'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/encodable.lean&#x27;, &#x27;line&#x27;: 104, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : encodable.{u_1} α], @decidable_pred.{1} nat (@set.range.{0 u_1+1} nat α (@encodable.encode.{u_1} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `let`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `let`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `let`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='letI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='letI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='letI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type ?l_1,
_inst_1 : encodable.{?l_1} α,
_inst_2 : infinite.{?l_1} α
⊢ denumerable.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>241    letI : infinite (set.range (@encode α _)) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='infinite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='encodable.encode'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 796, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/encodable.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} {ι : Type u_1}, (ι → α) → set.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [c : encodable.{u_1} α], α → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `let`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `let`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `let`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `let`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `let`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='letI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='letI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='letI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='letI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='letI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type ?l_1,
_inst_1 : encodable.{?l_1} α,
_inst_2 : infinite.{?l_1} α
⊢ denumerable.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>242      infinite.of_injective _ (equiv.set.range _ encode_injective).injective,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='infinite.of_injective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='equiv.set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='encodable.encode_injective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 811, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 789, &#x27;column&#x27;: 28}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/encodable.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {β : Type u_1} [_inst_1 : infinite.{u_1} β] (f : β → α), @function.injective.{u_1+1 1} β α f → infinite.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type} (f : α → β), @function.injective.{u_1+1 1} α β f → equiv.{u_1+1 1} α (@coe_sort.{1 2} (set.{0} β) (@set.has_coe_to_sort.{0} β) (@set.range.{0 u_1+1} β α f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : encodable.{u_1} α], @function.injective.{u_1+1 1} α nat (@encodable.encode.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `let`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `let`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `let`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `let`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='letI'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='letI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='letI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='letI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type ?l_1,
_inst_1 : encodable.{?l_1} α,
_inst_2 : infinite.{?l_1} α
⊢ denumerable.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type ?l_1,
_inst_1 : encodable.{?l_1} α,
_inst_2 : infinite.{?l_1} α,
_inst : @decidable_pred.{1} nat (@set.range.{0 ?l_1+1} nat α (@encodable.encode.{?l_1} α _inst_1)) :=
  @encodable.decidable_range_encode.{?l_1} α _inst_1,
_inst_3 : infinite.{0}
  (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat)
     (@set.range.{0 ?l_1+1} nat α (@encodable.encode.{?l_1} α _inst_1))) :=
  @infinite.of_injective.{0 ?l_1}
    (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat)
       (@set.range.{0 ?l_1+1} nat α (@encodable.encode.{?l_1} α _inst_1)))
    α
    _inst_2
    (@coe_fn.{(max 1 (max (?l_1+1) 1) 1 (?l_1+1)) (max (?l_1+1) 1)}
       (equiv.{?l_1+1 1} α
          (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat)
             (@set.range.{0 ?l_1+1} nat α (@encodable.encode.{?l_1} α _inst_1))))
       (@equiv.has_coe_to_fun.{?l_1+1 1} α
          (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat)
             (@set.range.{0 ?l_1+1} nat α (@encodable.encode.{?l_1} α _inst_1))))
       (@equiv.set.range.{?l_1+1 0} α nat (@encodable.encode.{?l_1} α _inst_1)
          (@encodable.encode_injective.{?l_1} α _inst_1)))
    (@equiv.injective.{?l_1+1 1} α
       (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat)
          (@set.range.{0 ?l_1+1} nat α (@encodable.encode.{?l_1} α _inst_1)))
       (@equiv.set.range.{?l_1+1 0} α nat (@encodable.encode.{?l_1} α _inst_1)
          (@encodable.encode_injective.{?l_1} α _inst_1)))
⊢ denumerable.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>243    letI := nat.subtype.denumerable (set.range (@encode α _)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='nat.subtype.denumerable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='encodable.encode'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 225, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/encodable.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (s : set.{0} nat) [_inst_3 : @decidable_pred.{1} nat s] [_inst_4 : infinite.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)], denumerable.{0} (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} {ι : Type u_1}, (ι → α) → set.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [c : encodable.{u_1} α], α → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `let`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `let`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `let`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `let`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `let`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='letI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='letI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='letI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='letI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='letI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type ?l_1,
_inst_1 : encodable.{?l_1} α,
_inst_2 : infinite.{?l_1} α,
_inst : @decidable_pred.{1} nat (@set.range.{0 ?l_1+1} nat α (@encodable.encode.{?l_1} α _inst_1)) :=
  @encodable.decidable_range_encode.{?l_1} α _inst_1,
_inst_3 : infinite.{0}
  (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat)
     (@set.range.{0 ?l_1+1} nat α (@encodable.encode.{?l_1} α _inst_1))) :=
  @infinite.of_injective.{0 ?l_1}
    (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat)
       (@set.range.{0 ?l_1+1} nat α (@encodable.encode.{?l_1} α _inst_1)))
    α
    _inst_2
    (@coe_fn.{(max 1 (max (?l_1+1) 1) 1 (?l_1+1)) (max (?l_1+1) 1)}
       (equiv.{?l_1+1 1} α
          (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat)
             (@set.range.{0 ?l_1+1} nat α (@encodable.encode.{?l_1} α _inst_1))))
       (@equiv.has_coe_to_fun.{?l_1+1 1} α
          (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat)
             (@set.range.{0 ?l_1+1} nat α (@encodable.encode.{?l_1} α _inst_1))))
       (@equiv.set.range.{?l_1+1 0} α nat (@encodable.encode.{?l_1} α _inst_1)
          (@encodable.encode_injective.{?l_1} α _inst_1)))
    (@equiv.injective.{?l_1+1 1} α
       (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat)
          (@set.range.{0 ?l_1+1} nat α (@encodable.encode.{?l_1} α _inst_1)))
       (@equiv.set.range.{?l_1+1 0} α nat (@encodable.encode.{?l_1} α _inst_1)
          (@encodable.encode_injective.{?l_1} α _inst_1)))
⊢ denumerable.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type ?l_1,
_inst_1 : encodable.{?l_1} α,
_inst_2 : infinite.{?l_1} α,
_inst : @decidable_pred.{1} nat (@set.range.{0 ?l_1+1} nat α (@encodable.encode.{?l_1} α _inst_1)) :=
  @encodable.decidable_range_encode.{?l_1} α _inst_1,
_inst_3 : infinite.{0}
  (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat)
     (@set.range.{0 ?l_1+1} nat α (@encodable.encode.{?l_1} α _inst_1))) :=
  @infinite.of_injective.{0 ?l_1}
    (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat)
       (@set.range.{0 ?l_1+1} nat α (@encodable.encode.{?l_1} α _inst_1)))
    α
    _inst_2
    (@coe_fn.{(max 1 (max (?l_1+1) 1) 1 (?l_1+1)) (max (?l_1+1) 1)}
       (equiv.{?l_1+1 1} α
          (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat)
             (@set.range.{0 ?l_1+1} nat α (@encodable.encode.{?l_1} α _inst_1))))
       (@equiv.has_coe_to_fun.{?l_1+1 1} α
          (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat)
             (@set.range.{0 ?l_1+1} nat α (@encodable.encode.{?l_1} α _inst_1))))
       (@equiv.set.range.{?l_1+1 0} α nat (@encodable.encode.{?l_1} α _inst_1)
          (@encodable.encode_injective.{?l_1} α _inst_1)))
    (@equiv.injective.{?l_1+1 1} α
       (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat)
          (@set.range.{0 ?l_1+1} nat α (@encodable.encode.{?l_1} α _inst_1)))
       (@equiv.set.range.{?l_1+1 0} α nat (@encodable.encode.{?l_1} α _inst_1)
          (@encodable.encode_injective.{?l_1} α _inst_1))),
_inst_4 : denumerable.{0}
  (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat)
     (@set.range.{0 ?l_1+1} nat α (@encodable.encode.{?l_1} α _inst_1))) :=
  @nat.subtype.denumerable (@set.range.{0 ?l_1+1} nat α (@encodable.encode.{?l_1} α _inst_1)) (λ (a : nat), _inst a)
    _inst_3
⊢ denumerable.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>244    exact denumerable.of_equiv (set.range (@encode α _))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='denumerable.of_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='encodable.encode'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/encodable.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type) {β : Type u_1} [_inst_3 : denumerable.{0} α], equiv.{u_1+1 1} β α → denumerable.{u_1} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} {ι : Type u_1}, (ι → α) → set.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [c : encodable.{u_1} α], α → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type ?l_1,
_inst_1 : encodable.{?l_1} α,
_inst_2 : infinite.{?l_1} α,
_inst : @decidable_pred.{1} nat (@set.range.{0 ?l_1+1} nat α (@encodable.encode.{?l_1} α _inst_1)) :=
  @encodable.decidable_range_encode.{?l_1} α _inst_1,
_inst_3 : infinite.{0}
  (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat)
     (@set.range.{0 ?l_1+1} nat α (@encodable.encode.{?l_1} α _inst_1))) :=
  @infinite.of_injective.{0 ?l_1}
    (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat)
       (@set.range.{0 ?l_1+1} nat α (@encodable.encode.{?l_1} α _inst_1)))
    α
    _inst_2
    (@coe_fn.{(max 1 (max (?l_1+1) 1) 1 (?l_1+1)) (max (?l_1+1) 1)}
       (equiv.{?l_1+1 1} α
          (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat)
             (@set.range.{0 ?l_1+1} nat α (@encodable.encode.{?l_1} α _inst_1))))
       (@equiv.has_coe_to_fun.{?l_1+1 1} α
          (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat)
             (@set.range.{0 ?l_1+1} nat α (@encodable.encode.{?l_1} α _inst_1))))
       (@equiv.set.range.{?l_1+1 0} α nat (@encodable.encode.{?l_1} α _inst_1)
          (@encodable.encode_injective.{?l_1} α _inst_1)))
    (@equiv.injective.{?l_1+1 1} α
       (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat)
          (@set.range.{0 ?l_1+1} nat α (@encodable.encode.{?l_1} α _inst_1)))
       (@equiv.set.range.{?l_1+1 0} α nat (@encodable.encode.{?l_1} α _inst_1)
          (@encodable.encode_injective.{?l_1} α _inst_1))),
_inst_4 : denumerable.{0}
  (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat)
     (@set.range.{0 ?l_1+1} nat α (@encodable.encode.{?l_1} α _inst_1))) :=
  @nat.subtype.denumerable (@set.range.{0 ?l_1+1} nat α (@encodable.encode.{?l_1} α _inst_1)) (λ (a : nat), _inst a)
    _inst_3
⊢ denumerable.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>245      (equiv_range_encode α)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='encodable.equiv_range_encode'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/encodable.lean&#x27;, &#x27;line&#x27;: 109, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : encodable.{u_1} α], equiv.{u_1+1 1} α (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat) (@set.range.{0 u_1+1} nat α (@encodable.encode.{u_1} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type ?l_1,
_inst_1 : encodable.{?l_1} α,
_inst_2 : infinite.{?l_1} α,
_inst : @decidable_pred.{1} nat (@set.range.{0 ?l_1+1} nat α (@encodable.encode.{?l_1} α _inst_1)) :=
  @encodable.decidable_range_encode.{?l_1} α _inst_1,
_inst_3 : infinite.{0}
  (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat)
     (@set.range.{0 ?l_1+1} nat α (@encodable.encode.{?l_1} α _inst_1))) :=
  @infinite.of_injective.{0 ?l_1}
    (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat)
       (@set.range.{0 ?l_1+1} nat α (@encodable.encode.{?l_1} α _inst_1)))
    α
    _inst_2
    (@coe_fn.{(max 1 (max (?l_1+1) 1) 1 (?l_1+1)) (max (?l_1+1) 1)}
       (equiv.{?l_1+1 1} α
          (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat)
             (@set.range.{0 ?l_1+1} nat α (@encodable.encode.{?l_1} α _inst_1))))
       (@equiv.has_coe_to_fun.{?l_1+1 1} α
          (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat)
             (@set.range.{0 ?l_1+1} nat α (@encodable.encode.{?l_1} α _inst_1))))
       (@equiv.set.range.{?l_1+1 0} α nat (@encodable.encode.{?l_1} α _inst_1)
          (@encodable.encode_injective.{?l_1} α _inst_1)))
    (@equiv.injective.{?l_1+1 1} α
       (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat)
          (@set.range.{0 ?l_1+1} nat α (@encodable.encode.{?l_1} α _inst_1)))
       (@equiv.set.range.{?l_1+1 0} α nat (@encodable.encode.{?l_1} α _inst_1)
          (@encodable.encode_injective.{?l_1} α _inst_1))),
_inst_4 : denumerable.{0}
  (@coe_sort.{1 2} (set.{0} nat) (@set.has_coe_to_sort.{0} nat)
     (@set.range.{0 ?l_1+1} nat α (@encodable.encode.{?l_1} α _inst_1))) :=
  @nat.subtype.denumerable (@set.range.{0 ?l_1+1} nat α (@encodable.encode.{?l_1} α _inst_1)) (λ (a : nat), _inst a)
    _inst_3
⊢ denumerable.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>246  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>247  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>248  end denumerable</code></pre>
</body>