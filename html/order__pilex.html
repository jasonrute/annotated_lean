<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2019 Chris Hughes. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Chris Hughes</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  import algebra.order_functions tactic.tauto algebra.pi_instances</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/order_functions.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/tauto.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/pi_instances.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  variables {ι : Type*} {β : ι → Type*} (r : ι → ι → Prop)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10    (s : Π {i}, β i → β i → Prop)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  def pi.lex (x y : Π i, β i) : Prop :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  ∃ i, (∀ j, r j i → x j = y j) ∧ s (x i) (y i)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι → ι → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (i : ι), β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (i : ι), β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {i : ι}, β i → β i → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (i : ι), β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (i : ι), β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  def pilex (α : Type*) (β : α → Type*) : Type* := Π a, β a</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  instance [has_lt ι] [∀ a, has_lt (β a)] : has_lt (pilex ι β) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='has_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pilex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 15, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1), (α → Type u_2) → Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  { lt := pi.lex (&lt;) (λ _, (&lt;)) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='pi.lex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {ι : Type u_1} {β : ι → Type u_2}, (ι → ι → Prop) → (Π {i : ι}, β i → β i → Prop) → (Π (i : ι), β i) → (Π (i : ι), β i) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_lt.{u_1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2} [c : has_lt.{u_2} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  instance [∀ a, inhabited (β a)] : inhabited (pilex ι β) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='inhabited'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='inhabited'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pilex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 768, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 768, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 15, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Sort u → Sort (max 1 u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Sort u → Sort (max 1 u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1), (α → Type u_2) → Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  by unfold pilex; apply_instance</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1411, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.unfold_config {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.ff, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.ff, beta := bool.tt, eta := bool.ff, proj := bool.ff, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.ff, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Given defined constants `e₁ ... eₙ`, `unfold e₁ ... eₙ` iteratively unfolds all occurrences in the target of the main goal, using equational lemmas associated with the definitions.

As with `simp`, the `at` modifier can be used to specify locations for the unfolding.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='unfold'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.unfold_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : Π (a : ι), inhabited.{u_2+1} (β a)
⊢ inhabited.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : Π (a : ι), inhabited.{u_2+1} (β a)
⊢ inhabited.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  set_option eqn_compiler.zeta true</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='(equation compiler) apply zeta-expansion (expand references to let-declarations) before creating auxiliary definitions.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  instance [linear_order ι] [∀ a, partial_order (β a)] : partial_order (pilex ι β) :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  let I := classical.DLO ι in</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  have lt_not_symm : ∀ {x y : pilex ι β}, ¬ (x &lt; y ∧ y &lt; x),</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28    from λ x y ⟨⟨i, hi⟩, ⟨j, hj⟩⟩, begin</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29        rcases lt_trichotomy i j with hij | hij | hji,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30        { exact lt_irrefl (x i) (by simpa [hj.1 _ hij] using hi.2) },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31        { exact not_le_of_gt hj.2 (hij ▸ le_of_lt hi.2) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='blue'><a title='le_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 99, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : preorder.{u_2} α] {a b : α}, @has_lt.lt.{u_2} α (@preorder.to_has_lt.{u_2} α _inst_1) a b → @has_le.le.{u_2} α (@preorder.to_has_le.{u_2} α _inst_1) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (∀ (j : ι), @has_lt.lt.{u_1} ι (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1))) j i → @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j)) ((λ (_x : ι), @has_lt.lt.{u_2} (β _x) ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x)) i (x i) (y i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
x y : pilex.{u_1 u_2} ι β,
_x :
  and
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       x
       y)
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       y
       x),
_fun_match :
  and
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       x
       y)
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       y
       x) →
  false,
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (x j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (x j)),
hij : @eq.{u_1+1} ι i j
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
x y : pilex.{u_1 u_2} ι β,
_x :
  and
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       x
       y)
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       y
       x),
_fun_match :
  and
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       x
       y)
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       y
       x) →
  false,
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (x j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (x j)),
hji :
  @has_lt.lt.{u_1} ι
    (@preorder.to_has_lt.{u_1} ι
       (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
    j
    i
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32        { exact lt_irrefl (x j) (by simpa [hi.1 _ hji] using hj.2) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='lt_irrefl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='hji'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : preorder.{u_2} α] (a : α), not (@has_lt.lt.{u_2} α (@preorder.to_has_lt.{u_2} α _inst_1) a a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (∀ (j : ι), @has_lt.lt.{u_1} ι (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1))) j i → @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j)) ((λ (_x : ι), @has_lt.lt.{u_2} (β _x) ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x)) i (x i) (y i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{u_1} ι (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1))) j i'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (∀ (j_1 : ι), @has_lt.lt.{u_1} ι (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1))) j_1 j → @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (x j_1)) ((λ (_x : ι), @has_lt.lt.{u_2} (β _x) ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x)) j (y j) (x j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
x y : pilex.{u_1 u_2} ι β,
_x :
  and
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       x
       y)
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       y
       x),
_fun_match :
  and
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       x
       y)
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       y
       x) →
  false,
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (x j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (x j)),
hji :
  @has_lt.lt.{u_1} ι
    (@preorder.to_has_lt.{u_1} ι
       (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
    j
    i
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
x y : pilex.{u_1 u_2} ι β,
_x :
  and
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       x
       y)
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       y
       x),
_fun_match :
  and
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       x
       y)
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       y
       x) →
  false,
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (x j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (x j)),
hji :
  @has_lt.lt.{u_1} ι
    (@preorder.to_has_lt.{u_1} ι
       (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
    j
    i
⊢ @has_lt.lt.{u_2} (β j) (@preorder.to_has_lt.{u_2} (β j) (@partial_order.to_preorder.{u_2} (β j) (_inst_2 j)))
    (x j)
    (x j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
x y : pilex.{u_1 u_2} ι β,
_x :
  and
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       x
       y)
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       y
       x),
_fun_match :
  and
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       x
       y)
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       y
       x) →
  false,
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (x j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (x j)),
hji :
  @has_lt.lt.{u_1} ι
    (@preorder.to_has_lt.{u_1} ι
       (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
    j
    i
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33      end,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  { le := λ x y, x &lt; y ∨ x = y,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='or'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u_1 u_2)} [c : has_lt.{(max u_1 u_2)} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u_1 u_2)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35    le_refl := λ _, or.inr rfl,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='or.inr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {a b : Prop}, b → or a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Sort u} {a : α}, @eq.{u} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36    le_antisymm := λ x y hxy hyx,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hxy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hyx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@preorder.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (λ (x y : pilex.{u_1 u_2} ι β), or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)) (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))) (λ (_x : pilex.{u_1 u_2} ι β), @or.inr (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) _x _x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) _x _x) (@rfl.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) _x)) (λ (x y z : pilex.{u_1 u_2} ι β) (hxy : @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (λ (x y : pilex.{u_1 u_2} ι β), or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))) x y) (hyz : @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (λ (x y : pilex.{u_1 u_2} ι β), or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))) y z), @or.elim (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (λ (x y : pilex.{u_1 u_2} ι β), or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))) x z) hxy (λ (_x : @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y), pilex.partial_order._match_3.{u_1 u_2} ι β _inst_1 _inst_2 x y z hxy hyz _x) (λ (hxy : @eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y), @eq.subst.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) (λ (_x : pilex.{u_1 u_2} ι β), @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (λ (x y : pilex.{u_1 u_2} ι β), or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))) _x z) y x (@eq.symm.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y hxy) hyz)) (λ (x y : pilex.{u_1 u_2} ι β), show iff (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (and (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)) (not (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x)))), from @iff.intro (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (and (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)) (not (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x)))) (λ (_x : @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y), pilex.partial_order._match_5.{u_1 u_2} ι β _inst_1 _inst_2 x y _x) (λ (a : and (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)) (not (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x)))), @and.dcases_on.{0} (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)) (not (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))) (λ (a : and (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)) (not (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x)))), @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) a (λ (a_left : or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)) (a_right : not (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))), @or.dcases_on (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (λ (a_left : or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)), @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) a_left (λ (a_left : @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y), @eq.mpr.{0} (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@rfl.{1} Prop (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y)) a_left) (λ (a_left : @eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y), @and.dcases_on.{0} (not (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x)) (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x)) (λ (a_right : and (not (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x)) (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))), @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@iff.mp (not (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))) (and (not (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x)) (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))) (@not_or_distrib (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x)) a_right) (λ (a_right_left : not (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x)) (a_right_right : not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x)), @absurd.{0} (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x) (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.mpr.{0} (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (@eq.trans.{1} Prop (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (@eq.trans.{1} Prop (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (@rfl.{1} Prop (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x)) (@iff.to_eq (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (@iff.intro (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (@eq.symm.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x) (@eq.symm.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))) (@eq.symm.{1} Prop (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (@rfl.{1} Prop (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))) a_left) a_right_right))))))) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@preorder.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (λ (x y : pilex.{u_1 u_2} ι β), or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)) (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))) (λ (_x : pilex.{u_1 u_2} ι β), @or.inr (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) _x _x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) _x _x) (@rfl.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) _x)) (λ (x y z : pilex.{u_1 u_2} ι β) (hxy : @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (λ (x y : pilex.{u_1 u_2} ι β), or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))) x y) (hyz : @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (λ (x y : pilex.{u_1 u_2} ι β), or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))) y z), @or.elim (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (λ (x y : pilex.{u_1 u_2} ι β), or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))) x z) hxy (λ (_x : @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y), pilex.partial_order._match_3.{u_1 u_2} ι β _inst_1 _inst_2 x y z hxy hyz _x) (λ (hxy : @eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y), @eq.subst.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) (λ (_x : pilex.{u_1 u_2} ι β), @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (λ (x y : pilex.{u_1 u_2} ι β), or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))) _x z) y x (@eq.symm.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y hxy) hyz)) (λ (x y : pilex.{u_1 u_2} ι β), show iff (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (and (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)) (not (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x)))), from @iff.intro (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (and (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)) (not (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x)))) (λ (_x : @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y), pilex.partial_order._match_5.{u_1 u_2} ι β _inst_1 _inst_2 x y _x) (λ (a : and (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)) (not (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x)))), @and.dcases_on.{0} (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)) (not (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))) (λ (a : and (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)) (not (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x)))), @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) a (λ (a_left : or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)) (a_right : not (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))), @or.dcases_on (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (λ (a_left : or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)), @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) a_left (λ (a_left : @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y), @eq.mpr.{0} (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@rfl.{1} Prop (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y)) a_left) (λ (a_left : @eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y), @and.dcases_on.{0} (not (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x)) (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x)) (λ (a_right : and (not (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x)) (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))), @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@iff.mp (not (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))) (and (not (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x)) (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))) (@not_or_distrib (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x)) a_right) (λ (a_right_left : not (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x)) (a_right_right : not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x)), @absurd.{0} (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x) (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.mpr.{0} (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (@eq.trans.{1} Prop (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (@eq.trans.{1} Prop (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (@rfl.{1} Prop (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x)) (@iff.to_eq (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (@iff.intro (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (@eq.symm.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x) (@eq.symm.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))) (@eq.symm.{1} Prop (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (@rfl.{1} Prop (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))) a_left) a_right_right))))))) y x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37      hxy.elim (λ hxy, hyx.elim (λ hyx, false.elim (lt_not_symm ⟨hxy, hyx⟩)) eq.symm) id,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hxy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='or.elim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hxy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hyx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='or.elim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hyx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='false.elim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lt_not_symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hxy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hyx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 202, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 202, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@preorder.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (λ (x y : pilex.{u_1 u_2} ι β), or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)) (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))) (λ (_x : pilex.{u_1 u_2} ι β), @or.inr (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) _x _x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) _x _x) (@rfl.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) _x)) (λ (x y z : pilex.{u_1 u_2} ι β) (hxy : @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (λ (x y : pilex.{u_1 u_2} ι β), or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))) x y) (hyz : @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (λ (x y : pilex.{u_1 u_2} ι β), or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))) y z), @or.elim (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (λ (x y : pilex.{u_1 u_2} ι β), or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))) x z) hxy (λ (_x : @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y), pilex.partial_order._match_3.{u_1 u_2} ι β _inst_1 _inst_2 x y z hxy hyz _x) (λ (hxy : @eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y), @eq.subst.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) (λ (_x : pilex.{u_1 u_2} ι β), @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (λ (x y : pilex.{u_1 u_2} ι β), or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))) _x z) y x (@eq.symm.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y hxy) hyz)) (λ (x y : pilex.{u_1 u_2} ι β), show iff (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (and (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)) (not (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x)))), from @iff.intro (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (and (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)) (not (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x)))) (λ (_x : @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y), pilex.partial_order._match_5.{u_1 u_2} ι β _inst_1 _inst_2 x y _x) (λ (a : and (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)) (not (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x)))), @and.dcases_on.{0} (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)) (not (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))) (λ (a : and (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)) (not (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x)))), @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) a (λ (a_left : or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)) (a_right : not (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))), @or.dcases_on (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (λ (a_left : or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)), @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) a_left (λ (a_left : @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y), @eq.mpr.{0} (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@rfl.{1} Prop (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y)) a_left) (λ (a_left : @eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y), @and.dcases_on.{0} (not (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x)) (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x)) (λ (a_right : and (not (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x)) (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))), @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@iff.mp (not (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))) (and (not (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x)) (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))) (@not_or_distrib (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x)) a_right) (λ (a_right_left : not (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x)) (a_right_right : not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x)), @absurd.{0} (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x) (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.mpr.{0} (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (@eq.trans.{1} Prop (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (@eq.trans.{1} Prop (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (@rfl.{1} Prop (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x)) (@iff.to_eq (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (@iff.intro (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (@eq.symm.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x) (@eq.symm.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))) (@eq.symm.{1} Prop (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (@rfl.{1} Prop (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))) a_left) a_right_right))))))) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b c : Prop}, or a b → (a → c) → (b → c) → c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@preorder.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (λ (x y : pilex.{u_1 u_2} ι β), or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)) (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))) (λ (_x : pilex.{u_1 u_2} ι β), @or.inr (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) _x _x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) _x _x) (@rfl.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) _x)) (λ (x y z : pilex.{u_1 u_2} ι β) (hxy : @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (λ (x y : pilex.{u_1 u_2} ι β), or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))) x y) (hyz : @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (λ (x y : pilex.{u_1 u_2} ι β), or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))) y z), @or.elim (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (λ (x y : pilex.{u_1 u_2} ι β), or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))) x z) hxy (λ (_x : @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y), pilex.partial_order._match_3.{u_1 u_2} ι β _inst_1 _inst_2 x y z hxy hyz _x) (λ (hxy : @eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y), @eq.subst.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) (λ (_x : pilex.{u_1 u_2} ι β), @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (λ (x y : pilex.{u_1 u_2} ι β), or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))) _x z) y x (@eq.symm.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y hxy) hyz)) (λ (x y : pilex.{u_1 u_2} ι β), show iff (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (and (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)) (not (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x)))), from @iff.intro (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (and (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)) (not (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x)))) (λ (_x : @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y), pilex.partial_order._match_5.{u_1 u_2} ι β _inst_1 _inst_2 x y _x) (λ (a : and (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)) (not (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x)))), @and.dcases_on.{0} (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)) (not (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))) (λ (a : and (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)) (not (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x)))), @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) a (λ (a_left : or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)) (a_right : not (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))), @or.dcases_on (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (λ (a_left : or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)), @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) a_left (λ (a_left : @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y), @eq.mpr.{0} (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@rfl.{1} Prop (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y)) a_left) (λ (a_left : @eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y), @and.dcases_on.{0} (not (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x)) (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x)) (λ (a_right : and (not (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x)) (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))), @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@iff.mp (not (or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))) (and (not (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x)) (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))) (@not_or_distrib (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x)) a_right) (λ (a_right_left : not (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x)) (a_right_right : not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x)), @absurd.{0} (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x) (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.mpr.{0} (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (@eq.trans.{1} Prop (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (@eq.trans.{1} Prop (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (@rfl.{1} Prop (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x)) (@iff.to_eq (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (@iff.intro (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (@eq.symm.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x) (@eq.symm.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))) (@eq.symm.{1} Prop (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y) (@rfl.{1} Prop (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))) a_left) a_right_right))))))) y x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b c : Prop}, or a b → (a → c) → (b → c) → c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Sort u}, false → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {x y : pilex.{u_1 u_2} ι β}, not (and (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Sort u} {a b : α}, @eq.{u} α a b → @eq.{u} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u}, α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38    le_trans :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39      λ x y z hxy hyz,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hxy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hyz'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (λ (x y : pilex.{u_1 u_2} ι β), or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (λ (x y : pilex.{u_1 u_2} ι β), or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))) y z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40      hxy.elim</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hxy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='or.elim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 202, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (λ (x y : pilex.{u_1 u_2} ι β), or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b c : Prop}, or a b → (a → c) → (b → c) → c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41        (λ ⟨i, hi⟩, hyz.elim</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hyz'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='or.elim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 202, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (λ (x y : pilex.{u_1 u_2} ι β), or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))) y z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b c : Prop}, or a b → (a → c) → (b → c) → c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42          (λ ⟨j, hj⟩, or.inl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='or.inl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='∀ {a b : Prop}, a → or a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43            ⟨by exactI min i j, by resetI; exact</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='min'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : decidable_linear_order.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Reset the instance cache. This allows any new instances
 added to the context to be used in typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='resetI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y z : pilex.{u_1 u_2} ι β,
hxy :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    y,
hyz :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    y
    z,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (z j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (z j))
⊢ ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y z : pilex.{u_1 u_2} ι β,
hxy :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    y,
hyz :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    y
    z,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (z j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (z j))
⊢ ∀ (j_1 : ι),
    @has_lt.lt.{u_1} ι
      (@preorder.to_has_lt.{u_1} ι
         (@partial_order.to_preorder.{u_1} ι
            (@lattice.semilattice_inf.to_partial_order.{u_1} ι
               (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
      j_1
      (@min.{u_1} ι I i j) →
    @eq.{u_2+1} ((λ (a : ι), β a) j_1) (x j_1) (z j_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44              λ k hk, by rw [hi.1 _ (lt_min_iff.1 hk).1, hj.1 _ (lt_min_iff.1 hk).2],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='lt_min_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='hj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='lt_min_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/order_functions.lean&#x27;, &#x27;line&#x27;: 110, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/order_functions.lean&#x27;, &#x27;line&#x27;: 110, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (∀ (j : ι), @has_lt.lt.{u_1} ι (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) j i → @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j)) ((λ (_x : ι), @has_lt.lt.{u_2} (β _x) ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x)) i (x i) (y i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : decidable_linear_order.{u_1} α] {a b c : α}, iff (@has_lt.lt.{u_1} α (@preorder.to_has_lt.{u_1} α (@partial_order.to_preorder.{u_1} α (@lattice.semilattice_inf.to_partial_order.{u_1} α (@lattice.lattice.to_semilattice_inf.{u_1} α (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_1))))) a (@min.{u_1} α _inst_1 b c)) (and (@has_lt.lt.{u_1} α (@preorder.to_has_lt.{u_1} α (@partial_order.to_preorder.{u_1} α (@lattice.semilattice_inf.to_partial_order.{u_1} α (@lattice.lattice.to_semilattice_inf.{u_1} α (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_1))))) a b) (@has_lt.lt.{u_1} α (@preorder.to_has_lt.{u_1} α (@partial_order.to_preorder.{u_1} α (@lattice.semilattice_inf.to_partial_order.{u_1} α (@lattice.lattice.to_semilattice_inf.{u_1} α (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_1))))) a c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{u_1} ι (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) k (@min.{u_1} ι I i j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (∀ (j_1 : ι), @has_lt.lt.{u_1} ι (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) j_1 j → @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (z j_1)) ((λ (_x : ι), @has_lt.lt.{u_2} (β _x) ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x)) j (y j) (z j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : decidable_linear_order.{u_1} α] {a b c : α}, iff (@has_lt.lt.{u_1} α (@preorder.to_has_lt.{u_1} α (@partial_order.to_preorder.{u_1} α (@lattice.semilattice_inf.to_partial_order.{u_1} α (@lattice.lattice.to_semilattice_inf.{u_1} α (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_1))))) a (@min.{u_1} α _inst_1 b c)) (and (@has_lt.lt.{u_1} α (@preorder.to_has_lt.{u_1} α (@partial_order.to_preorder.{u_1} α (@lattice.semilattice_inf.to_partial_order.{u_1} α (@lattice.lattice.to_semilattice_inf.{u_1} α (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_1))))) a b) (@has_lt.lt.{u_1} α (@preorder.to_has_lt.{u_1} α (@partial_order.to_preorder.{u_1} α (@lattice.semilattice_inf.to_partial_order.{u_1} α (@lattice.lattice.to_semilattice_inf.{u_1} α (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_1))))) a c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{u_1} ι (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) k (@min.{u_1} ι I i j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y z : pilex.{u_1 u_2} ι β,
hxy :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    y,
hyz :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    y
    z,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (z j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (z j))
⊢ ∀ (j_1 : ι),
    @has_lt.lt.{u_1} ι
      (@preorder.to_has_lt.{u_1} ι
         (@partial_order.to_preorder.{u_1} ι
            (@lattice.semilattice_inf.to_partial_order.{u_1} ι
               (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
      j_1
      (@min.{u_1} ι I i j) →
    @eq.{u_2+1} ((λ (a : ι), β a) j_1) (x j_1) (z j_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y z : pilex.{u_1 u_2} ι β,
hxy :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    y,
hyz :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    y
    z,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (z j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (z j)),
k : ι,
hk :
  @has_lt.lt.{u_1} ι
    (@preorder.to_has_lt.{u_1} ι
       (@partial_order.to_preorder.{u_1} ι
          (@lattice.semilattice_inf.to_partial_order.{u_1} ι
             (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
    k
    (@min.{u_1} ι I i j)
⊢ @eq.{u_2+1} ((λ (a : ι), β a) k) (x k) (z k)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y z : pilex.{u_1 u_2} ι β,
hxy :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    y,
hyz :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    y
    z,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (z j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (z j)),
k : ι,
hk :
  @has_lt.lt.{u_1} ι
    (@preorder.to_has_lt.{u_1} ι
       (@partial_order.to_preorder.{u_1} ι
          (@lattice.semilattice_inf.to_partial_order.{u_1} ι
             (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
    k
    (@min.{u_1} ι I i j)
⊢ @eq.{u_2+1} ((λ (a : ι), β a) k) (y k) (z k)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45              by resetI; exact (le_total i j).elim</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='le_total'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 57, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : linear_order.{u_1} α] (a b : α), or (@has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α (@linear_order.to_partial_order.{u_1} α _inst_1))) a b) (@has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α (@linear_order.to_partial_order.{u_1} α _inst_1))) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='Reset the instance cache. This allows any new instances
 added to the context to be used in typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='resetI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y z : pilex.{u_1 u_2} ι β,
hxy :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    y,
hyz :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    y
    z,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (z j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (z j))
⊢ @has_lt.lt.{u_2} (β (@min.{u_1} ι I i j))
    ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))
       (@min.{u_1} ι I i j))
    (x (@min.{u_1} ι I i j))
    (z (@min.{u_1} ι I i j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46                (λ hij, by rw [min_eq_left hij];</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='min_eq_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hij'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : decidable_linear_order.{u_1} α] {a b : α}, @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α (@linear_order.to_partial_order.{u_1} α (@decidable_linear_order.to_linear_order.{u_1} α _inst_1)))) a b → @eq.{u_1+1} α (@min.{u_1} α _inst_1 a b) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{u_1} ι (@preorder.to_has_le.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1))) i j'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y z : pilex.{u_1 u_2} ι β,
hxy :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    y,
hyz :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    y
    z,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (z j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (z j))
⊢ @has_lt.lt.{u_2} (β (@min.{u_1} ι I i j))
    ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))
       (@min.{u_1} ι I i j))
    (x (@min.{u_1} ι I i j))
    (z (@min.{u_1} ι I i j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y z : pilex.{u_1 u_2} ι β,
hxy :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    y,
hyz :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    y
    z,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (z j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (z j)),
hij :
  @has_le.le.{u_1} ι
    (@preorder.to_has_le.{u_1} ι
       (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
    i
    j
⊢ @has_lt.lt.{u_2} (β (@min.{u_1} ι I i j))
    ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))
       (@min.{u_1} ι I i j))
    (x (@min.{u_1} ι I i j))
    (z (@min.{u_1} ι I i j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y z : pilex.{u_1 u_2} ι β,
hxy :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    y,
hyz :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    y
    z,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (z j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (z j)),
hij :
  @has_le.le.{u_1} ι
    (@preorder.to_has_le.{u_1} ι
       (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
    i
    j
⊢ @has_lt.lt.{u_2} (β i)
    ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) i)
    (x i)
    (z i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y z : pilex.{u_1 u_2} ι β,
hxy :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    y,
hyz :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    y
    z,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (z j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (z j)),
hij :
  @has_le.le.{u_1} ι
    (@preorder.to_has_le.{u_1} ι
       (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
    i
    j
⊢ @has_lt.lt.{u_2} (β (@min.{u_1} ι I i j))
    ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))
       (@min.{u_1} ι I i j))
    (x (@min.{u_1} ι I i j))
    (z (@min.{u_1} ι I i j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47                  exact lt_of_lt_of_le hi.2</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='lt_of_lt_of_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 102, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : preorder.{u_2} α] {a b c : α}, @has_lt.lt.{u_2} α (@preorder.to_has_lt.{u_2} α _inst_1) a b → @has_le.le.{u_2} α (@preorder.to_has_le.{u_2} α _inst_1) b c → @has_lt.lt.{u_2} α (@preorder.to_has_lt.{u_2} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (∀ (j : ι), @has_lt.lt.{u_1} ι (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) j i → @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j)) ((λ (_x : ι), @has_lt.lt.{u_2} (β _x) ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x)) i (x i) (y i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y z : pilex.{u_1 u_2} ι β,
hxy :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    y,
hyz :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    y
    z,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (z j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (z j)),
hij :
  @has_le.le.{u_1} ι
    (@preorder.to_has_le.{u_1} ι
       (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
    i
    j
⊢ @has_lt.lt.{u_2} (β (@min.{u_1} ι I i j))
    ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))
       (@min.{u_1} ι I i j))
    (x (@min.{u_1} ι I i j))
    (z (@min.{u_1} ι I i j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48                    ((lt_or_eq_of_le hij).elim (λ h, le_of_eq (hj.1 _ h))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='lt_or_eq_of_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hij'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='le_of_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 124, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : partial_order.{u_1} α] {a b : α}, @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α _inst_1)) a b → or (@has_lt.lt.{u_1} α (@preorder.to_has_lt.{u_1} α (@partial_order.to_preorder.{u_1} α _inst_1)) a b) (@eq.{u_1+1} α a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{u_1} ι (@preorder.to_has_le.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1))) i j'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : preorder.{u_2} α] {a b : α}, @eq.{u_2+1} α a b → @has_le.le.{u_2} α (@preorder.to_has_le.{u_2} α _inst_1) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y z : pilex.{u_1 u_2} ι β,
hxy :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    y,
hyz :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    y
    z,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (z j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (z j)),
hij :
  @has_le.le.{u_1} ι
    (@preorder.to_has_le.{u_1} ι
       (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
    i
    j
⊢ @has_lt.lt.{u_2} (β (@min.{u_1} ι I i j))
    ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))
       (@min.{u_1} ι I i j))
    (x (@min.{u_1} ι I i j))
    (z (@min.{u_1} ι I i j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49                      (λ h, h.symm ▸ le_of_lt hj.2)))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='le_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 99, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {a b : α}, @eq.{u_1+1} α a b → @eq.{u_1+1} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : preorder.{u_2} α] {a b : α}, @has_lt.lt.{u_2} α (@preorder.to_has_lt.{u_2} α _inst_1) a b → @has_le.le.{u_2} α (@preorder.to_has_le.{u_2} α _inst_1) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (∀ (j_1 : ι), @has_lt.lt.{u_1} ι (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) j_1 j → @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (z j_1)) ((λ (_x : ι), @has_lt.lt.{u_2} (β _x) ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x)) j (y j) (z j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y z : pilex.{u_1 u_2} ι β,
hxy :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    y,
hyz :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    y
    z,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (z j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (z j)),
hij :
  @has_le.le.{u_1} ι
    (@preorder.to_has_le.{u_1} ι
       (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
    i
    j
⊢ @has_lt.lt.{u_2} (β (@min.{u_1} ι I i j))
    ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))
       (@min.{u_1} ι I i j))
    (x (@min.{u_1} ι I i j))
    (z (@min.{u_1} ι I i j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y z : pilex.{u_1 u_2} ι β,
hxy :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    y,
hyz :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    y
    z,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (z j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (z j))
⊢ @has_lt.lt.{u_2} (β (@min.{u_1} ι I i j))
    ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))
       (@min.{u_1} ι I i j))
    (x (@min.{u_1} ι I i j))
    (z (@min.{u_1} ι I i j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50                (λ hji, by rw [min_eq_right hji];</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='min_eq_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hji'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : decidable_linear_order.{u_1} α] {a b : α}, @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α (@linear_order.to_partial_order.{u_1} α (@decidable_linear_order.to_linear_order.{u_1} α _inst_1)))) b a → @eq.{u_1+1} α (@min.{u_1} α _inst_1 a b) b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{u_1} ι (@preorder.to_has_le.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1))) j i'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y z : pilex.{u_1 u_2} ι β,
hxy :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    y,
hyz :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    y
    z,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (z j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (z j))
⊢ @has_lt.lt.{u_2} (β (@min.{u_1} ι I i j))
    ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))
       (@min.{u_1} ι I i j))
    (x (@min.{u_1} ι I i j))
    (z (@min.{u_1} ι I i j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y z : pilex.{u_1 u_2} ι β,
hxy :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    y,
hyz :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    y
    z,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (z j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (z j)),
hji :
  @has_le.le.{u_1} ι
    (@preorder.to_has_le.{u_1} ι
       (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
    j
    i
⊢ @has_lt.lt.{u_2} (β (@min.{u_1} ι I i j))
    ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))
       (@min.{u_1} ι I i j))
    (x (@min.{u_1} ι I i j))
    (z (@min.{u_1} ι I i j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y z : pilex.{u_1 u_2} ι β,
hxy :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    y,
hyz :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    y
    z,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (z j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (z j)),
hji :
  @has_le.le.{u_1} ι
    (@preorder.to_has_le.{u_1} ι
       (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
    j
    i
⊢ @has_lt.lt.{u_2} (β j)
    ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) j)
    (x j)
    (z j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y z : pilex.{u_1 u_2} ι β,
hxy :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    y,
hyz :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    y
    z,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (z j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (z j)),
hji :
  @has_le.le.{u_1} ι
    (@preorder.to_has_le.{u_1} ι
       (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
    j
    i
⊢ @has_lt.lt.{u_2} (β (@min.{u_1} ι I i j))
    ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))
       (@min.{u_1} ι I i j))
    (x (@min.{u_1} ι I i j))
    (z (@min.{u_1} ι I i j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51                  exact lt_of_le_of_lt</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='lt_of_le_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 107, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : preorder.{u_2} α] {a b c : α}, @has_le.le.{u_2} α (@preorder.to_has_le.{u_2} α _inst_1) a b → @has_lt.lt.{u_2} α (@preorder.to_has_lt.{u_2} α _inst_1) b c → @has_lt.lt.{u_2} α (@preorder.to_has_lt.{u_2} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y z : pilex.{u_1 u_2} ι β,
hxy :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    y,
hyz :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    y
    z,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (z j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (z j)),
hji :
  @has_le.le.{u_1} ι
    (@preorder.to_has_le.{u_1} ι
       (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
    j
    i
⊢ @has_lt.lt.{u_2} (β (@min.{u_1} ι I i j))
    ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))
       (@min.{u_1} ι I i j))
    (x (@min.{u_1} ι I i j))
    (z (@min.{u_1} ι I i j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52                    ((lt_or_eq_of_le hji).elim (λ h, le_of_eq (hi.1 _ h))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='lt_or_eq_of_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hji'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='le_of_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 124, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : partial_order.{u_1} α] {a b : α}, @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α _inst_1)) a b → or (@has_lt.lt.{u_1} α (@preorder.to_has_lt.{u_1} α (@partial_order.to_preorder.{u_1} α _inst_1)) a b) (@eq.{u_1+1} α a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{u_1} ι (@preorder.to_has_le.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1))) j i'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : preorder.{u_2} α] {a b : α}, @eq.{u_2+1} α a b → @has_le.le.{u_2} α (@preorder.to_has_le.{u_2} α _inst_1) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y z : pilex.{u_1 u_2} ι β,
hxy :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    y,
hyz :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    y
    z,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (z j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (z j)),
hji :
  @has_le.le.{u_1} ι
    (@preorder.to_has_le.{u_1} ι
       (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
    j
    i
⊢ @has_lt.lt.{u_2} (β (@min.{u_1} ι I i j))
    ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))
       (@min.{u_1} ι I i j))
    (x (@min.{u_1} ι I i j))
    (z (@min.{u_1} ι I i j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53                      (λ h, h.symm ▸ le_of_lt hi.2))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='le_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 99, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : preorder.{u_2} α] {a b : α}, @has_lt.lt.{u_2} α (@preorder.to_has_lt.{u_2} α _inst_1) a b → @has_le.le.{u_2} α (@preorder.to_has_le.{u_2} α _inst_1) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (∀ (j : ι), @has_lt.lt.{u_1} ι (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) j i → @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j)) ((λ (_x : ι), @has_lt.lt.{u_2} (β _x) ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x)) i (x i) (y i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y z : pilex.{u_1 u_2} ι β,
hxy :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    y,
hyz :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    y
    z,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (z j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (z j)),
hji :
  @has_le.le.{u_1} ι
    (@preorder.to_has_le.{u_1} ι
       (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
    j
    i
⊢ @has_lt.lt.{u_2} (β (@min.{u_1} ι I i j))
    ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))
       (@min.{u_1} ι I i j))
    (x (@min.{u_1} ι I i j))
    (z (@min.{u_1} ι I i j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54                    hj.2)⟩)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='hj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (∀ (j_1 : ι), @has_lt.lt.{u_1} ι (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) j_1 j → @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (z j_1)) ((λ (_x : ι), @has_lt.lt.{u_2} (β _x) ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x)) j (y j) (z j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y z : pilex.{u_1 u_2} ι β,
hxy :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    y,
hyz :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    y
    z,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (z j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (z j)),
hji :
  @has_le.le.{u_1} ι
    (@preorder.to_has_le.{u_1} ι
       (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
    j
    i
⊢ @has_lt.lt.{u_2} (β (@min.{u_1} ι I i j))
    ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))
       (@min.{u_1} ι I i j))
    (x (@min.{u_1} ι I i j))
    (z (@min.{u_1} ι I i j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y z : pilex.{u_1 u_2} ι β,
hxy :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    y,
hyz :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    y
    z,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    z →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (λ (x y : pilex.{u_1 u_2} ι β),
          or
            (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@pilex.has_lt.{u_1 u_2} ι β
                  (@preorder.to_has_lt.{u_1} ι
                     (@partial_order.to_preorder.{u_1} ι
                        (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                           (@lattice.lattice.to_semilattice_inf.{u_1} ι
                              (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                  (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
               x
               y)
            (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)))
    x
    z,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (z j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (z j))
⊢ @has_lt.lt.{u_2} (β (@min.{u_1} ι I i j))
    ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))
       (@min.{u_1} ι I i j))
    (x (@min.{u_1} ι I i j))
    (z (@min.{u_1} ι I i j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55          (λ hyz, hyz ▸ hxy))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='hyz'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hyz'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hxy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type (max u_1 u_2)} {P : α → Prop} {a b : α}, @eq.{(max u_1 u_2)+1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (λ (x y : pilex.{u_1 u_2} ι β), or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56        (λ hxy, hxy.symm ▸ hyz),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='hxy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hxy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hyz'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (max u_1 u_2)} {a b : α}, @eq.{(max u_1 u_2)+1} α a b → @eq.{(max u_1 u_2)+1} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type (max u_1 u_2)} {P : α → Prop} {a b : α}, @eq.{(max u_1 u_2)+1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@has_le.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (λ (x y : pilex.{u_1 u_2} ι β), or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))) y z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57    lt_iff_le_not_le := λ x y, show x &lt; y ↔ (x &lt; y ∨ x = y) ∧ ¬ (y &lt; x ∨ y = x),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='or'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='not'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='or'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u_1 u_2)} [c : has_lt.{(max u_1 u_2)} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u_1 u_2)} [c : has_lt.{(max u_1 u_2)} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u_1 u_2)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u_1 u_2)} [c : has_lt.{(max u_1 u_2)} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u_1 u_2)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58      from ⟨λ ⟨i, hi⟩, ⟨or.inl ⟨i, hi⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='or.inl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='and (∀ (j : ι), @has_lt.lt.{u_1} ι (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) j i → @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j)) ((λ (_x : ι), @has_lt.lt.{u_2} (β _x) ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x)) i (x i) (y i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {a b : Prop}, a → or a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59          λ h, h.elim (λ ⟨j, hj⟩, begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='or.elim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 202, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='or (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x) (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b c : Prop}, or a b → (a → c) → (b → c) → c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a)))) y x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y : pilex.{u_1 u_2} ι β,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  and
    (or
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
             (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
          x
          y)
       (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
    (not
       (or
          (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@pilex.has_lt.{u_1 u_2} ι β
                (@preorder.to_has_lt.{u_1} ι
                   (@partial_order.to_preorder.{u_1} ι
                      (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                         (@lattice.lattice.to_semilattice_inf.{u_1} ι
                            (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
             y
             x)
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))),
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
h :
  or
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι
                (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                   (@lattice.lattice.to_semilattice_inf.{u_1} ι
                      (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       y
       x)
    (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x →
  false,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (x j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (x j))
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60              rcases lt_trichotomy i j with hij | hij | hji,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='lt_trichotomy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : linear_order.{u_1} α] (a b : α), or (@has_lt.lt.{u_1} α (@preorder.to_has_lt.{u_1} α (@partial_order.to_preorder.{u_1} α (@linear_order.to_partial_order.{u_1} α _inst_1))) a b) (or (@eq.{u_1+1} α a b) (@has_lt.lt.{u_1} α (@preorder.to_has_lt.{u_1} α (@partial_order.to_preorder.{u_1} α (@linear_order.to_partial_order.{u_1} α _inst_1))) b a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y : pilex.{u_1 u_2} ι β,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  and
    (or
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
             (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
          x
          y)
       (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
    (not
       (or
          (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@pilex.has_lt.{u_1 u_2} ι β
                (@preorder.to_has_lt.{u_1} ι
                   (@partial_order.to_preorder.{u_1} ι
                      (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                         (@lattice.lattice.to_semilattice_inf.{u_1} ι
                            (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
             y
             x)
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))),
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
h :
  or
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι
                (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                   (@lattice.lattice.to_semilattice_inf.{u_1} ι
                      (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       y
       x)
    (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x →
  false,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (x j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (x j))
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y : pilex.{u_1 u_2} ι β,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  and
    (or
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
             (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
          x
          y)
       (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
    (not
       (or
          (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@pilex.has_lt.{u_1 u_2} ι β
                (@preorder.to_has_lt.{u_1} ι
                   (@partial_order.to_preorder.{u_1} ι
                      (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                         (@lattice.lattice.to_semilattice_inf.{u_1} ι
                            (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
             y
             x)
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))),
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
h :
  or
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι
                (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                   (@lattice.lattice.to_semilattice_inf.{u_1} ι
                      (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       y
       x)
    (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x →
  false,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (x j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (x j)),
hij :
  @has_lt.lt.{u_1} ι
    (@preorder.to_has_lt.{u_1} ι
       (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
    i
    j
⊢ false

ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y : pilex.{u_1 u_2} ι β,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  and
    (or
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
             (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
          x
          y)
       (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
    (not
       (or
          (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@pilex.has_lt.{u_1 u_2} ι β
                (@preorder.to_has_lt.{u_1} ι
                   (@partial_order.to_preorder.{u_1} ι
                      (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                         (@lattice.lattice.to_semilattice_inf.{u_1} ι
                            (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
             y
             x)
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))),
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
h :
  or
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι
                (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                   (@lattice.lattice.to_semilattice_inf.{u_1} ι
                      (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       y
       x)
    (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x →
  false,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (x j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (x j)),
hij : @eq.{u_1+1} ι i j
⊢ false

ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y : pilex.{u_1 u_2} ι β,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  and
    (or
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
             (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
          x
          y)
       (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
    (not
       (or
          (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@pilex.has_lt.{u_1 u_2} ι β
                (@preorder.to_has_lt.{u_1} ι
                   (@partial_order.to_preorder.{u_1} ι
                      (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                         (@lattice.lattice.to_semilattice_inf.{u_1} ι
                            (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
             y
             x)
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))),
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
h :
  or
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι
                (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                   (@lattice.lattice.to_semilattice_inf.{u_1} ι
                      (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       y
       x)
    (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x →
  false,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (x j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (x j)),
hji :
  @has_lt.lt.{u_1} ι
    (@preorder.to_has_lt.{u_1} ι
       (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
    j
    i
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61              { exact lt_irrefl (x i) (by simpa [hj.1 _ hij] using hi.2) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='lt_irrefl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='hj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='hij'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : preorder.{u_2} α] (a : α), not (@has_lt.lt.{u_2} α (@preorder.to_has_lt.{u_2} α _inst_1) a a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (∀ (j_1 : ι), @has_lt.lt.{u_1} ι (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) j_1 j → @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (x j_1)) ((λ (_x : ι), @has_lt.lt.{u_2} (β _x) ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x)) j (y j) (x j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{u_1} ι (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1))) i j'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (∀ (j : ι), @has_lt.lt.{u_1} ι (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) j i → @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j)) ((λ (_x : ι), @has_lt.lt.{u_2} (β _x) ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x)) i (x i) (y i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y : pilex.{u_1 u_2} ι β,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  and
    (or
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
             (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
          x
          y)
       (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
    (not
       (or
          (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@pilex.has_lt.{u_1 u_2} ι β
                (@preorder.to_has_lt.{u_1} ι
                   (@partial_order.to_preorder.{u_1} ι
                      (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                         (@lattice.lattice.to_semilattice_inf.{u_1} ι
                            (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
             y
             x)
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))),
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
h :
  or
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι
                (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                   (@lattice.lattice.to_semilattice_inf.{u_1} ι
                      (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       y
       x)
    (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x →
  false,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (x j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (x j)),
hij :
  @has_lt.lt.{u_1} ι
    (@preorder.to_has_lt.{u_1} ι
       (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
    i
    j
⊢ false

ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y : pilex.{u_1 u_2} ι β,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  and
    (or
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
             (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
          x
          y)
       (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
    (not
       (or
          (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@pilex.has_lt.{u_1 u_2} ι β
                (@preorder.to_has_lt.{u_1} ι
                   (@partial_order.to_preorder.{u_1} ι
                      (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                         (@lattice.lattice.to_semilattice_inf.{u_1} ι
                            (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
             y
             x)
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))),
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
h :
  or
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι
                (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                   (@lattice.lattice.to_semilattice_inf.{u_1} ι
                      (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       y
       x)
    (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x →
  false,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (x j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (x j)),
hij : @eq.{u_1+1} ι i j
⊢ false

ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y : pilex.{u_1 u_2} ι β,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  and
    (or
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
             (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
          x
          y)
       (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
    (not
       (or
          (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@pilex.has_lt.{u_1 u_2} ι β
                (@preorder.to_has_lt.{u_1} ι
                   (@partial_order.to_preorder.{u_1} ι
                      (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                         (@lattice.lattice.to_semilattice_inf.{u_1} ι
                            (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
             y
             x)
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))),
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
h :
  or
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι
                (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                   (@lattice.lattice.to_semilattice_inf.{u_1} ι
                      (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       y
       x)
    (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x →
  false,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (x j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (x j)),
hji :
  @has_lt.lt.{u_1} ι
    (@preorder.to_has_lt.{u_1} ι
       (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
    j
    i
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y : pilex.{u_1 u_2} ι β,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  and
    (or
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
             (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
          x
          y)
       (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
    (not
       (or
          (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@pilex.has_lt.{u_1 u_2} ι β
                (@preorder.to_has_lt.{u_1} ι
                   (@partial_order.to_preorder.{u_1} ι
                      (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                         (@lattice.lattice.to_semilattice_inf.{u_1} ι
                            (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
             y
             x)
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))),
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
h :
  or
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι
                (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                   (@lattice.lattice.to_semilattice_inf.{u_1} ι
                      (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       y
       x)
    (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x →
  false,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (x j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (x j)),
hij :
  @has_lt.lt.{u_1} ι
    (@preorder.to_has_lt.{u_1} ι
       (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
    i
    j
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y : pilex.{u_1 u_2} ι β,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  and
    (or
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
             (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
          x
          y)
       (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
    (not
       (or
          (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@pilex.has_lt.{u_1 u_2} ι β
                (@preorder.to_has_lt.{u_1} ι
                   (@partial_order.to_preorder.{u_1} ι
                      (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                         (@lattice.lattice.to_semilattice_inf.{u_1} ι
                            (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
             y
             x)
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))),
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
h :
  or
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι
                (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                   (@lattice.lattice.to_semilattice_inf.{u_1} ι
                      (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       y
       x)
    (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x →
  false,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (x j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (x j)),
hij :
  @has_lt.lt.{u_1} ι
    (@preorder.to_has_lt.{u_1} ι
       (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
    i
    j
⊢ @has_lt.lt.{u_2} (β i) (@preorder.to_has_lt.{u_2} (β i) (@partial_order.to_preorder.{u_2} (β i) (_inst_2 i)))
    (x i)
    (x i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y : pilex.{u_1 u_2} ι β,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  and
    (or
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
             (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
          x
          y)
       (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
    (not
       (or
          (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@pilex.has_lt.{u_1 u_2} ι β
                (@preorder.to_has_lt.{u_1} ι
                   (@partial_order.to_preorder.{u_1} ι
                      (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                         (@lattice.lattice.to_semilattice_inf.{u_1} ι
                            (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
             y
             x)
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))),
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
h :
  or
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι
                (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                   (@lattice.lattice.to_semilattice_inf.{u_1} ι
                      (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       y
       x)
    (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x →
  false,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (x j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (x j)),
hij :
  @has_lt.lt.{u_1} ι
    (@preorder.to_has_lt.{u_1} ι
       (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
    i
    j
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y : pilex.{u_1 u_2} ι β,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  and
    (or
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
             (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
          x
          y)
       (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
    (not
       (or
          (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@pilex.has_lt.{u_1 u_2} ι β
                (@preorder.to_has_lt.{u_1} ι
                   (@partial_order.to_preorder.{u_1} ι
                      (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                         (@lattice.lattice.to_semilattice_inf.{u_1} ι
                            (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
             y
             x)
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))),
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
h :
  or
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι
                (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                   (@lattice.lattice.to_semilattice_inf.{u_1} ι
                      (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       y
       x)
    (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x →
  false,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (x j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (x j)),
hij : @eq.{u_1+1} ι i j
⊢ false

ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y : pilex.{u_1 u_2} ι β,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  and
    (or
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
             (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
          x
          y)
       (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
    (not
       (or
          (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@pilex.has_lt.{u_1 u_2} ι β
                (@preorder.to_has_lt.{u_1} ι
                   (@partial_order.to_preorder.{u_1} ι
                      (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                         (@lattice.lattice.to_semilattice_inf.{u_1} ι
                            (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
             y
             x)
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))),
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
h :
  or
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι
                (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                   (@lattice.lattice.to_semilattice_inf.{u_1} ι
                      (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       y
       x)
    (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x →
  false,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (x j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (x j)),
hji :
  @has_lt.lt.{u_1} ι
    (@preorder.to_has_lt.{u_1} ι
       (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
    j
    i
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62              { exact not_le_of_gt hj.2 (hij ▸ le_of_lt hi.2) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='not_le_of_gt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hij'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='le_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 118, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 99, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : preorder.{u_2} α] {a b : α}, @gt.{u_2} α (@preorder.to_has_lt.{u_2} α _inst_1) a b → not (@has_le.le.{u_2} α (@preorder.to_has_le.{u_2} α _inst_1) a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (∀ (j_1 : ι), @has_lt.lt.{u_1} ι (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) j_1 j → @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (x j_1)) ((λ (_x : ι), @has_lt.lt.{u_2} (β _x) ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x)) j (y j) (x j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{u_1+1} ι i j'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : preorder.{u_2} α] {a b : α}, @has_lt.lt.{u_2} α (@preorder.to_has_lt.{u_2} α _inst_1) a b → @has_le.le.{u_2} α (@preorder.to_has_le.{u_2} α _inst_1) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (∀ (j : ι), @has_lt.lt.{u_1} ι (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) j i → @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j)) ((λ (_x : ι), @has_lt.lt.{u_2} (β _x) ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x)) i (x i) (y i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y : pilex.{u_1 u_2} ι β,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  and
    (or
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
             (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
          x
          y)
       (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
    (not
       (or
          (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@pilex.has_lt.{u_1 u_2} ι β
                (@preorder.to_has_lt.{u_1} ι
                   (@partial_order.to_preorder.{u_1} ι
                      (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                         (@lattice.lattice.to_semilattice_inf.{u_1} ι
                            (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
             y
             x)
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))),
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
h :
  or
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι
                (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                   (@lattice.lattice.to_semilattice_inf.{u_1} ι
                      (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       y
       x)
    (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x →
  false,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (x j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (x j)),
hij : @eq.{u_1+1} ι i j
⊢ false

ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y : pilex.{u_1 u_2} ι β,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  and
    (or
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
             (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
          x
          y)
       (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
    (not
       (or
          (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@pilex.has_lt.{u_1 u_2} ι β
                (@preorder.to_has_lt.{u_1} ι
                   (@partial_order.to_preorder.{u_1} ι
                      (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                         (@lattice.lattice.to_semilattice_inf.{u_1} ι
                            (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
             y
             x)
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))),
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
h :
  or
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι
                (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                   (@lattice.lattice.to_semilattice_inf.{u_1} ι
                      (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       y
       x)
    (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x →
  false,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (x j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (x j)),
hji :
  @has_lt.lt.{u_1} ι
    (@preorder.to_has_lt.{u_1} ι
       (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
    j
    i
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y : pilex.{u_1 u_2} ι β,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  and
    (or
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
             (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
          x
          y)
       (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
    (not
       (or
          (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@pilex.has_lt.{u_1 u_2} ι β
                (@preorder.to_has_lt.{u_1} ι
                   (@partial_order.to_preorder.{u_1} ι
                      (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                         (@lattice.lattice.to_semilattice_inf.{u_1} ι
                            (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
             y
             x)
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))),
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
h :
  or
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι
                (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                   (@lattice.lattice.to_semilattice_inf.{u_1} ι
                      (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       y
       x)
    (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x →
  false,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (x j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (x j)),
hij : @eq.{u_1+1} ι i j
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y : pilex.{u_1 u_2} ι β,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  and
    (or
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
             (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
          x
          y)
       (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
    (not
       (or
          (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@pilex.has_lt.{u_1 u_2} ι β
                (@preorder.to_has_lt.{u_1} ι
                   (@partial_order.to_preorder.{u_1} ι
                      (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                         (@lattice.lattice.to_semilattice_inf.{u_1} ι
                            (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
             y
             x)
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))),
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
h :
  or
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι
                (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                   (@lattice.lattice.to_semilattice_inf.{u_1} ι
                      (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       y
       x)
    (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x →
  false,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (x j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (x j)),
hji :
  @has_lt.lt.{u_1} ι
    (@preorder.to_has_lt.{u_1} ι
       (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
    j
    i
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63              { exact lt_irrefl (x j) (by simpa [hi.1 _ hji] using hj.2) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='lt_irrefl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='hji'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : preorder.{u_2} α] (a : α), not (@has_lt.lt.{u_2} α (@preorder.to_has_lt.{u_2} α _inst_1) a a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (∀ (j : ι), @has_lt.lt.{u_1} ι (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) j i → @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j)) ((λ (_x : ι), @has_lt.lt.{u_2} (β _x) ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x)) i (x i) (y i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{u_1} ι (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1))) j i'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (∀ (j_1 : ι), @has_lt.lt.{u_1} ι (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) j_1 j → @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (x j_1)) ((λ (_x : ι), @has_lt.lt.{u_2} (β _x) ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x)) j (y j) (x j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y : pilex.{u_1 u_2} ι β,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  and
    (or
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
             (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
          x
          y)
       (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
    (not
       (or
          (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@pilex.has_lt.{u_1 u_2} ι β
                (@preorder.to_has_lt.{u_1} ι
                   (@partial_order.to_preorder.{u_1} ι
                      (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                         (@lattice.lattice.to_semilattice_inf.{u_1} ι
                            (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
             y
             x)
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))),
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
h :
  or
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι
                (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                   (@lattice.lattice.to_semilattice_inf.{u_1} ι
                      (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       y
       x)
    (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x →
  false,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (x j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (x j)),
hji :
  @has_lt.lt.{u_1} ι
    (@preorder.to_has_lt.{u_1} ι
       (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
    j
    i
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y : pilex.{u_1 u_2} ι β,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  and
    (or
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
             (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
          x
          y)
       (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
    (not
       (or
          (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@pilex.has_lt.{u_1 u_2} ι β
                (@preorder.to_has_lt.{u_1} ι
                   (@partial_order.to_preorder.{u_1} ι
                      (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                         (@lattice.lattice.to_semilattice_inf.{u_1} ι
                            (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
             y
             x)
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))),
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
h :
  or
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι
                (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                   (@lattice.lattice.to_semilattice_inf.{u_1} ι
                      (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       y
       x)
    (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x →
  false,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (x j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (x j)),
hji :
  @has_lt.lt.{u_1} ι
    (@preorder.to_has_lt.{u_1} ι
       (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
    j
    i
⊢ @has_lt.lt.{u_2} (β j) (@preorder.to_has_lt.{u_2} (β j) (@partial_order.to_preorder.{u_2} (β j) (_inst_2 j)))
    (x j)
    (x j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y : pilex.{u_1 u_2} ι β,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  and
    (or
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
             (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
          x
          y)
       (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
    (not
       (or
          (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@pilex.has_lt.{u_1 u_2} ι β
                (@preorder.to_has_lt.{u_1} ι
                   (@partial_order.to_preorder.{u_1} ι
                      (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                         (@lattice.lattice.to_semilattice_inf.{u_1} ι
                            (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
             y
             x)
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))),
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
h :
  or
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι
                (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                   (@lattice.lattice.to_semilattice_inf.{u_1} ι
                      (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       y
       x)
    (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x),
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    y
    x →
  false,
j : ι,
hj :
  and
    (∀ (j_1 : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j_1
         j →
       @eq.{u_2+1} ((λ (a : ι), β a) j_1) (y j_1) (x j_1))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       j
       (y j)
       (x j)),
hji :
  @has_lt.lt.{u_1} ι
    (@preorder.to_has_lt.{u_1} ι
       (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
    j
    i
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64            end)</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65          (λ hyx, lt_irrefl (x i) (by simpa [hyx] using hi.2))⟩, by tauto⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='hyx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lt_irrefl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='hyx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/tauto.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] (a : α), not (@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (∀ (j : ι), @has_lt.lt.{u_1} ι (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι I))))) j i → @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j)) ((λ (_x : ι), @has_lt.lt.{u_2} (β _x) ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x)) i (x i) (y i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`tauto` breaks down assumptions of the form `_ ∧ _`, `_ ∨ _`, `_ ↔ _` and `∃ _, _`
and splits a goal of the form `_ ∧ _`, `_ ↔ _` or `∃ _, _` until it can be discharged
using `reflexivity` or `solve_by_elim`.
This is a finishing tactic: it either closes the goal of raises an error.
The variant `tauto!` uses the law of excluded middle.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='tauto'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y : pilex.{u_1 u_2} ι β,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y →
  and
    (or
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
             (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
          x
          y)
       (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
    (not
       (or
          (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@pilex.has_lt.{u_1 u_2} ι β
                (@preorder.to_has_lt.{u_1} ι
                   (@partial_order.to_preorder.{u_1} ι
                      (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                         (@lattice.lattice.to_semilattice_inf.{u_1} ι
                            (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
             y
             x)
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))),
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))) _x))
       i
       (x i)
       (y i)),
h :
  or
    (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@pilex.has_lt.{u_1 u_2} ι β
          (@preorder.to_has_lt.{u_1} ι
             (@partial_order.to_preorder.{u_1} ι
                (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                   (@lattice.lattice.to_semilattice_inf.{u_1} ι
                      (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
          (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
       y
       x)
    (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x),
hyx : @eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x
⊢ @has_lt.lt.{u_2} (β i) (@preorder.to_has_lt.{u_2} (β i) (@partial_order.to_preorder.{u_2} (β i) (_inst_2 i)))
    (x i)
    (x i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), partial_order.{u_2} (β a),
I : decidable_linear_order.{u_1} ι := @classical.DLO.{u_1} ι _inst_1,
lt_not_symm :
  ∀ {x y : pilex.{u_1 u_2} ι β},
    not
      (and
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            x
            y)
         (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@pilex.has_lt.{u_1 u_2} ι β
               (@preorder.to_has_lt.{u_1} ι
                  (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
               (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
            y
            x)),
x y : pilex.{u_1 u_2} ι β
⊢ and
    (or
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
             (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
          x
          y)
       (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
    (not
       (or
          (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@pilex.has_lt.{u_1 u_2} ι β
                (@preorder.to_has_lt.{u_1} ι
                   (@partial_order.to_preorder.{u_1} ι
                      (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                         (@lattice.lattice.to_semilattice_inf.{u_1} ι
                            (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
                (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
             y
             x)
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) y x))) →
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι I)))))
       (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) (_inst_2 a))))
    x
    y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66    ..pilex.has_lt }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='pilex.has_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {ι : Type u_1} {β : ι → Type u_2} [_inst_1 : has_lt.{u_1} ι] [_inst_2 : Π (a : ι), has_lt.{u_2} (β a)], has_lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68  /-- `pilex` is a linear order if the original order is well-founded.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69  This cannot be an instance, since it depends on the well-foundedness of `&lt;`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  protected def pilex.linear_order [linear_order ι] (wf : well_founded ((&lt;) : ι → ι → Prop))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='linear_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='well_founded'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/wf.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Sort u}, (α → α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [c : has_lt.{u_1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71    [∀ a, linear_order (β a)] : linear_order (pilex ι β) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='linear_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='linear_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pilex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 15, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1), (α → Type u_2) → Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72  { le_total := λ x y, by classical; exact</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 125, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='Make every propositions in the context decidable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='classical'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
wf :
  @well_founded.{u_1+1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))),
_inst_2 : Π (a : ι), linear_order.{u_2} (β a),
x y : pilex.{u_1 u_2} ι β
⊢ or
    (@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
       x
       y)
    (@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
       y
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73      or_iff_not_imp_left.2 (λ hxy, begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='or_iff_not_imp_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 244, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop} [_inst_1 : decidable a], iff (or a b) (not a → b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
wf :
  @well_founded.{u_1+1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))),
_inst_2 : Π (a : ι), linear_order.{u_2} (β a),
x y : pilex.{u_1 u_2} ι β
⊢ or
    (@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
       x
       y)
    (@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
       y
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
wf :
  @well_founded.{u_1+1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))),
_inst_2 : Π (a : ι), linear_order.{u_2} (β a),
x y : pilex.{u_1 u_2} ι β,
_inst : Π (a : Prop), decidable a,
hxy :
  not
    (@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
       x
       y)
⊢ @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
    y
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74        have := not_or_distrib.1 hxy,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='not_or_distrib'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hxy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 366, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff (not (or a b)) (and (not a) (not b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.partial_order.{u_1 u_2} ι β _inst_1 (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))) (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.partial_order.{u_1 u_2} ι β _inst_1 (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))) (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.partial_order.{u_1 u_2} ι β _inst_1 (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))) (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.partial_order.{u_1 u_2} ι β _inst_1 (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))) (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.partial_order.{u_1 u_2} ι β _inst_1 (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))) (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.partial_order.{u_1 u_2} ι β _inst_1 (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))))) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
wf :
  @well_founded.{u_1+1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))),
_inst_2 : Π (a : ι), linear_order.{u_2} (β a),
x y : pilex.{u_1 u_2} ι β,
_inst : Π (a : Prop), decidable a,
hxy :
  not
    (@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
       x
       y)
⊢ @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
    y
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
wf :
  @well_founded.{u_1+1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))),
_inst_2 : Π (a : ι), linear_order.{u_2} (β a),
x y : pilex.{u_1 u_2} ι β,
_inst : Π (a : Prop), decidable a,
hxy :
  not
    (@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
       x
       y),
this :
  and
    (not
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1))))))
             (λ (a : ι),
                @preorder.to_has_lt.{u_2} (β a)
                  (@partial_order.to_preorder.{u_2} (β a)
                     ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
          x
          y))
    (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
⊢ @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
    y
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75        let i : ι := well_founded.min wf _ (classical.not_forall.1 (this.2 ∘ funext)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='well_founded.min'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='wf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='classical.not_forall'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 519, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 576, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/funext.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {r : α → α → Prop}, @well_founded.{u_1+1} α r → Π (p : set.{u_1} α), @set.nonempty.{u_1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@well_founded.{u_1+1} ι (@has_lt.lt.{u_1} ι (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {p : α → Prop}, iff (not (∀ (x : α), p x)) (@Exists.{u_1+1} α (λ (x : α), not (p x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='and (not (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1)))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a)))) x y)) (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β φ : Prop}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : α → Type u_2} {f₁ f₂ : Π (x : α), β x}, (∀ (x : α), @eq.{u_2+1} (β x) (f₁ x) (f₂ x)) → @eq.{(max (u_1+1) (u_2+1))} (Π (x : α), β x) f₁ f₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The minimum element of a nonempty set in a well-founded order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
wf :
  @well_founded.{u_1+1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))),
_inst_2 : Π (a : ι), linear_order.{u_2} (β a),
x y : pilex.{u_1 u_2} ι β,
_inst : Π (a : Prop), decidable a,
hxy :
  not
    (@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
       x
       y),
this :
  and
    (not
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1))))))
             (λ (a : ι),
                @preorder.to_has_lt.{u_2} (β a)
                  (@partial_order.to_preorder.{u_2} (β a)
                     ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
          x
          y))
    (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
⊢ @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
    y
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
wf :
  @well_founded.{u_1+1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))),
_inst_2 : Π (a : ι), linear_order.{u_2} (β a),
x y : pilex.{u_1 u_2} ι β,
_inst : Π (a : Prop), decidable a,
hxy :
  not
    (@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
       x
       y),
this :
  and
    (not
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1))))))
             (λ (a : ι),
                @preorder.to_has_lt.{u_2} (β a)
                  (@partial_order.to_preorder.{u_2} (β a)
                     ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
          x
          y))
    (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)),
i : ι :=
  @well_founded.min.{u_1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1))))
    wf
    (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1) → false)
    (@iff.mp (not (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@Exists.{u_1+1} ι (λ (x_1 : ι), not (@eq.{u_2+1} (β x_1) (x x_1) (y x_1))))
       (@classical.not_forall.{u_1+1} ι (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@function.comp.{0 0 0} (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1))
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)
          false
          (@and.right
             (not
                (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.has_lt.{u_1 u_2} ι β
                      (@preorder.to_has_lt.{u_1} ι
                         (@partial_order.to_preorder.{u_1} ι
                            (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                               (@lattice.lattice.to_semilattice_inf.{u_1} ι
                                  (@lattice.lattice_of_decidable_linear_order.{u_1} ι
                                     (@classical.DLO.{u_1} ι _inst_1))))))
                      (λ (a : ι),
                         @preorder.to_has_lt.{u_2} (β a)
                           (@partial_order.to_preorder.{u_2} (β a)
                              ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
                   x
                   y))
             (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
             this)
          (@funext.{u_1+1 u_2+1} ι (λ (x : ι), β x) x y)))
⊢ @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
    y
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76        have hjiyx : ∀ j &lt; i, y j = x j,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
wf :
  @well_founded.{u_1+1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))),
_inst_2 : Π (a : ι), linear_order.{u_2} (β a),
x y : pilex.{u_1 u_2} ι β,
_inst : Π (a : Prop), decidable a,
hxy :
  not
    (@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
       x
       y),
this :
  and
    (not
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1))))))
             (λ (a : ι),
                @preorder.to_has_lt.{u_2} (β a)
                  (@partial_order.to_preorder.{u_2} (β a)
                     ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
          x
          y))
    (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)),
i : ι :=
  @well_founded.min.{u_1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1))))
    wf
    (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1) → false)
    (@iff.mp (not (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@Exists.{u_1+1} ι (λ (x_1 : ι), not (@eq.{u_2+1} (β x_1) (x x_1) (y x_1))))
       (@classical.not_forall.{u_1+1} ι (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@function.comp.{0 0 0} (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1))
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)
          false
          (@and.right
             (not
                (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.has_lt.{u_1 u_2} ι β
                      (@preorder.to_has_lt.{u_1} ι
                         (@partial_order.to_preorder.{u_1} ι
                            (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                               (@lattice.lattice.to_semilattice_inf.{u_1} ι
                                  (@lattice.lattice_of_decidable_linear_order.{u_1} ι
                                     (@classical.DLO.{u_1} ι _inst_1))))))
                      (λ (a : ι),
                         @preorder.to_has_lt.{u_2} (β a)
                           (@partial_order.to_preorder.{u_2} (β a)
                              ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
                   x
                   y))
             (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
             this)
          (@funext.{u_1+1 u_2+1} ι (λ (x : ι), β x) x y)))
⊢ @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
    y
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
wf :
  @well_founded.{u_1+1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))),
_inst_2 : Π (a : ι), linear_order.{u_2} (β a),
x y : pilex.{u_1 u_2} ι β,
_inst : Π (a : Prop), decidable a,
hxy :
  not
    (@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
       x
       y),
this :
  and
    (not
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1))))))
             (λ (a : ι),
                @preorder.to_has_lt.{u_2} (β a)
                  (@partial_order.to_preorder.{u_2} (β a)
                     ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
          x
          y))
    (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)),
i : ι :=
  @well_founded.min.{u_1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1))))
    wf
    (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1) → false)
    (@iff.mp (not (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@Exists.{u_1+1} ι (λ (x_1 : ι), not (@eq.{u_2+1} (β x_1) (x x_1) (y x_1))))
       (@classical.not_forall.{u_1+1} ι (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@function.comp.{0 0 0} (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1))
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)
          false
          (@and.right
             (not
                (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.has_lt.{u_1 u_2} ι β
                      (@preorder.to_has_lt.{u_1} ι
                         (@partial_order.to_preorder.{u_1} ι
                            (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                               (@lattice.lattice.to_semilattice_inf.{u_1} ι
                                  (@lattice.lattice_of_decidable_linear_order.{u_1} ι
                                     (@classical.DLO.{u_1} ι _inst_1))))))
                      (λ (a : ι),
                         @preorder.to_has_lt.{u_2} (β a)
                           (@partial_order.to_preorder.{u_2} (β a)
                              ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
                   x
                   y))
             (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
             this)
          (@funext.{u_1+1 u_2+1} ι (λ (x : ι), β x) x y)))
⊢ ∀ (j : ι),
    @has_lt.lt.{u_1} ι
      (@preorder.to_has_lt.{u_1} ι
         (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
      j
      i →
    @eq.{u_2+1} (β j) (y j) (x j)

ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
wf :
  @well_founded.{u_1+1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))),
_inst_2 : Π (a : ι), linear_order.{u_2} (β a),
x y : pilex.{u_1 u_2} ι β,
_inst : Π (a : Prop), decidable a,
hxy :
  not
    (@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
       x
       y),
this :
  and
    (not
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1))))))
             (λ (a : ι),
                @preorder.to_has_lt.{u_2} (β a)
                  (@partial_order.to_preorder.{u_2} (β a)
                     ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
          x
          y))
    (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)),
i : ι :=
  @well_founded.min.{u_1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1))))
    wf
    (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1) → false)
    (@iff.mp (not (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@Exists.{u_1+1} ι (λ (x_1 : ι), not (@eq.{u_2+1} (β x_1) (x x_1) (y x_1))))
       (@classical.not_forall.{u_1+1} ι (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@function.comp.{0 0 0} (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1))
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)
          false
          (@and.right
             (not
                (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.has_lt.{u_1 u_2} ι β
                      (@preorder.to_has_lt.{u_1} ι
                         (@partial_order.to_preorder.{u_1} ι
                            (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                               (@lattice.lattice.to_semilattice_inf.{u_1} ι
                                  (@lattice.lattice_of_decidable_linear_order.{u_1} ι
                                     (@classical.DLO.{u_1} ι _inst_1))))))
                      (λ (a : ι),
                         @preorder.to_has_lt.{u_2} (β a)
                           (@partial_order.to_preorder.{u_2} (β a)
                              ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
                   x
                   y))
             (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
             this)
          (@funext.{u_1+1 u_2+1} ι (λ (x : ι), β x) x y))),
hjiyx :
  ∀ (j : ι),
    @has_lt.lt.{u_1} ι
      (@preorder.to_has_lt.{u_1} ι
         (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
      j
      i →
    @eq.{u_2+1} (β j) (y j) (x j)
⊢ @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
    y
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77        { assume j,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
wf :
  @well_founded.{u_1+1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))),
_inst_2 : Π (a : ι), linear_order.{u_2} (β a),
x y : pilex.{u_1 u_2} ι β,
_inst : Π (a : Prop), decidable a,
hxy :
  not
    (@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
       x
       y),
this :
  and
    (not
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1))))))
             (λ (a : ι),
                @preorder.to_has_lt.{u_2} (β a)
                  (@partial_order.to_preorder.{u_2} (β a)
                     ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
          x
          y))
    (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)),
i : ι :=
  @well_founded.min.{u_1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1))))
    wf
    (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1) → false)
    (@iff.mp (not (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@Exists.{u_1+1} ι (λ (x_1 : ι), not (@eq.{u_2+1} (β x_1) (x x_1) (y x_1))))
       (@classical.not_forall.{u_1+1} ι (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@function.comp.{0 0 0} (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1))
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)
          false
          (@and.right
             (not
                (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.has_lt.{u_1 u_2} ι β
                      (@preorder.to_has_lt.{u_1} ι
                         (@partial_order.to_preorder.{u_1} ι
                            (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                               (@lattice.lattice.to_semilattice_inf.{u_1} ι
                                  (@lattice.lattice_of_decidable_linear_order.{u_1} ι
                                     (@classical.DLO.{u_1} ι _inst_1))))))
                      (λ (a : ι),
                         @preorder.to_has_lt.{u_2} (β a)
                           (@partial_order.to_preorder.{u_2} (β a)
                              ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
                   x
                   y))
             (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
             this)
          (@funext.{u_1+1 u_2+1} ι (λ (x : ι), β x) x y)))
⊢ ∀ (j : ι),
    @has_lt.lt.{u_1} ι
      (@preorder.to_has_lt.{u_1} ι
         (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
      j
      i →
    @eq.{u_2+1} (β j) (y j) (x j)

ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
wf :
  @well_founded.{u_1+1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))),
_inst_2 : Π (a : ι), linear_order.{u_2} (β a),
x y : pilex.{u_1 u_2} ι β,
_inst : Π (a : Prop), decidable a,
hxy :
  not
    (@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
       x
       y),
this :
  and
    (not
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1))))))
             (λ (a : ι),
                @preorder.to_has_lt.{u_2} (β a)
                  (@partial_order.to_preorder.{u_2} (β a)
                     ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
          x
          y))
    (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)),
i : ι :=
  @well_founded.min.{u_1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1))))
    wf
    (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1) → false)
    (@iff.mp (not (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@Exists.{u_1+1} ι (λ (x_1 : ι), not (@eq.{u_2+1} (β x_1) (x x_1) (y x_1))))
       (@classical.not_forall.{u_1+1} ι (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@function.comp.{0 0 0} (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1))
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)
          false
          (@and.right
             (not
                (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.has_lt.{u_1 u_2} ι β
                      (@preorder.to_has_lt.{u_1} ι
                         (@partial_order.to_preorder.{u_1} ι
                            (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                               (@lattice.lattice.to_semilattice_inf.{u_1} ι
                                  (@lattice.lattice_of_decidable_linear_order.{u_1} ι
                                     (@classical.DLO.{u_1} ι _inst_1))))))
                      (λ (a : ι),
                         @preorder.to_has_lt.{u_2} (β a)
                           (@partial_order.to_preorder.{u_2} (β a)
                              ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
                   x
                   y))
             (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
             this)
          (@funext.{u_1+1 u_2+1} ι (λ (x : ι), β x) x y))),
hjiyx :
  ∀ (j : ι),
    @has_lt.lt.{u_1} ι
      (@preorder.to_has_lt.{u_1} ι
         (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
      j
      i →
    @eq.{u_2+1} (β j) (y j) (x j)
⊢ @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
    y
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
wf :
  @well_founded.{u_1+1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))),
_inst_2 : Π (a : ι), linear_order.{u_2} (β a),
x y : pilex.{u_1 u_2} ι β,
_inst : Π (a : Prop), decidable a,
hxy :
  not
    (@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
       x
       y),
this :
  and
    (not
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1))))))
             (λ (a : ι),
                @preorder.to_has_lt.{u_2} (β a)
                  (@partial_order.to_preorder.{u_2} (β a)
                     ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
          x
          y))
    (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)),
i : ι :=
  @well_founded.min.{u_1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1))))
    wf
    (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1) → false)
    (@iff.mp (not (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@Exists.{u_1+1} ι (λ (x_1 : ι), not (@eq.{u_2+1} (β x_1) (x x_1) (y x_1))))
       (@classical.not_forall.{u_1+1} ι (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@function.comp.{0 0 0} (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1))
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)
          false
          (@and.right
             (not
                (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.has_lt.{u_1 u_2} ι β
                      (@preorder.to_has_lt.{u_1} ι
                         (@partial_order.to_preorder.{u_1} ι
                            (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                               (@lattice.lattice.to_semilattice_inf.{u_1} ι
                                  (@lattice.lattice_of_decidable_linear_order.{u_1} ι
                                     (@classical.DLO.{u_1} ι _inst_1))))))
                      (λ (a : ι),
                         @preorder.to_has_lt.{u_2} (β a)
                           (@partial_order.to_preorder.{u_2} (β a)
                              ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
                   x
                   y))
             (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
             this)
          (@funext.{u_1+1 u_2+1} ι (λ (x : ι), β x) x y)))
⊢ ∀ (j : ι),
    @has_lt.lt.{u_1} ι
      (@preorder.to_has_lt.{u_1} ι
         (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
      j
      i →
    @eq.{u_2+1} (β j) (y j) (x j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
wf :
  @well_founded.{u_1+1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))),
_inst_2 : Π (a : ι), linear_order.{u_2} (β a),
x y : pilex.{u_1 u_2} ι β,
_inst : Π (a : Prop), decidable a,
hxy :
  not
    (@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
       x
       y),
this :
  and
    (not
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1))))))
             (λ (a : ι),
                @preorder.to_has_lt.{u_2} (β a)
                  (@partial_order.to_preorder.{u_2} (β a)
                     ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
          x
          y))
    (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)),
i : ι :=
  @well_founded.min.{u_1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1))))
    wf
    (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1) → false)
    (@iff.mp (not (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@Exists.{u_1+1} ι (λ (x_1 : ι), not (@eq.{u_2+1} (β x_1) (x x_1) (y x_1))))
       (@classical.not_forall.{u_1+1} ι (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@function.comp.{0 0 0} (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1))
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)
          false
          (@and.right
             (not
                (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.has_lt.{u_1 u_2} ι β
                      (@preorder.to_has_lt.{u_1} ι
                         (@partial_order.to_preorder.{u_1} ι
                            (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                               (@lattice.lattice.to_semilattice_inf.{u_1} ι
                                  (@lattice.lattice_of_decidable_linear_order.{u_1} ι
                                     (@classical.DLO.{u_1} ι _inst_1))))))
                      (λ (a : ι),
                         @preorder.to_has_lt.{u_2} (β a)
                           (@partial_order.to_preorder.{u_2} (β a)
                              ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
                   x
                   y))
             (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
             this)
          (@funext.{u_1+1 u_2+1} ι (λ (x : ι), β x) x y))),
j : ι
⊢ @has_lt.lt.{u_1} ι
    (@preorder.to_has_lt.{u_1} ι
       (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
    j
    i →
  @eq.{u_2+1} (β j) (y j) (x j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78          rw [eq_comm, ← not_imp_not],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='eq_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='not_imp_not'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 363, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 250, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {a b : α}, iff (@eq.{u_2+1} α a b) (@eq.{u_2+1} α b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop} [_inst_1 : decidable a], iff (not a → not b) (b → a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
wf :
  @well_founded.{u_1+1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))),
_inst_2 : Π (a : ι), linear_order.{u_2} (β a),
x y : pilex.{u_1 u_2} ι β,
_inst : Π (a : Prop), decidable a,
hxy :
  not
    (@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
       x
       y),
this :
  and
    (not
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1))))))
             (λ (a : ι),
                @preorder.to_has_lt.{u_2} (β a)
                  (@partial_order.to_preorder.{u_2} (β a)
                     ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
          x
          y))
    (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)),
i : ι :=
  @well_founded.min.{u_1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1))))
    wf
    (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1) → false)
    (@iff.mp (not (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@Exists.{u_1+1} ι (λ (x_1 : ι), not (@eq.{u_2+1} (β x_1) (x x_1) (y x_1))))
       (@classical.not_forall.{u_1+1} ι (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@function.comp.{0 0 0} (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1))
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)
          false
          (@and.right
             (not
                (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.has_lt.{u_1 u_2} ι β
                      (@preorder.to_has_lt.{u_1} ι
                         (@partial_order.to_preorder.{u_1} ι
                            (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                               (@lattice.lattice.to_semilattice_inf.{u_1} ι
                                  (@lattice.lattice_of_decidable_linear_order.{u_1} ι
                                     (@classical.DLO.{u_1} ι _inst_1))))))
                      (λ (a : ι),
                         @preorder.to_has_lt.{u_2} (β a)
                           (@partial_order.to_preorder.{u_2} (β a)
                              ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
                   x
                   y))
             (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
             this)
          (@funext.{u_1+1 u_2+1} ι (λ (x : ι), β x) x y))),
j : ι
⊢ @has_lt.lt.{u_1} ι
    (@preorder.to_has_lt.{u_1} ι
       (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
    j
    i →
  @eq.{u_2+1} (β j) (y j) (x j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
wf :
  @well_founded.{u_1+1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))),
_inst_2 : Π (a : ι), linear_order.{u_2} (β a),
x y : pilex.{u_1 u_2} ι β,
_inst : Π (a : Prop), decidable a,
hxy :
  not
    (@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
       x
       y),
this :
  and
    (not
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1))))))
             (λ (a : ι),
                @preorder.to_has_lt.{u_2} (β a)
                  (@partial_order.to_preorder.{u_2} (β a)
                     ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
          x
          y))
    (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)),
i : ι :=
  @well_founded.min.{u_1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1))))
    wf
    (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1) → false)
    (@iff.mp (not (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@Exists.{u_1+1} ι (λ (x_1 : ι), not (@eq.{u_2+1} (β x_1) (x x_1) (y x_1))))
       (@classical.not_forall.{u_1+1} ι (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@function.comp.{0 0 0} (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1))
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)
          false
          (@and.right
             (not
                (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.has_lt.{u_1 u_2} ι β
                      (@preorder.to_has_lt.{u_1} ι
                         (@partial_order.to_preorder.{u_1} ι
                            (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                               (@lattice.lattice.to_semilattice_inf.{u_1} ι
                                  (@lattice.lattice_of_decidable_linear_order.{u_1} ι
                                     (@classical.DLO.{u_1} ι _inst_1))))))
                      (λ (a : ι),
                         @preorder.to_has_lt.{u_2} (β a)
                           (@partial_order.to_preorder.{u_2} (β a)
                              ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
                   x
                   y))
             (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
             this)
          (@funext.{u_1+1 u_2+1} ι (λ (x : ι), β x) x y))),
j : ι
⊢ @has_lt.lt.{u_1} ι
    (@preorder.to_has_lt.{u_1} ι
       (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
    j
    i →
  @eq.{u_2+1} (β j) (x j) (y j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
wf :
  @well_founded.{u_1+1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))),
_inst_2 : Π (a : ι), linear_order.{u_2} (β a),
x y : pilex.{u_1 u_2} ι β,
_inst : Π (a : Prop), decidable a,
hxy :
  not
    (@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
       x
       y),
this :
  and
    (not
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1))))))
             (λ (a : ι),
                @preorder.to_has_lt.{u_2} (β a)
                  (@partial_order.to_preorder.{u_2} (β a)
                     ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
          x
          y))
    (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)),
i : ι :=
  @well_founded.min.{u_1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1))))
    wf
    (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1) → false)
    (@iff.mp (not (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@Exists.{u_1+1} ι (λ (x_1 : ι), not (@eq.{u_2+1} (β x_1) (x x_1) (y x_1))))
       (@classical.not_forall.{u_1+1} ι (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@function.comp.{0 0 0} (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1))
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)
          false
          (@and.right
             (not
                (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.has_lt.{u_1 u_2} ι β
                      (@preorder.to_has_lt.{u_1} ι
                         (@partial_order.to_preorder.{u_1} ι
                            (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                               (@lattice.lattice.to_semilattice_inf.{u_1} ι
                                  (@lattice.lattice_of_decidable_linear_order.{u_1} ι
                                     (@classical.DLO.{u_1} ι _inst_1))))))
                      (λ (a : ι),
                         @preorder.to_has_lt.{u_2} (β a)
                           (@partial_order.to_preorder.{u_2} (β a)
                              ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
                   x
                   y))
             (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
             this)
          (@funext.{u_1+1 u_2+1} ι (λ (x : ι), β x) x y))),
j : ι
⊢ not (@eq.{u_2+1} (β j) (x j) (y j)) →
  not
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
       j
       i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79          exact λ h, well_founded.not_lt_min wf _ _ h },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='well_founded.not_lt_min'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='wf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 527, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {r : α → α → Prop} (H : @well_founded.{u_1+1} α r) (p : set.{u_1} α) (h : @set.nonempty.{u_1} α p) {x : α}, @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x p → not (r x (@well_founded.min.{u_1} α r H p h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@well_founded.{u_1+1} ι (@has_lt.lt.{u_1} ι (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
wf :
  @well_founded.{u_1+1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))),
_inst_2 : Π (a : ι), linear_order.{u_2} (β a),
x y : pilex.{u_1 u_2} ι β,
_inst : Π (a : Prop), decidable a,
hxy :
  not
    (@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
       x
       y),
this :
  and
    (not
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1))))))
             (λ (a : ι),
                @preorder.to_has_lt.{u_2} (β a)
                  (@partial_order.to_preorder.{u_2} (β a)
                     ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
          x
          y))
    (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)),
i : ι :=
  @well_founded.min.{u_1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1))))
    wf
    (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1) → false)
    (@iff.mp (not (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@Exists.{u_1+1} ι (λ (x_1 : ι), not (@eq.{u_2+1} (β x_1) (x x_1) (y x_1))))
       (@classical.not_forall.{u_1+1} ι (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@function.comp.{0 0 0} (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1))
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)
          false
          (@and.right
             (not
                (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.has_lt.{u_1 u_2} ι β
                      (@preorder.to_has_lt.{u_1} ι
                         (@partial_order.to_preorder.{u_1} ι
                            (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                               (@lattice.lattice.to_semilattice_inf.{u_1} ι
                                  (@lattice.lattice_of_decidable_linear_order.{u_1} ι
                                     (@classical.DLO.{u_1} ι _inst_1))))))
                      (λ (a : ι),
                         @preorder.to_has_lt.{u_2} (β a)
                           (@partial_order.to_preorder.{u_2} (β a)
                              ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
                   x
                   y))
             (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
             this)
          (@funext.{u_1+1 u_2+1} ι (λ (x : ι), β x) x y))),
j : ι
⊢ not (@eq.{u_2+1} (β j) (x j) (y j)) →
  not
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
       j
       i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
wf :
  @well_founded.{u_1+1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))),
_inst_2 : Π (a : ι), linear_order.{u_2} (β a),
x y : pilex.{u_1 u_2} ι β,
_inst : Π (a : Prop), decidable a,
hxy :
  not
    (@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
       x
       y),
this :
  and
    (not
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1))))))
             (λ (a : ι),
                @preorder.to_has_lt.{u_2} (β a)
                  (@partial_order.to_preorder.{u_2} (β a)
                     ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
          x
          y))
    (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)),
i : ι :=
  @well_founded.min.{u_1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1))))
    wf
    (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1) → false)
    (@iff.mp (not (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@Exists.{u_1+1} ι (λ (x_1 : ι), not (@eq.{u_2+1} (β x_1) (x x_1) (y x_1))))
       (@classical.not_forall.{u_1+1} ι (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@function.comp.{0 0 0} (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1))
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)
          false
          (@and.right
             (not
                (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.has_lt.{u_1 u_2} ι β
                      (@preorder.to_has_lt.{u_1} ι
                         (@partial_order.to_preorder.{u_1} ι
                            (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                               (@lattice.lattice.to_semilattice_inf.{u_1} ι
                                  (@lattice.lattice_of_decidable_linear_order.{u_1} ι
                                     (@classical.DLO.{u_1} ι _inst_1))))))
                      (λ (a : ι),
                         @preorder.to_has_lt.{u_2} (β a)
                           (@partial_order.to_preorder.{u_2} (β a)
                              ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
                   x
                   y))
             (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
             this)
          (@funext.{u_1+1 u_2+1} ι (λ (x : ι), β x) x y))),
hjiyx :
  ∀ (j : ι),
    @has_lt.lt.{u_1} ι
      (@preorder.to_has_lt.{u_1} ι
         (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
      j
      i →
    @eq.{u_2+1} (β j) (y j) (x j)
⊢ @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
    y
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80        refine or.inl ⟨i, hjiyx, _⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='or.inl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hjiyx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, a → or a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (j : ι), @has_lt.lt.{u_1} ι (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1))) j i → @eq.{u_2+1} (β j) (y j) (x j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
wf :
  @well_founded.{u_1+1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))),
_inst_2 : Π (a : ι), linear_order.{u_2} (β a),
x y : pilex.{u_1 u_2} ι β,
_inst : Π (a : Prop), decidable a,
hxy :
  not
    (@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
       x
       y),
this :
  and
    (not
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1))))))
             (λ (a : ι),
                @preorder.to_has_lt.{u_2} (β a)
                  (@partial_order.to_preorder.{u_2} (β a)
                     ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
          x
          y))
    (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)),
i : ι :=
  @well_founded.min.{u_1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1))))
    wf
    (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1) → false)
    (@iff.mp (not (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@Exists.{u_1+1} ι (λ (x_1 : ι), not (@eq.{u_2+1} (β x_1) (x x_1) (y x_1))))
       (@classical.not_forall.{u_1+1} ι (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@function.comp.{0 0 0} (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1))
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)
          false
          (@and.right
             (not
                (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.has_lt.{u_1 u_2} ι β
                      (@preorder.to_has_lt.{u_1} ι
                         (@partial_order.to_preorder.{u_1} ι
                            (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                               (@lattice.lattice.to_semilattice_inf.{u_1} ι
                                  (@lattice.lattice_of_decidable_linear_order.{u_1} ι
                                     (@classical.DLO.{u_1} ι _inst_1))))))
                      (λ (a : ι),
                         @preorder.to_has_lt.{u_2} (β a)
                           (@partial_order.to_preorder.{u_2} (β a)
                              ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
                   x
                   y))
             (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
             this)
          (@funext.{u_1+1 u_2+1} ι (λ (x : ι), β x) x y))),
hjiyx :
  ∀ (j : ι),
    @has_lt.lt.{u_1} ι
      (@preorder.to_has_lt.{u_1} ι
         (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
      j
      i →
    @eq.{u_2+1} (β j) (y j) (x j)
⊢ @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
             (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
    y
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
wf :
  @well_founded.{u_1+1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))),
_inst_2 : Π (a : ι), linear_order.{u_2} (β a),
x y : pilex.{u_1 u_2} ι β,
_inst : Π (a : Prop), decidable a,
hxy :
  not
    (@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
       x
       y),
this :
  and
    (not
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1))))))
             (λ (a : ι),
                @preorder.to_has_lt.{u_2} (β a)
                  (@partial_order.to_preorder.{u_2} (β a)
                     ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
          x
          y))
    (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)),
i : ι :=
  @well_founded.min.{u_1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1))))
    wf
    (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1) → false)
    (@iff.mp (not (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@Exists.{u_1+1} ι (λ (x_1 : ι), not (@eq.{u_2+1} (β x_1) (x x_1) (y x_1))))
       (@classical.not_forall.{u_1+1} ι (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@function.comp.{0 0 0} (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1))
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)
          false
          (@and.right
             (not
                (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.has_lt.{u_1 u_2} ι β
                      (@preorder.to_has_lt.{u_1} ι
                         (@partial_order.to_preorder.{u_1} ι
                            (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                               (@lattice.lattice.to_semilattice_inf.{u_1} ι
                                  (@lattice.lattice_of_decidable_linear_order.{u_1} ι
                                     (@classical.DLO.{u_1} ι _inst_1))))))
                      (λ (a : ι),
                         @preorder.to_has_lt.{u_2} (β a)
                           (@partial_order.to_preorder.{u_2} (β a)
                              ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
                   x
                   y))
             (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
             this)
          (@funext.{u_1+1 u_2+1} ι (λ (x : ι), β x) x y))),
hjiyx :
  ∀ (j : ι),
    @has_lt.lt.{u_1} ι
      (@preorder.to_has_lt.{u_1} ι
         (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
      j
      i →
    @eq.{u_2+1} (β j) (y j) (x j)
⊢ (λ (_x : ι),
     @has_lt.lt.{u_2} (β _x)
       ((λ (a : ι),
           @preorder.to_has_lt.{u_2} (β a)
             (@partial_order.to_preorder.{u_2} (β a)
                ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a)))
          _x))
    i
    (y i)
    (x i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81        { refine lt_of_not_ge (λ hyx, _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='lt_of_not_ge'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : linear_order.{u_2} α] {a b : α}, not (@ge.{u_2} α (@preorder.to_has_le.{u_2} α (@partial_order.to_preorder.{u_2} α (@linear_order.to_partial_order.{u_2} α _inst_1))) a b) → @has_lt.lt.{u_2} α (@preorder.to_has_lt.{u_2} α (@partial_order.to_preorder.{u_2} α (@linear_order.to_partial_order.{u_2} α _inst_1))) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
wf :
  @well_founded.{u_1+1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))),
_inst_2 : Π (a : ι), linear_order.{u_2} (β a),
x y : pilex.{u_1 u_2} ι β,
_inst : Π (a : Prop), decidable a,
hxy :
  not
    (@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
       x
       y),
this :
  and
    (not
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1))))))
             (λ (a : ι),
                @preorder.to_has_lt.{u_2} (β a)
                  (@partial_order.to_preorder.{u_2} (β a)
                     ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
          x
          y))
    (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)),
i : ι :=
  @well_founded.min.{u_1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1))))
    wf
    (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1) → false)
    (@iff.mp (not (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@Exists.{u_1+1} ι (λ (x_1 : ι), not (@eq.{u_2+1} (β x_1) (x x_1) (y x_1))))
       (@classical.not_forall.{u_1+1} ι (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@function.comp.{0 0 0} (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1))
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)
          false
          (@and.right
             (not
                (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.has_lt.{u_1 u_2} ι β
                      (@preorder.to_has_lt.{u_1} ι
                         (@partial_order.to_preorder.{u_1} ι
                            (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                               (@lattice.lattice.to_semilattice_inf.{u_1} ι
                                  (@lattice.lattice_of_decidable_linear_order.{u_1} ι
                                     (@classical.DLO.{u_1} ι _inst_1))))))
                      (λ (a : ι),
                         @preorder.to_has_lt.{u_2} (β a)
                           (@partial_order.to_preorder.{u_2} (β a)
                              ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
                   x
                   y))
             (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
             this)
          (@funext.{u_1+1 u_2+1} ι (λ (x : ι), β x) x y))),
hjiyx :
  ∀ (j : ι),
    @has_lt.lt.{u_1} ι
      (@preorder.to_has_lt.{u_1} ι
         (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
      j
      i →
    @eq.{u_2+1} (β j) (y j) (x j)
⊢ (λ (_x : ι),
     @has_lt.lt.{u_2} (β _x)
       ((λ (a : ι),
           @preorder.to_has_lt.{u_2} (β a)
             (@partial_order.to_preorder.{u_2} (β a)
                ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a)))
          _x))
    i
    (y i)
    (x i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
wf :
  @well_founded.{u_1+1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))),
_inst_2 : Π (a : ι), linear_order.{u_2} (β a),
x y : pilex.{u_1 u_2} ι β,
_inst : Π (a : Prop), decidable a,
hxy :
  not
    (@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
       x
       y),
this :
  and
    (not
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1))))))
             (λ (a : ι),
                @preorder.to_has_lt.{u_2} (β a)
                  (@partial_order.to_preorder.{u_2} (β a)
                     ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
          x
          y))
    (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)),
i : ι :=
  @well_founded.min.{u_1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1))))
    wf
    (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1) → false)
    (@iff.mp (not (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@Exists.{u_1+1} ι (λ (x_1 : ι), not (@eq.{u_2+1} (β x_1) (x x_1) (y x_1))))
       (@classical.not_forall.{u_1+1} ι (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@function.comp.{0 0 0} (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1))
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)
          false
          (@and.right
             (not
                (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.has_lt.{u_1 u_2} ι β
                      (@preorder.to_has_lt.{u_1} ι
                         (@partial_order.to_preorder.{u_1} ι
                            (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                               (@lattice.lattice.to_semilattice_inf.{u_1} ι
                                  (@lattice.lattice_of_decidable_linear_order.{u_1} ι
                                     (@classical.DLO.{u_1} ι _inst_1))))))
                      (λ (a : ι),
                         @preorder.to_has_lt.{u_2} (β a)
                           (@partial_order.to_preorder.{u_2} (β a)
                              ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
                   x
                   y))
             (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
             this)
          (@funext.{u_1+1 u_2+1} ι (λ (x : ι), β x) x y))),
hjiyx :
  ∀ (j : ι),
    @has_lt.lt.{u_1} ι
      (@preorder.to_has_lt.{u_1} ι
         (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
      j
      i →
    @eq.{u_2+1} (β j) (y j) (x j),
hyx :
  @ge.{u_2} (β i)
    (@preorder.to_has_le.{u_2} (β i)
       (@partial_order.to_preorder.{u_2} (β i) (@linear_order.to_partial_order.{u_2} (β i) (_inst_2 i))))
    (y i)
    (x i)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82          exact this.1 ⟨i, (λ j hj, (hjiyx j hj).symm),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='hjiyx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (not (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1)))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a)))) x y)) (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (j : ι), @has_lt.lt.{u_1} ι (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1))) j i → @eq.{u_2+1} (β j) (y j) (x j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
wf :
  @well_founded.{u_1+1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))),
_inst_2 : Π (a : ι), linear_order.{u_2} (β a),
x y : pilex.{u_1 u_2} ι β,
_inst : Π (a : Prop), decidable a,
hxy :
  not
    (@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
       x
       y),
this :
  and
    (not
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1))))))
             (λ (a : ι),
                @preorder.to_has_lt.{u_2} (β a)
                  (@partial_order.to_preorder.{u_2} (β a)
                     ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
          x
          y))
    (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)),
i : ι :=
  @well_founded.min.{u_1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1))))
    wf
    (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1) → false)
    (@iff.mp (not (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@Exists.{u_1+1} ι (λ (x_1 : ι), not (@eq.{u_2+1} (β x_1) (x x_1) (y x_1))))
       (@classical.not_forall.{u_1+1} ι (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@function.comp.{0 0 0} (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1))
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)
          false
          (@and.right
             (not
                (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.has_lt.{u_1 u_2} ι β
                      (@preorder.to_has_lt.{u_1} ι
                         (@partial_order.to_preorder.{u_1} ι
                            (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                               (@lattice.lattice.to_semilattice_inf.{u_1} ι
                                  (@lattice.lattice_of_decidable_linear_order.{u_1} ι
                                     (@classical.DLO.{u_1} ι _inst_1))))))
                      (λ (a : ι),
                         @preorder.to_has_lt.{u_2} (β a)
                           (@partial_order.to_preorder.{u_2} (β a)
                              ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
                   x
                   y))
             (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
             this)
          (@funext.{u_1+1 u_2+1} ι (λ (x : ι), β x) x y))),
hjiyx :
  ∀ (j : ι),
    @has_lt.lt.{u_1} ι
      (@preorder.to_has_lt.{u_1} ι
         (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
      j
      i →
    @eq.{u_2+1} (β j) (y j) (x j),
hyx :
  @ge.{u_2} (β i)
    (@preorder.to_has_le.{u_2} (β i)
       (@partial_order.to_preorder.{u_2} (β i) (@linear_order.to_partial_order.{u_2} (β i) (_inst_2 i))))
    (y i)
    (x i)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83            lt_of_le_of_ne hyx (well_founded.min_mem _ {i | x i ≠ y i} _)⟩ }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='lt_of_le_of_ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hyx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='well_founded.min_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 136, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 523, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : partial_order.{u_2} α] {a b : α}, @has_le.le.{u_2} α (@preorder.to_has_le.{u_2} α (@partial_order.to_preorder.{u_2} α _inst_1)) a b → @ne.{u_2+1} α a b → @has_lt.lt.{u_2} α (@preorder.to_has_lt.{u_2} α (@partial_order.to_preorder.{u_2} α _inst_1)) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ge.{u_2} (β i) (@preorder.to_has_le.{u_2} (β i) (@partial_order.to_preorder.{u_2} (β i) (@linear_order.to_partial_order.{u_2} (β i) (_inst_2 i)))) (y i) (x i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {r : α → α → Prop} (H : @well_founded.{u_1+1} α r) (p : set.{u_1} α) (h : @set.nonempty.{u_1} α p), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) (@well_founded.min.{u_1} α r H p h) p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
wf :
  @well_founded.{u_1+1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))),
_inst_2 : Π (a : ι), linear_order.{u_2} (β a),
x y : pilex.{u_1 u_2} ι β,
_inst : Π (a : Prop), decidable a,
hxy :
  not
    (@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
       x
       y),
this :
  and
    (not
       (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@pilex.has_lt.{u_1 u_2} ι β
             (@preorder.to_has_lt.{u_1} ι
                (@partial_order.to_preorder.{u_1} ι
                   (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                      (@lattice.lattice.to_semilattice_inf.{u_1} ι
                         (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1))))))
             (λ (a : ι),
                @preorder.to_has_lt.{u_2} (β a)
                  (@partial_order.to_preorder.{u_2} (β a)
                     ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
          x
          y))
    (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)),
i : ι :=
  @well_founded.min.{u_1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1))))
    wf
    (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1) → false)
    (@iff.mp (not (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@Exists.{u_1+1} ι (λ (x_1 : ι), not (@eq.{u_2+1} (β x_1) (x x_1) (y x_1))))
       (@classical.not_forall.{u_1+1} ι (λ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1)))
       (@function.comp.{0 0 0} (∀ (x_1 : ι), @eq.{u_2+1} (β x_1) (x x_1) (y x_1))
          (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y)
          false
          (@and.right
             (not
                (@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.has_lt.{u_1 u_2} ι β
                      (@preorder.to_has_lt.{u_1} ι
                         (@partial_order.to_preorder.{u_1} ι
                            (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                               (@lattice.lattice.to_semilattice_inf.{u_1} ι
                                  (@lattice.lattice_of_decidable_linear_order.{u_1} ι
                                     (@classical.DLO.{u_1} ι _inst_1))))))
                      (λ (a : ι),
                         @preorder.to_has_lt.{u_2} (β a)
                           (@partial_order.to_preorder.{u_2} (β a)
                              ((λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)) a))))
                   x
                   y))
             (not (@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y))
             this)
          (@funext.{u_1+1 u_2+1} ι (λ (x : ι), β x) x y))),
hjiyx :
  ∀ (j : ι),
    @has_lt.lt.{u_1} ι
      (@preorder.to_has_lt.{u_1} ι
         (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))
      j
      i →
    @eq.{u_2+1} (β j) (y j) (x j),
hyx :
  @ge.{u_2} (β i)
    (@preorder.to_has_le.{u_2} (β i)
       (@partial_order.to_preorder.{u_2} (β i) (@linear_order.to_partial_order.{u_2} (β i) (_inst_2 i))))
    (y i)
    (x i)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84      end),</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
wf :
  @well_founded.{u_1+1} ι
    (@has_lt.lt.{u_1} ι
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι (@linear_order.to_partial_order.{u_1} ι _inst_1)))),
_inst_2 : Π (a : ι), linear_order.{u_2} (β a),
x y : pilex.{u_1 u_2} ι β
⊢ or
    (@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
       x
       y)
    (@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                      (λ (a : ι), @linear_order.to_partial_order.{u_2} (β a) (_inst_2 a)))))))
       y
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85    ..pilex.partial_order }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='pilex.partial_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 25, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {ι : Type u_1} {β : ι → Type u_2} [_inst_1 : linear_order.{u_1} ι] [_inst_2 : Π (a : ι), partial_order.{u_2} (β a)], partial_order.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87  instance [linear_order ι] [∀ a, ordered_comm_group (β a)] : ordered_comm_group (pilex ι β) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='linear_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ordered_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='ordered_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pilex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ordered_group.lean&#x27;, &#x27;line&#x27;: 186, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ordered_group.lean&#x27;, &#x27;line&#x27;: 186, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 15, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1), (α → Type u_2) → Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88  { add_le_add_left := λ x y hxy z,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hxy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.partial_order.{u_1 u_2} ι β _inst_1 (λ (a : ι), @ordered_comm_monoid.to_partial_order.{u_2} (β a) (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a) (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a)))))) (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.partial_order.{u_1 u_2} ι β _inst_1 (λ (a : ι), @ordered_comm_monoid.to_partial_order.{u_2} (β a) (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a) (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a)))))) (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.partial_order.{u_1 u_2} ι β _inst_1 (λ (a : ι), @ordered_comm_monoid.to_partial_order.{u_2} (β a) (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a) (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a)))))) (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.partial_order.{u_1 u_2} ι β _inst_1 (λ (a : ι), @ordered_comm_monoid.to_partial_order.{u_2} (β a) (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a) (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a)))))) (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.partial_order.{u_1 u_2} ι β _inst_1 (λ (a : ι), @ordered_comm_monoid.to_partial_order.{u_2} (β a) (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a) (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a)))))) (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.partial_order.{u_1 u_2} ι β _inst_1 (λ (a : ι), @ordered_comm_monoid.to_partial_order.{u_2} (β a) (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a) (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a))))))))) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89      hxy.elim</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hxy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='or.elim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 202, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.partial_order.{u_1 u_2} ι β _inst_1 (λ (a : ι), @ordered_comm_monoid.to_partial_order.{u_2} (β a) (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a) (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a)))))) (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.partial_order.{u_1 u_2} ι β _inst_1 (λ (a : ι), @ordered_comm_monoid.to_partial_order.{u_2} (β a) (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a) (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a)))))) (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.partial_order.{u_1 u_2} ι β _inst_1 (λ (a : ι), @ordered_comm_monoid.to_partial_order.{u_2} (β a) (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a) (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a)))))) (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.partial_order.{u_1 u_2} ι β _inst_1 (λ (a : ι), @ordered_comm_monoid.to_partial_order.{u_2} (β a) (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a) (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a)))))) (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.partial_order.{u_1 u_2} ι β _inst_1 (λ (a : ι), @ordered_comm_monoid.to_partial_order.{u_2} (β a) (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a) (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a)))))) (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.partial_order.{u_1 u_2} ι β _inst_1 (λ (a : ι), @ordered_comm_monoid.to_partial_order.{u_2} (β a) (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a) (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a))))))))) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b c : Prop}, or a b → (a → c) → (b → c) → c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90        (λ ⟨i, hi⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.has_lt.{u_1 u_2} ι β (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1)))))) (λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) ((λ (a : ι), @ordered_comm_monoid.to_partial_order.{u_2} (β a) (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a) (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a)))) a)))) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='and (∀ (j : ι), @has_lt.lt.{u_1} ι (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1)))))) j i → @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j)) ((λ (_x : ι), @has_lt.lt.{u_2} (β _x) ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) ((λ (a : ι), @ordered_comm_monoid.to_partial_order.{u_2} (β a) (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a) (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a)))) a))) _x)) i (x i) (y i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91          or.inl ⟨i, λ j hji, show z j + x j = z j + y j, by rw [hi.1 j hji],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='or.inl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hji'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hji'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='∀ {a b : Prop}, a → or a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_lt.lt.{u_1} ι (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1)))))) j i'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_add.{u_2} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_add.{u_2} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (∀ (j : ι), @has_lt.lt.{u_1} ι (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1)))))) j i → @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j)) ((λ (_x : ι), @has_lt.lt.{u_2} (β _x) ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) ((λ (a : ι), @ordered_comm_monoid.to_partial_order.{u_2} (β a) (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a) (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a)))) a))) _x)) i (x i) (y i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{u_1} ι (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1)))))) j i'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                          </code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), ordered_comm_group.{u_2} (β a),
x y : pilex.{u_1 u_2} ι β,
hxy :
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι),
                      @ordered_comm_monoid.to_partial_order.{u_2} (β a)
                        (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a)
                           (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a))))))
             (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι),
                      @ordered_comm_monoid.to_partial_order.{u_2} (β a)
                        (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a)
                           (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a))))))
             (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι),
                      @ordered_comm_monoid.to_partial_order.{u_2} (β a)
                        (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a)
                           (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a))))))
             (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι),
                      @ordered_comm_monoid.to_partial_order.{u_2} (β a)
                        (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a)
                           (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a))))))
             (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι),
                      @ordered_comm_monoid.to_partial_order.{u_2} (β a)
                        (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a)
                           (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a))))))
             (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι),
                      @ordered_comm_monoid.to_partial_order.{u_2} (β a)
                        (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a)
                           (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a)))))))))
    x
    y,
z : pilex.{u_1 u_2} ι β,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1))))))
       (λ (a : ι),
          @preorder.to_has_lt.{u_2} (β a)
            (@partial_order.to_preorder.{u_2} (β a)
               ((λ (a : ι),
                   @ordered_comm_monoid.to_partial_order.{u_2} (β a)
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a)
                        (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a))))
                  a))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@pilex.has_lt.{u_1 u_2} ι β
       (@preorder.to_has_lt.{u_1} ι
          (@partial_order.to_preorder.{u_1} ι
             (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                (@lattice.lattice.to_semilattice_inf.{u_1} ι
                   (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1))))))
       (λ (a : ι),
          @preorder.to_has_lt.{u_2} (β a)
            (@partial_order.to_preorder.{u_2} (β a)
               ((λ (a : ι),
                   @ordered_comm_monoid.to_partial_order.{u_2} (β a)
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a)
                        (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a))))
                  a))))
    x
    y →
  @has_le.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@preorder.to_has_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι),
                      @ordered_comm_monoid.to_partial_order.{u_2} (β a)
                        (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a)
                           (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a))))))
             (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι),
                      @ordered_comm_monoid.to_partial_order.{u_2} (β a)
                        (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a)
                           (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a))))))
             (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι),
                      @ordered_comm_monoid.to_partial_order.{u_2} (β a)
                        (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a)
                           (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a))))))
             (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι),
                      @ordered_comm_monoid.to_partial_order.{u_2} (β a)
                        (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a)
                           (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a))))))
             (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι),
                      @ordered_comm_monoid.to_partial_order.{u_2} (β a)
                        (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a)
                           (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a))))))
             (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι),
                      @ordered_comm_monoid.to_partial_order.{u_2} (β a)
                        (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a)
                           (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a)))))))))
    (@has_add.add.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@add_semigroup.to_has_add.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@add_monoid.to_add_semigroup.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@add_group.to_add_monoid.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@add_comm_group.to_add_group.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@add_comm_group.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                      (@add_comm_group.add.{(max u_1 u_2)} (Π (i : ι), β i)
                         (@pi.add_comm_group.{u_1 u_2} ι (λ (i : ι), β i)
                            (λ (i : ι), @ordered_comm_group.to_add_comm_group.{u_2} (β i) (_inst_2 i))))
                      (@add_comm_group.add_assoc.{(max u_1 u_2)} (Π (i : ι), β i)
                         (@pi.add_comm_group.{u_1 u_2} ι (λ (i : ι), β i)
                            (λ (i : ι), @ordered_comm_group.to_add_comm_group.{u_2} (β i) (_inst_2 i))))
                      (@add_comm_group.zero.{(max u_1 u_2)} (Π (i : ι), β i)
                         (@pi.add_comm_group.{u_1 u_2} ι (λ (i : ι), β i)
                            (λ (i : ι), @ordered_comm_group.to_add_comm_group.{u_2} (β i) (_inst_2 i))))
                      (@add_comm_group.zero_add.{(max u_1 u_2)} (Π (i : ι), β i)
                         (@pi.add_comm_group.{u_1 u_2} ι (λ (i : ι), β i)
                            (λ (i : ι), @ordered_comm_group.to_add_comm_group.{u_2} (β i) (_inst_2 i))))
                      (@add_comm_group.add_zero.{(max u_1 u_2)} (Π (i : ι), β i)
                         (@pi.add_comm_group.{u_1 u_2} ι (λ (i : ι), β i)
                            (λ (i : ι), @ordered_comm_group.to_add_comm_group.{u_2} (β i) (_inst_2 i))))
                      (@add_comm_group.neg.{(max u_1 u_2)} (Π (i : ι), β i)
                         (@pi.add_comm_group.{u_1 u_2} ι (λ (i : ι), β i)
                            (λ (i : ι), @ordered_comm_group.to_add_comm_group.{u_2} (β i) (_inst_2 i))))
                      (@add_comm_group.add_left_neg.{(max u_1 u_2)} (Π (i : ι), β i)
                         (@pi.add_comm_group.{u_1 u_2} ι (λ (i : ι), β i)
                            (λ (i : ι), @ordered_comm_group.to_add_comm_group.{u_2} (β i) (_inst_2 i))))
                      (@add_comm_group.add_comm.{(max u_1 u_2)} (Π (i : ι), β i)
                         (@pi.add_comm_group.{u_1 u_2} ι (λ (i : ι), β i)
                            (λ (i : ι), @ordered_comm_group.to_add_comm_group.{u_2} (β i) (_inst_2 i)))))))))
       z
       x)
    (@has_add.add.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@add_semigroup.to_has_add.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@add_monoid.to_add_semigroup.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@add_group.to_add_monoid.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@add_comm_group.to_add_group.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                   (@add_comm_group.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                      (@add_comm_group.add.{(max u_1 u_2)} (Π (i : ι), β i)
                         (@pi.add_comm_group.{u_1 u_2} ι (λ (i : ι), β i)
                            (λ (i : ι), @ordered_comm_group.to_add_comm_group.{u_2} (β i) (_inst_2 i))))
                      (@add_comm_group.add_assoc.{(max u_1 u_2)} (Π (i : ι), β i)
                         (@pi.add_comm_group.{u_1 u_2} ι (λ (i : ι), β i)
                            (λ (i : ι), @ordered_comm_group.to_add_comm_group.{u_2} (β i) (_inst_2 i))))
                      (@add_comm_group.zero.{(max u_1 u_2)} (Π (i : ι), β i)
                         (@pi.add_comm_group.{u_1 u_2} ι (λ (i : ι), β i)
                            (λ (i : ι), @ordered_comm_group.to_add_comm_group.{u_2} (β i) (_inst_2 i))))
                      (@add_comm_group.zero_add.{(max u_1 u_2)} (Π (i : ι), β i)
                         (@pi.add_comm_group.{u_1 u_2} ι (λ (i : ι), β i)
                            (λ (i : ι), @ordered_comm_group.to_add_comm_group.{u_2} (β i) (_inst_2 i))))
                      (@add_comm_group.add_zero.{(max u_1 u_2)} (Π (i : ι), β i)
                         (@pi.add_comm_group.{u_1 u_2} ι (λ (i : ι), β i)
                            (λ (i : ι), @ordered_comm_group.to_add_comm_group.{u_2} (β i) (_inst_2 i))))
                      (@add_comm_group.neg.{(max u_1 u_2)} (Π (i : ι), β i)
                         (@pi.add_comm_group.{u_1 u_2} ι (λ (i : ι), β i)
                            (λ (i : ι), @ordered_comm_group.to_add_comm_group.{u_2} (β i) (_inst_2 i))))
                      (@add_comm_group.add_left_neg.{(max u_1 u_2)} (Π (i : ι), β i)
                         (@pi.add_comm_group.{u_1 u_2} ι (λ (i : ι), β i)
                            (λ (i : ι), @ordered_comm_group.to_add_comm_group.{u_2} (β i) (_inst_2 i))))
                      (@add_comm_group.add_comm.{(max u_1 u_2)} (Π (i : ι), β i)
                         (@pi.add_comm_group.{u_1 u_2} ι (λ (i : ι), β i)
                            (λ (i : ι), @ordered_comm_group.to_add_comm_group.{u_2} (β i) (_inst_2 i)))))))))
       z
       y),
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1))))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι),
              @preorder.to_has_lt.{u_2} (β a)
                (@partial_order.to_preorder.{u_2} (β a)
                   ((λ (a : ι),
                       @ordered_comm_monoid.to_partial_order.{u_2} (β a)
                         (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a)
                            (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a))))
                      a)))
             _x))
       i
       (x i)
       (y i)),
j : ι,
hji :
  @has_lt.lt.{u_1} ι
    (@preorder.to_has_lt.{u_1} ι
       (@partial_order.to_preorder.{u_1} ι
          (@lattice.semilattice_inf.to_partial_order.{u_1} ι
             (@lattice.lattice.to_semilattice_inf.{u_1} ι
                (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1))))))
    j
    i
⊢ @eq.{u_2+1} (β j)
    (@has_add.add.{u_2} (β j)
       (@add_semigroup.to_has_add.{u_2} (β j)
          (@add_monoid.to_add_semigroup.{u_2} (β j)
             (@add_group.to_add_monoid.{u_2} (β j)
                (@add_comm_group.to_add_group.{u_2} (β j)
                   (@ordered_comm_group.to_add_comm_group.{u_2} (β j) (_inst_2 j))))))
       (z j)
       (x j))
    (@has_add.add.{u_2} (β j)
       (@add_semigroup.to_has_add.{u_2} (β j)
          (@add_monoid.to_add_semigroup.{u_2} (β j)
             (@add_group.to_add_monoid.{u_2} (β j)
                (@add_comm_group.to_add_group.{u_2} (β j)
                   (@ordered_comm_group.to_add_comm_group.{u_2} (β j) (_inst_2 j))))))
       (z j)
       (y j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92            add_lt_add_left hi.2 _⟩)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='add_lt_add_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='and.right'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ordered_group.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : ordered_cancel_comm_monoid.{u} α] {a b : α}, @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@ordered_cancel_comm_monoid.to_partial_order.{u} α _inst_1))) a b → ∀ (c : α), @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@ordered_cancel_comm_monoid.to_partial_order.{u} α _inst_1))) (@has_add.add.{u} α (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α (@add_comm_monoid.to_add_monoid.{u} α (@ordered_cancel_comm_monoid.to_add_comm_monoid.{u} α _inst_1)))) c a) (@has_add.add.{u} α (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α (@add_comm_monoid.to_add_monoid.{u} α (@ordered_cancel_comm_monoid.to_add_comm_monoid.{u} α _inst_1)))) c b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {a b : Prop}, and a b → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93        (λ hxy, hxy ▸ le_refl _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='hxy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hxy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='le_refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@eq.{(max u_1 u_2)+1} (pilex.{u_1 u_2} ι β) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type (max u_1 u_2)} {P : α → Prop} {a b : α}, @eq.{(max u_1 u_2)+1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] (a : α), @has_le.le.{u} α (@preorder.to_has_le.{u} α _inst_1) a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94    add_lt_add_left := λ x y ⟨i, hi⟩ z,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@preorder.to_has_lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.partial_order.{u_1 u_2} ι β _inst_1 (λ (a : ι), @ordered_comm_monoid.to_partial_order.{u_2} (β a) (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a) (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a)))))) (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.partial_order.{u_1 u_2} ι β _inst_1 (λ (a : ι), @ordered_comm_monoid.to_partial_order.{u_2} (β a) (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a) (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a)))))) (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.partial_order.{u_1 u_2} ι β _inst_1 (λ (a : ι), @ordered_comm_monoid.to_partial_order.{u_2} (β a) (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a) (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a)))))) (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.partial_order.{u_1 u_2} ι β _inst_1 (λ (a : ι), @ordered_comm_monoid.to_partial_order.{u_2} (β a) (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a) (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a)))))) (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.partial_order.{u_1 u_2} ι β _inst_1 (λ (a : ι), @ordered_comm_monoid.to_partial_order.{u_2} (β a) (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a) (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a)))))) (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β) (@pilex.partial_order.{u_1 u_2} ι β _inst_1 (λ (a : ι), @ordered_comm_monoid.to_partial_order.{u_2} (β a) (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a) (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a))))))))) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='and (∀ (j : ι), @has_lt.lt.{u_1} ι (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1)))))) j i → @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j)) ((λ (_x : ι), @has_lt.lt.{u_2} (β _x) ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) ((λ (a : ι), @ordered_comm_monoid.to_partial_order.{u_2} (β a) (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a) (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a)))) a))) _x)) i (x i) (y i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95      ⟨i, λ j hji, show z j + x j = z j + y j, by rw [hi.1 j hji],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hji'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hji'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_lt.lt.{u_1} ι (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1)))))) j i'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_add.{u_2} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_add.{u_2} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pilex.{u_1 u_2} ι β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (∀ (j : ι), @has_lt.lt.{u_1} ι (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1)))))) j i → @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j)) ((λ (_x : ι), @has_lt.lt.{u_2} (β _x) ((λ (a : ι), @preorder.to_has_lt.{u_2} (β a) (@partial_order.to_preorder.{u_2} (β a) ((λ (a : ι), @ordered_comm_monoid.to_partial_order.{u_2} (β a) (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a) (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a)))) a))) _x)) i (x i) (y i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{u_1} ι (@preorder.to_has_lt.{u_1} ι (@partial_order.to_preorder.{u_1} ι (@lattice.semilattice_inf.to_partial_order.{u_1} ι (@lattice.lattice.to_semilattice_inf.{u_1} ι (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1)))))) j i'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='lime'><a title='ι : Type u_1,
β : ι → Type u_2,
_inst_1 : linear_order.{u_1} ι,
_inst_2 : Π (a : ι), ordered_comm_group.{u_2} (β a),
x y : pilex.{u_1 u_2} ι β,
_x :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@preorder.to_has_lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι),
                      @ordered_comm_monoid.to_partial_order.{u_2} (β a)
                        (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a)
                           (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a))))))
             (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι),
                      @ordered_comm_monoid.to_partial_order.{u_2} (β a)
                        (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a)
                           (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a))))))
             (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι),
                      @ordered_comm_monoid.to_partial_order.{u_2} (β a)
                        (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a)
                           (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a))))))
             (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι),
                      @ordered_comm_monoid.to_partial_order.{u_2} (β a)
                        (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a)
                           (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a))))))
             (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι),
                      @ordered_comm_monoid.to_partial_order.{u_2} (β a)
                        (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a)
                           (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a))))))
             (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι),
                      @ordered_comm_monoid.to_partial_order.{u_2} (β a)
                        (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a)
                           (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a)))))))))
    x
    y,
_fun_match :
  @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
    (@preorder.to_has_lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
       (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
          (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
             (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι),
                      @ordered_comm_monoid.to_partial_order.{u_2} (β a)
                        (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a)
                           (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a))))))
             (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι),
                      @ordered_comm_monoid.to_partial_order.{u_2} (β a)
                        (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a)
                           (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a))))))
             (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι),
                      @ordered_comm_monoid.to_partial_order.{u_2} (β a)
                        (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a)
                           (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a))))))
             (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι),
                      @ordered_comm_monoid.to_partial_order.{u_2} (β a)
                        (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a)
                           (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a))))))
             (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι),
                      @ordered_comm_monoid.to_partial_order.{u_2} (β a)
                        (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a)
                           (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a))))))
             (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                   (λ (a : ι),
                      @ordered_comm_monoid.to_partial_order.{u_2} (β a)
                        (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a)
                           (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a)))))))))
    x
    y →
  ∀ (c : pilex.{u_1 u_2} ι β),
    @has_lt.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
      (@preorder.to_has_lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
         (@partial_order.to_preorder.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@partial_order.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@partial_order.le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                  (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                     (λ (a : ι),
                        @ordered_comm_monoid.to_partial_order.{u_2} (β a)
                          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a)
                             (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a))))))
               (@partial_order.lt.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                  (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                     (λ (a : ι),
                        @ordered_comm_monoid.to_partial_order.{u_2} (β a)
                          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a)
                             (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a))))))
               (@partial_order.le_refl.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                  (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                     (λ (a : ι),
                        @ordered_comm_monoid.to_partial_order.{u_2} (β a)
                          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a)
                             (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a))))))
               (@partial_order.le_trans.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                  (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                     (λ (a : ι),
                        @ordered_comm_monoid.to_partial_order.{u_2} (β a)
                          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a)
                             (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a))))))
               (@partial_order.lt_iff_le_not_le.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                  (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                     (λ (a : ι),
                        @ordered_comm_monoid.to_partial_order.{u_2} (β a)
                          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a)
                             (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a))))))
               (@partial_order.le_antisymm.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                  (@pilex.partial_order.{u_1 u_2} ι β _inst_1
                     (λ (a : ι),
                        @ordered_comm_monoid.to_partial_order.{u_2} (β a)
                          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a)
                             (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a)))))))))
      (@has_add.add.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
         (@add_semigroup.to_has_add.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@add_monoid.to_add_semigroup.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@add_group.to_add_monoid.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                  (@add_comm_group.to_add_group.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                     (@add_comm_group.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                        (@add_comm_group.add.{(max u_1 u_2)} (Π (i : ι), β i)
                           (@pi.add_comm_group.{u_1 u_2} ι (λ (i : ι), β i)
                              (λ (i : ι), @ordered_comm_group.to_add_comm_group.{u_2} (β i) (_inst_2 i))))
                        (@add_comm_group.add_assoc.{(max u_1 u_2)} (Π (i : ι), β i)
                           (@pi.add_comm_group.{u_1 u_2} ι (λ (i : ι), β i)
                              (λ (i : ι), @ordered_comm_group.to_add_comm_group.{u_2} (β i) (_inst_2 i))))
                        (@add_comm_group.zero.{(max u_1 u_2)} (Π (i : ι), β i)
                           (@pi.add_comm_group.{u_1 u_2} ι (λ (i : ι), β i)
                              (λ (i : ι), @ordered_comm_group.to_add_comm_group.{u_2} (β i) (_inst_2 i))))
                        (@add_comm_group.zero_add.{(max u_1 u_2)} (Π (i : ι), β i)
                           (@pi.add_comm_group.{u_1 u_2} ι (λ (i : ι), β i)
                              (λ (i : ι), @ordered_comm_group.to_add_comm_group.{u_2} (β i) (_inst_2 i))))
                        (@add_comm_group.add_zero.{(max u_1 u_2)} (Π (i : ι), β i)
                           (@pi.add_comm_group.{u_1 u_2} ι (λ (i : ι), β i)
                              (λ (i : ι), @ordered_comm_group.to_add_comm_group.{u_2} (β i) (_inst_2 i))))
                        (@add_comm_group.neg.{(max u_1 u_2)} (Π (i : ι), β i)
                           (@pi.add_comm_group.{u_1 u_2} ι (λ (i : ι), β i)
                              (λ (i : ι), @ordered_comm_group.to_add_comm_group.{u_2} (β i) (_inst_2 i))))
                        (@add_comm_group.add_left_neg.{(max u_1 u_2)} (Π (i : ι), β i)
                           (@pi.add_comm_group.{u_1 u_2} ι (λ (i : ι), β i)
                              (λ (i : ι), @ordered_comm_group.to_add_comm_group.{u_2} (β i) (_inst_2 i))))
                        (@add_comm_group.add_comm.{(max u_1 u_2)} (Π (i : ι), β i)
                           (@pi.add_comm_group.{u_1 u_2} ι (λ (i : ι), β i)
                              (λ (i : ι), @ordered_comm_group.to_add_comm_group.{u_2} (β i) (_inst_2 i)))))))))
         c
         x)
      (@has_add.add.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
         (@add_semigroup.to_has_add.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
            (@add_monoid.to_add_semigroup.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
               (@add_group.to_add_monoid.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                  (@add_comm_group.to_add_group.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                     (@add_comm_group.mk.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)
                        (@add_comm_group.add.{(max u_1 u_2)} (Π (i : ι), β i)
                           (@pi.add_comm_group.{u_1 u_2} ι (λ (i : ι), β i)
                              (λ (i : ι), @ordered_comm_group.to_add_comm_group.{u_2} (β i) (_inst_2 i))))
                        (@add_comm_group.add_assoc.{(max u_1 u_2)} (Π (i : ι), β i)
                           (@pi.add_comm_group.{u_1 u_2} ι (λ (i : ι), β i)
                              (λ (i : ι), @ordered_comm_group.to_add_comm_group.{u_2} (β i) (_inst_2 i))))
                        (@add_comm_group.zero.{(max u_1 u_2)} (Π (i : ι), β i)
                           (@pi.add_comm_group.{u_1 u_2} ι (λ (i : ι), β i)
                              (λ (i : ι), @ordered_comm_group.to_add_comm_group.{u_2} (β i) (_inst_2 i))))
                        (@add_comm_group.zero_add.{(max u_1 u_2)} (Π (i : ι), β i)
                           (@pi.add_comm_group.{u_1 u_2} ι (λ (i : ι), β i)
                              (λ (i : ι), @ordered_comm_group.to_add_comm_group.{u_2} (β i) (_inst_2 i))))
                        (@add_comm_group.add_zero.{(max u_1 u_2)} (Π (i : ι), β i)
                           (@pi.add_comm_group.{u_1 u_2} ι (λ (i : ι), β i)
                              (λ (i : ι), @ordered_comm_group.to_add_comm_group.{u_2} (β i) (_inst_2 i))))
                        (@add_comm_group.neg.{(max u_1 u_2)} (Π (i : ι), β i)
                           (@pi.add_comm_group.{u_1 u_2} ι (λ (i : ι), β i)
                              (λ (i : ι), @ordered_comm_group.to_add_comm_group.{u_2} (β i) (_inst_2 i))))
                        (@add_comm_group.add_left_neg.{(max u_1 u_2)} (Π (i : ι), β i)
                           (@pi.add_comm_group.{u_1 u_2} ι (λ (i : ι), β i)
                              (λ (i : ι), @ordered_comm_group.to_add_comm_group.{u_2} (β i) (_inst_2 i))))
                        (@add_comm_group.add_comm.{(max u_1 u_2)} (Π (i : ι), β i)
                           (@pi.add_comm_group.{u_1 u_2} ι (λ (i : ι), β i)
                              (λ (i : ι), @ordered_comm_group.to_add_comm_group.{u_2} (β i) (_inst_2 i)))))))))
         c
         y),
i : ι,
hi :
  and
    (∀ (j : ι),
       @has_lt.lt.{u_1} ι
         (@preorder.to_has_lt.{u_1} ι
            (@partial_order.to_preorder.{u_1} ι
               (@lattice.semilattice_inf.to_partial_order.{u_1} ι
                  (@lattice.lattice.to_semilattice_inf.{u_1} ι
                     (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1))))))
         j
         i →
       @eq.{u_2+1} ((λ (a : ι), β a) j) (x j) (y j))
    ((λ (_x : ι),
        @has_lt.lt.{u_2} (β _x)
          ((λ (a : ι),
              @preorder.to_has_lt.{u_2} (β a)
                (@partial_order.to_preorder.{u_2} (β a)
                   ((λ (a : ι),
                       @ordered_comm_monoid.to_partial_order.{u_2} (β a)
                         (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (β a)
                            (@ordered_comm_group.to_ordered_cancel_comm_monoid.{u_2} (β a) (_inst_2 a))))
                      a)))
             _x))
       i
       (x i)
       (y i)),
z : pilex.{u_1 u_2} ι β,
j : ι,
hji :
  @has_lt.lt.{u_1} ι
    (@preorder.to_has_lt.{u_1} ι
       (@partial_order.to_preorder.{u_1} ι
          (@lattice.semilattice_inf.to_partial_order.{u_1} ι
             (@lattice.lattice.to_semilattice_inf.{u_1} ι
                (@lattice.lattice_of_decidable_linear_order.{u_1} ι (@classical.DLO.{u_1} ι _inst_1))))))
    j
    i
⊢ @eq.{u_2+1} (β j)
    (@has_add.add.{u_2} (β j)
       (@add_semigroup.to_has_add.{u_2} (β j)
          (@add_monoid.to_add_semigroup.{u_2} (β j)
             (@add_group.to_add_monoid.{u_2} (β j)
                (@add_comm_group.to_add_group.{u_2} (β j)
                   (@ordered_comm_group.to_add_comm_group.{u_2} (β j) (_inst_2 j))))))
       (z j)
       (x j))
    (@has_add.add.{u_2} (β j)
       (@add_semigroup.to_has_add.{u_2} (β j)
          (@add_monoid.to_add_semigroup.{u_2} (β j)
             (@add_group.to_add_monoid.{u_2} (β j)
                (@add_comm_group.to_add_group.{u_2} (β j)
                   (@ordered_comm_group.to_add_comm_group.{u_2} (β j) (_inst_2 j))))))
       (z j)
       (y j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96        add_lt_add_left hi.2 _⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='add_lt_add_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='and.right'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ordered_group.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : ordered_cancel_comm_monoid.{u} α] {a b : α}, @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@ordered_cancel_comm_monoid.to_partial_order.{u} α _inst_1))) a b → ∀ (c : α), @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@ordered_cancel_comm_monoid.to_partial_order.{u} α _inst_1))) (@has_add.add.{u} α (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α (@add_comm_monoid.to_add_monoid.{u} α (@ordered_cancel_comm_monoid.to_add_comm_monoid.{u} α _inst_1)))) c a) (@has_add.add.{u} α (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α (@add_comm_monoid.to_add_monoid.{u} α (@ordered_cancel_comm_monoid.to_add_comm_monoid.{u} α _inst_1)))) c b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {a b : Prop}, and a b → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97    ..pilex.partial_order,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='pilex.partial_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 25, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {ι : Type u_1} {β : ι → Type u_2} [_inst_1 : linear_order.{u_1} ι] [_inst_2 : Π (a : ι), partial_order.{u_2} (β a)], partial_order.{(max u_1 u_2)} (pilex.{u_1 u_2} ι β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98    ..pi.add_comm_group }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='pi.add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/pi_instances.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {I : Type u} {f : I → Type v} [_inst_1 : Π (i : I), add_comm_group.{v} (f i)], add_comm_group.{(max u v)} (Π (i : I), f i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font></pre>
</body>